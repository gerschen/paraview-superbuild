diff -u -U5 -r silo-4.11-bsd/src/hdf5_drv/H5FDsilo.c silo-4.11-bsd.warning-preproc-mask/src/hdf5_drv/H5FDsilo.c
--- silo-4.11-bsd/src/hdf5_drv/H5FDsilo.c	2021-09-10 18:22:52.000000000 -0400
+++ silo-4.11-bsd.warning-preproc-mask/src/hdf5_drv/H5FDsilo.c	2022-09-13 11:43:43.091361812 -0400
@@ -495,11 +495,11 @@
                 size_t size, void *buf);
 static herr_t H5FD_silo_write(H5FD_t *lf, H5FD_mem_t type, hid_t fapl_id, haddr_t addr,
                 size_t size, const void *buf);
 static herr_t H5FD_silo_truncate(H5FD_t *_file, hid_t dxpl_id, hbool_t closing);
 
-#warning REMOVE ME
+/* #warning REMOVE ME */
 #if 0
 typedef struct H5FD_class_t {
     const char *name;
     haddr_t maxaddr;
     H5F_close_degree_t fc_degree;
@@ -1976,11 +1976,11 @@
 H5FD_silo_get_eof(const H5FD_t *_file, H5FD_mem_t type)
 #else
 H5FD_silo_get_eof(const H5FD_t *_file)
 #endif
 {
-#warning TAKE ADVANTAGE OF TYPE INFO HERE
+/* #warning TAKE ADVANTAGE OF TYPE INFO HERE */
     const H5FD_silo_t	*file = (const H5FD_silo_t *)_file;
 
     return(MAX(file->eof, file->eoa));
 }
 
diff -u -U5 -r silo-4.11-bsd/src/hdf5_drv/silo_hdf5.c silo-4.11-bsd.warning-preproc-mask/src/hdf5_drv/silo_hdf5.c
--- silo-4.11-bsd/src/hdf5_drv/silo_hdf5.c	2021-09-10 18:22:52.000000000 -0400
+++ silo-4.11-bsd.warning-preproc-mask/src/hdf5_drv/silo_hdf5.c	2022-09-13 11:43:43.183361809 -0400
@@ -56,11 +56,11 @@
    in this file uses version 1.6 of the HDF5 API. This is harmless for
    versions of HDF5 before 1.8 and ensures correct compilation with
    version 1.8 and thereafter. When, and if, the HDF5 code in this file
    is explicitly upgraded to the 1.8 API, this symbol should be removed. */
 #define H5_USE_16_API
-#warning DO WE NEED THIS HEADER FILE
+/* #warning DO WE NEED THIS HEADER FILE */
 #include <H5pubconf.h>
 #include <hdf5.h>
 
 #include <errno.h>
 #include <assert.h>
@@ -2150,11 +2150,11 @@
     ((struct HZMCODECbase *) db_hdf5_hzip_params.params)->bits = 12;
 #endif
 
 #if HDF5_VERSION_GE(1,8,0) && !defined(H5_USE_16_API)
     db_hdf5_hzip_class.version = H5Z_CLASS_T_VERS;
-#warning SHOULD WE DISABLE HZIP AND FPZIP ENCODING
+/* #warning SHOULD WE DISABLE HZIP AND FPZIP ENCODING */
     db_hdf5_hzip_class.encoder_present = 1;
     db_hdf5_hzip_class.decoder_present = 1;
 #endif
     db_hdf5_hzip_class.id = DB_HDF5_HZIP_ID;
     db_hdf5_hzip_class.name = "Lindstrom-hzip";
@@ -2794,11 +2794,11 @@
     dbfile->pub.cd = db_hdf5_SetDir;
     dbfile->pub.g_dir = db_hdf5_GetDir;
     dbfile->pub.newtoc = db_hdf5_NewToc;
     dbfile->pub.mkdir = db_hdf5_MkDir;
     dbfile->pub.cpdir = db_hdf5_CpDir;
-#warning GET RID OF CPLISTEDOBJECTS
+/* #warning GET RID OF CPLISTEDOBJECTS */
     dbfile->pub.cpnobjs = db_hdf5_CpListedObjects;
     dbfile->pub.mksymlink = db_hdf5_MkSymlink;
     dbfile->pub.g_symlink = db_hdf5_GetSymlink;
 
     /* Variable inquiries */
@@ -3342,11 +3342,11 @@
         if (DB_HDF5_HZIP_ID==filtn)
             have_hzip = TRUE;
         if (H5Z_FILTER_ZFP==filtn)
             have_zfp = TRUE;
     }
-#warning WHAT ABOUT NULL RETURN FROM DBGETCOMPRESSION
+/* #warning WHAT ABOUT NULL RETURN FROM DBGETCOMPRESSION */
 /* Handle some global compression parameters */
     if ((ptr=(char *)strstr(DBGetCompressionFile(dbfile), 
        "ERRMODE=")) != (char *)NULL) 
     {
         (void)strncpy(chararray, ptr+8, 4); 
@@ -3373,11 +3373,11 @@
         {
             db_perror(DBGetCompressionFile(dbfile), E_COMPRESSION, me);
             return (-1);
         }
     }
-#warning FIX MISSING .compressionMinsize member
+/* #warning FIX MISSING .compressionMinsize member */
 #if 0
     if ((ptr=(char *)strstr(DBGetCompressionFile(dbfile), 
        "MINSIZE=")) != (char *)NULL) 
     {
         unsigned int minsize;
@@ -3391,11 +3391,11 @@
             return -1;
         }
     }
 #endif
 
-#warning QUERY FILE LEVEL COMPRESSION PARAMS HERE
+/* #warning QUERY FILE LEVEL COMPRESSION PARAMS HERE */
     opt_flag = SILO_Globals.compressionErrmode == COMPRESSION_ERRMODE_FALLBACK ?
                    H5Z_FLAG_OPTIONAL : H5Z_FLAG_MANDATORY;
 
     /* Select the compression algorthm */
     if ((ptr=(char *)strstr(DBGetCompressionFile(dbfile), 
@@ -4116,11 +4116,11 @@
         nvals = &(toc->nobj);
         break;
     }
 
     /* Append to table of contents */
-#warning REVISIT THIS CODE BLOCK
+/* #warning REVISIT THIS CODE BLOCK */
 #if 0
     if (islink) {
         int n = toc->nsymlink++;
         toc->symlink_names = (char **) realloc(toc->symlink_names, (n+1)*sizeof(char*));
         toc->symlink_names[n] = STRDUP(name);
@@ -4731,11 +4731,11 @@
 }
     static int n = 0;
     static int const nmax = 32;
     static char *cbuf[32] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
-#warning HARD CODED SIZE HERE
+/* #warning HARD CODED SIZE HERE */
     static char cwgname[4096];
     char *parent_objdirname = 0;
     char *parent_fullname = 0;
     char *child_fullname = 0;
 
@@ -4955,18 +4955,18 @@
     H5AC_cache_config_t h5mdc_config;
 #endif
 
     /* Performance optimizations for memory footprint */
 #if HDF5_VERSION_GE(1,8,0)
-#warning FIX ME...THIS NEEDS TO BE CONDITION ON COMPAT MODE WORKS FOR 1.8.0
+/* #warning FIX ME...THIS NEEDS TO BE CONDITION ON COMPAT MODE WORKS FOR 1.8.0 */
     /*H5Pset_libver_bounds(retval, H5F_LIBVER_LATEST, H5F_LIBVER_LATEST);*/
 
 #if HDF5_VERSION_GE(1,10,1)
     H5Pset_evict_on_close(retval, (hbool_t)1);
 #endif
 
-#warning SET FRIENDLY NAMES TO 2 but only at file level
+/* #warning SET FRIENDLY NAMES TO 2 but only at file level */
     /*DBSetFriendlyHDF5NamesFile((DBfile*)dbfile, 2);*/
 
     /* First, initialize our copy of h5mdc_config */
     h5mdc_config.version = H5AC__CURR_CACHE_CONFIG_VERSION;
     H5Pget_mdc_config(retval, &h5mdc_config);
@@ -4999,11 +4999,11 @@
 
     /* Handle cases where we are running on Windows. If a client
        request anything other than the default driver, we issue
        a warning message and continue only on windows (default) vfd. */
 #if !defined(_WIN32)
-#warning REMOVED WINDOWS SPECIFIC CHECK
+/* #warning REMOVED WINDOWS SPECIFIC CHECK */
 #endif
 #if 0
 #if defined(_WIN32)
     if (opts_set_id != DB_FILE_OPTS_H5_DEFAULT_DEFAULT && 
         opts_set_id < NUM_DEFAULT_FILE_OPTIONS_SETS)
@@ -5089,11 +5089,11 @@
         }
 
         /* default HDF5 mpi drivers */
         case DB_FILE_OPTS_H5_DEFAULT_MPIP:
         {
-#warning DO WE STILL NEED THIS
+/* #warning DO WE STILL NEED THIS */
             H5Pclose(retval);
             return db_perror("HDF5 MPI VFD", E_NOTENABLEDINBUILD, me);
             break;
         }
 
@@ -5153,11 +5153,11 @@
                 p = DBGetOption(opts, DBOPT_H5_USER_DRIVER_INFO);
                 h5status |= H5Pset_driver(retval, new_driver_id, p);
             }
 
 #if !defined(_WIN32)
-#warning REMOVED WINDOWS SPECIFIC CHECK
+/* #warning REMOVED WINDOWS SPECIFIC CHECK */
 #endif
 #if 0
 #if defined(_WIN32)
             if (vfd != DB_H5VFD_DEFAULT)
             {
@@ -5428,11 +5428,11 @@
                         h5status |= H5Pset_fapl_mpio(retval, mpi_comm, mpi_info);
                         if (created_info) MPI_Info_free(&mpi_info);
                     }
                     else
                     {
-#warning DO WE STILL NEED THIS
+/* #warning DO WE STILL NEED THIS */
                         H5Pclose(retval);
                         return db_perror("HDF5 MPIPOSIX VFD not available in >HDF5-1.8.12", E_NOTENABLEDINBUILD, me);
                     }
 #else 
                     H5Pclose(retval);
@@ -5512,11 +5512,11 @@
                 h5status |= H5Pset_cache(retval, 0, nelmts, nbytes, policy);
             }
         }
     }
 
-#warning FIX THIS
+/* #warning FIX THIS */
 #if 0
     /* Handle cases where we are running on Windows. We need to ensure
        that fapl VFD is windows. So, we re-set fapl here if running on windows.
        The intent is that all other fapl properties that are not specific to
        the VFD will pass through ok but that anything that winds up setting
@@ -5966,11 +5966,11 @@
          * of '1' for istore_k */
         int created_fcprops = 0;
         if (fcprops == -1)
         {
             fcprops = H5Pcreate(H5P_FILE_CREATE);
-#warning BACKWARD COMPAT ISSUE FOR HDF5
+/* #warning BACKWARD COMPAT ISSUE FOR HDF5 */
             /*H5Pset_istore_k(fcprops, 1);*/
             created_fcprops = 1;
         }
         fid = H5Fcreate(name, H5F_ACC_TRUNC, fcprops, faprops);
         if (created_fcprops)
@@ -6001,11 +6001,11 @@
     dbfile->pub.Grab = FALSE;
     fidp = (hid_t *) malloc(sizeof(hid_t));
     *fidp = fid;
     dbfile->pub.GrabId = (void*) fidp;
     dbfile->fid = fid;
-#warning FIX FILE SCOPE GLOBAL INITIALIZATION
+/* #warning FIX FILE SCOPE GLOBAL INITIALIZATION */
 #if 0
     *(dbfile->pub.file_scope_globals) = SILO_Globals;
 #endif
     return db_hdf5_finish_create(dbfile, target, finfo);
 }
@@ -6465,11 +6465,11 @@
             (atype=H5Aget_type(attr))<0) {
             db_perror(name, E_CALLFAIL, me);
             UNWIND();
         }
         asize = H5Tget_size(atype);
-#warning WHY THIS SIZE
+/* #warning WHY THIS SIZE */
         msize = MAX(asize, 3*1024);
         if (NULL==(file_value=(char *)malloc(asize)) ||
             NULL==(mem_value=(char *)malloc(msize)) ||
             NULL==(bkg=(char *)malloc(msize))) {
             db_perror(name, E_NOMEM, me);
@@ -6634,11 +6634,11 @@
     } END_PROTECT;
 
     return 0;
 }
 
-#warning REMOVE THIS MAYBE
+/* #warning REMOVE THIS MAYBE */
 SILO_CALLBACK int
 db_hdf5_CpListedObjects(int nobjs,
     DBfile *_dbfile, char const * const *srcObjs,
     DBfile *dstFile, char const * const *dstObjs)
 {
@@ -7371,11 +7371,11 @@
                 *(double*)(object+moffset) = strtod(obj->pdb_names[i]+4, NULL);
                 moffset += sizeof(double);
                 foffset += H5Tget_size(dbfile->T_double);
             } else if (!strncmp(obj->pdb_names[i], "'<s>", 4)) {
                 size_t len = strlen(obj->pdb_names[i]+4)-1;
-#warning COMPATABILITY ISSUE
+/* #warning COMPATABILITY ISSUE */
                 hid_t str_type;
                 if (len > 1024 && !DBGetAllowLongStrComponentsFile(_dbfile))
                 {
                     db_perror("encountered Str component > 1024 chars", E_CALLFAIL, me);
                     UNWIND();
@@ -7744,11 +7744,11 @@
     static char *me = "db_hdf5_GetVarByteLength";
     hid_t       dset=-1, ftype=-1, mtype=-1, space=-1;
     hsize_t     nbytes_big;
     int         nbytes_small=-1;
 
-#warning REMOVED db_perror CALLS
+/* #warning REMOVED db_perror CALLS */
     PROTECT {
         /* Open the dataset */
         if ((dset=H5Dopen(dbfile->cwg, name))>=0) {
         
             /* Get data type and space */
@@ -8390,11 +8390,11 @@
                if (ds_size[i]<(hsize_t)dims[i]) {
                    db_perror("dims", E_BADARGS, me);
                    UNWIND();
                }
            }
-#warning WHAT IF EXISTING DATASET WAS COMPRESSED
+/* #warning WHAT IF EXISTING DATASET WAS COMPRESSED */
        } else {
            /* Create memory and file data space (both identical) */
            for (i=0; i<ndims; i++) ds_size[i] = dims[i];
            if ((space=H5Screate_simple(ndims, ds_size, NULL))<0) {
                db_perror("data space", E_CALLFAIL, me);
@@ -8432,11 +8432,11 @@
            (fclass = H5Tget_class(dset_type))<0 ||
            (mclass = H5Tget_class(mtype))<0) {
            db_perror(vname, E_CALLFAIL, me);
            UNWIND();
        }
-#warning COMPARE TO -1 OR TO NEGATIVE
+/* #warning COMPARE TO -1 OR TO NEGATIVE */
        if (dset_type != -1)
            H5Tclose(dset_type);
        if (mclass != fclass) {
            db_perror(vname, E_CALLFAIL, me);
            UNWIND();
@@ -8454,11 +8454,11 @@
        H5Sclose(space);
    } CLEANUP {
        H5E_BEGIN_TRY {
            H5Dclose(dset);
            H5Sclose(space);
-#warning COMPARE TO -1 OR NEGATIVE
+/* #warning COMPARE TO -1 OR NEGATIVE */
            if (dset_type != -1)
                H5Tclose(dset_type);
        } H5E_END_TRY;
    } END_PROTECT;
    
@@ -8679,11 +8679,11 @@
             db_perror(name, E_CALLFAIL, me);
             UNWIND();
         }
 
         /* Add members to the DBobject */
-#warning THIS IFDEFD CODE IS IN TRANSITION TO BETTER GENERIC OBJECTS
+/* #warning THIS IFDEFD CODE IS IN TRANSITION TO BETTER GENERIC OBJECTS */
         for (i=0; i<nmembs; i++) {
             int ndims = 0;
             hid_t member_type = db_hdf5_get_cmemb(atype, i, &ndims, memb_size);
             char *name = H5Tget_member_name(atype, i);
             hid_t mtype = H5Tcreate(H5T_COMPOUND, msize);
@@ -8776,16 +8776,16 @@
             free(name);
             H5Tclose(mtype);
             H5Tclose(member_type);
         }
 
-#warning REVISIT THIS CLEANUP CODE. IS THERE A BETTER SYMBOLIC VALUE THAN -1
+/* #warning REVISIT THIS CLEANUP CODE. IS THERE A BETTER SYMBOLIC VALUE THAN -1 */
         /* Cleanup */
         H5Tclose(atype);
         H5Aclose(attr);
         H5Tclose(o);
-#warning USE FREE() MACRO HERE
+/* #warning USE FREE() MACRO HERE */
         free(file_value);
         free(mem_value);
         free(bkg);
         
     } CLEANUP {
@@ -8793,11 +8793,11 @@
             H5Tclose(atype);
             H5Tclose(h5str);
             H5Aclose(attr);
             H5Tclose(o);
         } H5E_END_TRY;
-#warning USE FREE() MACRO HERE
+/* #warning USE FREE() MACRO HERE */
         if (file_value) free(file_value);
         if (mem_value) free(mem_value);
         if (bkg) free(bkg);
     } END_PROTECT;
 
@@ -11454,11 +11454,11 @@
             UNWIND();
         }
         for (i=0; i<nvars && nels; i++) {
             db_hdf5_compwrz(dbfile, datatype, 1, &nels, vars[i],
                 m.value[i]/*out*/, friendly_name(_dbfile,varnames[i], "_data", 0), compressionFlags);
-//#warning WHY NOT COMPRESS MIX DATA TOO
+/* //#warning WHY NOT COMPRESS MIX DATA TOO */
             if (mixvars && mixvars[i] && mixlen>0) {
                 db_hdf5_compwr(dbfile, datatype, 1, &mixlen, mixvars[i],
                     m.mixed_value[i]/*out*/, friendly_name(_dbfile,varnames[i], "_mix", 0));
             }
         }
@@ -14299,11 +14299,11 @@
         /*
          * Create a character string which is a semi-colon separated list of
          * material names.
          */
         /* Write raw data arrays */
-#warning REPLACE WITH STRING UTILITIES
+/* #warning REPLACE WITH STRING UTILITIES */
         if (nmats > 0 && matnames)
         {
             for (i=len=0; i<nmats; i++) len += strlen(matnames[i])+1;
             s = (char *)malloc(len+1);
             for (i=len=0; i<nmats; i++) {
@@ -14337,21 +14337,21 @@
             DBStringArrayToStringList((char const * const *)_mm._matcolors,
                 _mm._nmatnos, &tmp, &len);
             db_hdf5_compwr(dbfile, DB_CHAR, 1, &len, tmp,
                 m.mat_colors/*out*/, friendly_name(_dbfile,name,"_matcolors", 0));
             FREE(tmp);
-#warning IS THIS TAKEN CARE OF ELSEWHERE
+/* #warning IS THIS TAKEN CARE OF ELSEWHERE */
             _mm._matcolors = 0;
         }
         if (_mm._matnames && _mm._nmatnos > 0) {
             int len; char *tmp;
             DBStringArrayToStringList((char const * const *)_mm._matnames,
                 _mm._nmatnos, &tmp, &len);
             db_hdf5_compwr(dbfile, DB_CHAR, 1, &len, tmp,
                 m.material_names/*out*/, friendly_name(_dbfile,name,"_material_names", 0));
             FREE(tmp);
-#warning IS THIS TAKEN CARE OF ELSEWHERE
+/* #warning IS THIS TAKEN CARE OF ELSEWHERE */
             _mm._matnames = 0;
         }
         /* output nameschemes if we have 'em */
         if (_mm._file_ns)
         {
diff -u -U5 -r silo-4.11-bsd/src/hdf5_drv/silo_hdf5_private.h silo-4.11-bsd.warning-preproc-mask/src/hdf5_drv/silo_hdf5_private.h
--- silo-4.11-bsd/src/hdf5_drv/silo_hdf5_private.h	2021-09-10 18:22:52.000000000 -0400
+++ silo-4.11-bsd.warning-preproc-mask/src/hdf5_drv/silo_hdf5_private.h	2022-09-13 11:43:43.128361811 -0400
@@ -105,11 +105,11 @@
 SILO_CALLBACK int db_hdf5_MkDir(DBfile *_dbfile, char const *name);
 SILO_CALLBACK int db_hdf5_SetDir(DBfile *_dbfile, char const *name);
 SILO_CALLBACK int db_hdf5_GetDir(DBfile *_dbfile, char *name/*out*/);
 SILO_CALLBACK int db_hdf5_CpDir(DBfile *_dbfile, char const *srcDir,
                            DBfile *dstFile, char const *dstDir);
-#warning REMOVE db_hdf5_CpListedObjects
+/* #warning REMOVE db_hdf5_CpListedObjects */
 SILO_CALLBACK int db_hdf5_CpListedObjects(int nobjs,
                            DBfile *_dbfile, char const * const *srcObjs,
                            DBfile *dstFile, char const * const *dstObjs);
 SILO_CALLBACK int db_hdf5_MkSymlink(DBfile *_dbfile,
                           char const *target, char const *link);
diff -u -U5 -r silo-4.11-bsd/src/pdb/pdb.c silo-4.11-bsd.warning-preproc-mask/src/pdb/pdb.c
--- silo-4.11-bsd/src/pdb/pdb.c	2021-09-10 18:22:52.000000000 -0400
+++ silo-4.11-bsd.warning-preproc-mask/src/pdb/pdb.c	2022-09-13 11:43:43.153361810 -0400
@@ -1804,23 +1804,23 @@
 {
     lite_PD_buffer_size = s;
     return lite_PD_buffer_size;
 }
 
-#warning MOVE TO PDLOW.C
+/* #warning MOVE TO PDLOW.C */
 char *lite_PD_get_error(void)
 {
     return lite_PD_err;
 }
 
-#warning MOVE TO PDMEMB.C
+/* #warning MOVE TO PDMEMB.C */
 syment *lite_PD_query_entry(PDBfile *file, char *name, char *fullname)
 {
     return lite_PD_inquire_entry(file, name, TRUE, fullname);
 }
 
-#warning MOVE TO PDLOW.C
+/* #warning MOVE TO PDLOW.C */
 int lite_PD_get_entry_info(syment *ep, char **ptyp, long *pni, int *pnd, long **pdim)
 {
   /* code courtesy of Rob Managan */
   int rv;
   long nd;
@@ -1865,31 +1865,31 @@
   }
 
   return(rv);
 }
 
-#warning MOVE TO PDLOW.C
+/* #warning MOVE TO PDLOW.C */
 void lite_PD_free_entry_info(char *typ, long *pdim)
 {
   SFREE(typ);
   SFREE(pdim);
 }
 
-#warning MOVE TO PDLOW.C
+/* #warning MOVE TO PDLOW.C */
 void lite_PD_rel_entry_info(syment *ep, char *type, long *dims)
 {
     lite_PD_free_entry_info(type, dims);
     _lite_PD_rl_syment(ep);
 }
 
 /* 21Mar17 for Rob Managan */
-#warning MOVE TO PDBDIR.C
+/* #warning MOVE TO PDBDIR.C */
 int lite_PD_ln(PDBfile *file, char *oldname, char *newname)
 {
   /* Courtesy of Rob Managan */
   syment *oldep;
-#warning MAYBE INCREASE MAXLINE FOR LEOSPACT
+/* #warning MAYBE INCREASE MAXLINE FOR LEOSPACT */
   char newpath[MAXLINE], oldpath[MAXLINE], dirname[MAXLINE];
   char *nname, *s;
 
   if (file == NULL) {
 
@@ -1960,11 +1960,11 @@
   _lite_PD_e_install( nname, oldep, file->symtab);
 
   return(TRUE);
 }
 
-#warning SHOULD GO IN PDBMM.c
+/* #warning SHOULD GO IN PDBMM.c */
 void *_lite_PD_alloc_entry(PDBfile *file, char *type, long nitems)
 {
   void *vr;
   long len, bpi;
   defstr *dp;
diff -u -U5 -r silo-4.11-bsd/src/score/scctl.c silo-4.11-bsd.warning-preproc-mask/src/score/scctl.c
--- silo-4.11-bsd/src/score/scctl.c	2021-09-10 18:22:52.000000000 -0400
+++ silo-4.11-bsd.warning-preproc-mask/src/score/scctl.c	2022-09-13 12:07:09.385316915 -0400
@@ -66,11 +66,11 @@
 
 #include <sys/types.h>
 #include <sys/stat.h>
 
 /* Prototypes for other external functions. */
-#ifndef WIN32
+#ifdef _WIN32
 extern char *ctime(const time_t *);
 #else
 #include <unistd.h>
 #endif
 
@@ -234,11 +234,17 @@
     struct stat sbuf;
     statval = stat(name, &sbuf);
 #endif
     if (statval == 0)
     {
+#ifdef _WIN32
+#define _S_ISTYPE(mode, mask)  (((mode) & _S_IFMT) == (mask))
+        if (!_S_ISTYPE(sbuf.st_mode, _S_IFREG)) return FALSE;
+        if (!(sbuf.st_mode & _S_IREAD)) return FALSE;
+#else
         if (!S_ISREG(sbuf.st_mode)) return FALSE;
         if (!(sbuf.st_mode & (S_IRUSR | S_IROTH))) return FALSE;
+#endif
         return TRUE;
     }
     return FALSE;
 }
diff -u -U5 -r silo-4.11-bsd/src/silo/alloc.c silo-4.11-bsd.warning-preproc-mask/src/silo/alloc.c
--- silo-4.11-bsd/src/silo/alloc.c	2021-09-10 18:22:52.000000000 -0400
+++ silo-4.11-bsd.warning-preproc-mask/src/silo/alloc.c	2022-09-13 11:43:43.012361815 -0400
@@ -904,11 +904,11 @@
 }
 
 PUBLIC int
 DBIsEmptyQuadmesh(DBquadmesh const *msh)
 {
-#warning CHECK THIS LOGIC. IF ANY DIM>0, IT IS NOT EMPTY
+/* #warning CHECK THIS LOGIC. IF ANY DIM>0, IT IS NOT EMPTY */
     int i, is_empty = 1;
 
     for (i = 0; msh && i < msh->ndims; i++)
     {
         if (msh->dims[i] > 0)
@@ -1349,11 +1349,11 @@
 }
 
 PUBLIC int
 DBIsEmptyQuadvar(DBquadvar const *var)
 {
-#warning CHECK THIS LOGIC
+/* #warning CHECK THIS LOGIC */
     int i, is_empty = 1;
 
     for (i = 0; var && i < var->ndims; i++)
     {
         if (var->dims[i] > 0)
diff -u -U5 -r silo-4.11-bsd/src/silo/silo.c silo-4.11-bsd.warning-preproc-mask/src/silo/silo.c
--- silo-4.11-bsd/src/silo/silo.c	2021-09-10 18:22:52.000000000 -0400
+++ silo-4.11-bsd.warning-preproc-mask/src/silo/silo.c	2022-09-13 11:43:43.040361814 -0400
@@ -69,11 +69,11 @@
  *
  *  Thomas R. Treadway, Fri Jan  5 13:46:26 PST 2007
  *  Added backward compatible symbols
  */
 
-#warning SIMPLIFY HEADER INCLUSION LOGIC
+/* #warning SIMPLIFY HEADER INCLUSION LOGIC */
 
 /* Private SILO functions.  */
 #include "config.h" /* For a possible redefinition of setjmp/longjmp.
                        Also for SDX driver detection.  */
 #include <stdio.h>
@@ -224,11 +224,11 @@
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
 
 PRIVATE filter_t _db_filter[DB_NFILTERS];
-#warning REDUCE USE OF THIS CONSTRUCT
+/* #warning REDUCE USE OF THIS CONSTRUCT */
 const static char *api_dummy = 0;
 
 /* stat struct definition */
 typedef struct db_silo_stat_t {
 #ifndef SIZEOF_OFF64_T
@@ -282,11 +282,11 @@
     TRUE,  /* allowOverwrites */
     FALSE, /* allowEmptyObjects */
     FALSE, /* enableChecksums */
     FALSE, /* enableFriendlyHDF5Names */
     FALSE, /* enableGrabDriver */
-#warning FIX THIS
+/* #warning FIX THIS */
     FALSE, /* darshanEnabled */
     FALSE, /* allowLongStrComponents */
     3,     /* maxDeprecateWarnings */
     0,     /* compressionParams (null) */
     2.0,   /* compressionMinratio */
@@ -1124,11 +1124,11 @@
         if (toc->symlink_target_names) {
             for (i = 0; i < toc->nsymlink; i++)
                 FREE(toc->symlink_target_names[i]);
             FREE(toc->symlink_target_names);
         }
-#warning WE SHOULD PROBABLY JUST EITHER MAKE THIS CONSISTENT OR PERHAPS COPY ALL CHARS INTO LINK@TARGET format
+/* #warning WE SHOULD PROBABLY JUST EITHER MAKE THIS CONSISTENT OR PERHAPS COPY ALL CHARS INTO LINK@TARGET format */
         /* toc->symlink_names is just copy of other members here.
            So, we don't free it here. */
     }
 
     FREE(dbfile->pub.toc);
@@ -1729,11 +1729,11 @@
          */
         DBSetDir(_dbfile, orig_dir);
 
     }
 
-#warning CLEAN UP IS LOST IN ABOVE EARLY RETURNS
+/* #warning CLEAN UP IS LOST IN ABOVE EARLY RETURNS */
     if (args)
         DBFreeStringArray(args, nargs);
 
     if (nlist && (*nlist >= _nlist_orig))
         return -1;
@@ -2530,11 +2530,11 @@
 DB_SETGET(int, FriendlyHDF5Names, enableFriendlyHDF5Names, DB_INTBOOL_NOT_SET) 
 DB_SETGET(int, DeprecateWarnings, maxDeprecateWarnings, DB_INTBOOL_NOT_SET) 
 /*DB_SETGET(int, EnableDarshan, darshanEnabled, DB_INTBOOL_NOT_SET) */
 DB_SETGET(int, AllowLongStrComponents, allowLongStrComponents, DB_INTBOOL_NOT_SET) 
 DB_SETGET(unsigned long long, DataReadMask2, dataReadMask, DB_MASK_NOT_SET) 
-#warning WHAT ABOUT FORCESINGLE SHOWERRORS
+/* #warning WHAT ABOUT FORCESINGLE SHOWERRORS */
 
 /* The compression stuff has some custom initialization */
 static void _db_set_compression_params(char **dst, char const *s)
 {
     if (s && *s == '\0') {
@@ -2839,11 +2839,11 @@
     void *rtn = 0;
     if (file) {
        if (file->pub.GrabId > (void *) 0) {
           int grab_val = 1;
           DBWrite(file, "/_was_grabbed", &grab_val, &grab_val, 1, DB_INT);
-#warning FIX GLOBAL LOCK
+/* #warning FIX GLOBAL LOCK */
           SILO_Globals.enableGrabDriver = TRUE;
           rtn = (void *) file->pub.GrabId;
        }
     }
     return rtn;
@@ -3580,11 +3580,11 @@
  *    Hank Childs, Thu Mar  2 13:34:35 PST 2000
  *    Add check to ensure that nested DBShowErrors to suspend error 
  *    messages would work correctly.
  *
  *-------------------------------------------------------------------------*/
-#warning ADD DBSHOWERRORSFILE
+/* #warning ADD DBSHOWERRORSFILE */
 PUBLIC void
 DBShowErrors(int level, void(*func)(char*))
 {
     static int     old_level = DB_NONE;
     static int     old_level_drvr = DB_NONE;
@@ -3595,11 +3595,11 @@
     {
         level = DB_ALL;
 	SILO_Globals._db_err_level_drvr = DB_ALL;
     }
 
-#warning GET RID OF SUSPEND/RESUME STUFF
+/* #warning GET RID OF SUSPEND/RESUME STUFF */
     switch (level) {
         case DB_SUSPEND:
             if (nested_suspend++ == 0)
             {
                 old_level = SILO_Globals._db_err_level;
@@ -3969,13 +3969,13 @@
     dbfile->pub.file_scope_globals->enableFriendlyHDF5Names = DB_INTBOOL_NOT_SET;
     dbfile->pub.file_scope_globals->enableGrabDriver        = DB_INTBOOL_NOT_SET;
     dbfile->pub.file_scope_globals->darshanEnabled          = DB_INTBOOL_NOT_SET;
     dbfile->pub.file_scope_globals->allowLongStrComponents  = DB_INTBOOL_NOT_SET;
     dbfile->pub.file_scope_globals->maxDeprecateWarnings    = DB_INTBOOL_NOT_SET;
-#warning ADD compressionMinSize
+/* #warning ADD compressionMinSize */
     dbfile->pub.file_scope_globals->compressionMinratio     = DB_FLOAT_NOT_SET;
-#warning CORRECT INITIALIZATION OF compressionErrmode
+/* #warning CORRECT INITIALIZATION OF compressionErrmode */
     dbfile->pub.file_scope_globals->compressionErrmode      = DB_INTBOOL_NOT_SET;
     dbfile->pub.file_scope_globals->compatabilityMode       = DB_INTBOOL_NOT_SET;
     dbfile->pub.file_scope_globals->compressionParams       = DB_CHAR_PTR_NOT_SET;
     dbfile->pub.file_scope_globals->_db_err_level           = DB_INTBOOL_NOT_SET;
     dbfile->pub.file_scope_globals->_db_err_func            = DB_VOID_PTR_NOT_SET;
@@ -4411,11 +4411,11 @@
     API_BEGIN2("DBClose", int, -1, api_dummy) {
         if (!dbfile)
             API_ERROR(NULL, E_NOFILE);
         if (NULL == dbfile->pub.close)
             API_ERROR(dbfile->pub.name, E_NOTIMP);
-#warning IS ORDER OF OPS CORRECT HERE
+/* #warning IS ORDER OF OPS CORRECT HERE */
         id = dbfile->pub.fileid;
         if (id >= 0 && id < DB_NFILES)
             _db_fstatus[id] = 0;
 
         if (dbfile->pub.file_lib_version)
@@ -5834,11 +5834,11 @@
        is ok only if AllowOverwrites is enabled *and* the src object
        can fit within the space used by the dst object, the latter piece
        of logic we cannot currently check. */
     if (!DBGetAllowOverwrites())
     {
-#warning ONLY IF SRC SIZE SMALLER THAN DST SIZE
+/* #warning ONLY IF SRC SIZE SMALLER THAN DST SIZE */
         db_perror("overwrite of pre-existing dst prevented due "
             "to DBSetAllowOverwrites(0)", E_BADARGS, dstName?dstName:srcName);
         return 0;
     }
 
@@ -5929,21 +5929,21 @@
             dstSubObjDirName = db_dirname(dstAbsName);
             dstSubObjAbsName = db_join_path(dstSubObjDirName, dstSubObjName);
 
             /* To make exiting and cleanup logic here a tad simpler, we do all
                the work we *might* need to with the strings and then free them. */
-#warning SHOULDNT WE USE FILE LENGTH FUNCTIONS HERE
+/* #warning SHOULDNT WE USE FILE LENGTH FUNCTIONS HERE */
             srcSubObjType = DBInqVarType(srcFile, srcSubObjAbsName);
             srcLen = DBGetVarByteLength(srcFile, srcSubObjAbsName);
             dstSubObjType = DBInqVarType(dstFile, dstSubObjAbsName);
             dstLen = DBGetVarByteLength(dstFile, dstSubObjAbsName);
 
             if (dstSubObjType == DB_VARIABLE)
                 can_overwrite = 1;
             else if (dstSubObjType == DB_DIR)
                 can_overwrite = 0;
-#warning DISALLOW SIMLINKS FOR NOW
+/* #warning DISALLOW SIMLINKS FOR NOW */
             else if (dstSubObjType == DB_SYMLINK)
                 can_overwrite = 0;
             else
                 can_overwrite = db_can_overwrite_dstobj_with_srcobj(
                     srcFile, srcSubObjAbsName, dstFile, dstSubObjAbsName); /* recursive call */
@@ -6005,12 +6005,12 @@
 {
     int q;
     char *_dstObjAbsName;
     DBobject *dstObj, *srcObj;
 
-#warning CHECK ARGS HERE. ALLOW FOR NULL dstFile AND dstObjAbsName
-#warning WHY CHECK dstType HERE
+/* #warning CHECK ARGS HERE. ALLOW FOR NULL dstFile AND dstObjAbsName */
+/* #warning WHY CHECK dstType HERE */
 
     /* Query type information if not already known */
     if (srcType == DB_INVALID_OBJECT)
         srcType = DBInqVarType(srcFile, srcObjAbsName);
     if (dstType == DB_INVALID_OBJECT)
@@ -6033,11 +6033,11 @@
        to allow overwrites and the source needs to be small enough to fit
        into the space the destination object occupies. */
     else if (dstType != DB_INVALID_OBJECT)
     {
         int srcSize, dstSize;
-#warning USE FILE-BASED FUNCTION WHEN AVAILABLE
+/* #warning USE FILE-BASED FUNCTION WHEN AVAILABLE */
         if (!DBGetAllowOverwrites())
         {
             db_perror("overwrite of pre-existing dst prevented due "
                 "to DBSetAllowOverwrites(0)", E_BADARGS, dstObjAbsName);
             return 0;
@@ -6248,12 +6248,12 @@
  *
  *-------------------------------------------------------------------------*/
 PUBLIC int
 DBCp(char const *opts, DBfile *srcFile, DBfile *dstFile, ...)
 {
-#warning WHAT ABOUT API MACROS. MAYBE NOT NEEDED SINCE NOT CALLING DOWN INTO DRIVERS
-#warning WHAT ABOUT -f (force) OPTION
+/* #warning WHAT ABOUT API MACROS. MAYBE NOT NEEDED SINCE NOT CALLING DOWN INTO DRIVERS */
+/* #warning WHAT ABOUT -f (force) OPTION */
     char const *me = "DBCp";
     int i, j, pass, all_ok;
     int recurse_on_dirs = 0;
     int preserve_links = 0;
     int deref_links = 0;
@@ -6268,11 +6268,11 @@
     char const *many_to_one_dir = 0;
     int N = 0;
     char const **srcPathNames = 0, **dstPathNames = 0;
     char srcStartCwg[1024], dstStartCwg[1024];
 
-#warning WARN ABOUT CERTAIN OPTIONS NOT YET SUPPORTED
+/* #warning WARN ABOUT CERTAIN OPTIONS NOT YET SUPPORTED */
     /* process any options in the opts string */
     for (i = 0; opts && opts[i]; i++)
     {
         switch (opts[i])
         {
@@ -6354,11 +6354,11 @@
             va_end(ap);
             N = src_dst_pairs?n/2:n;
         }
     }
 
-#warning FIX LEAKS WITH EARLY RETURN HERE
+/* #warning FIX LEAKS WITH EARLY RETURN HERE */
 
     if (n_src_dir_triple && N == 0)
         return 0;
     if (!n_src_dir_triple && N < 2)
         return db_perror("src or dst unspecified", E_BADARGS, me);
@@ -6639,11 +6639,11 @@
 
 PUBLIC void *
 DBGetPartialObject(DBfile *dbfile, char const *name, int nvals, int ndims,
     int index_mode, void const *indices, DBoptlist *options)
 {
-#warning FIX THIS METHOD
+/* #warning FIX THIS METHOD */
 
 
 
     /* call directly down into driver */
 
@@ -8159,11 +8159,11 @@
  *    I replaced API_END with API_END_NOPOP.
  *
  *    Sean Ahern, Tue Sep 28 10:48:06 PDT 1999
  *    Added a check for variable name validity.
  *-------------------------------------------------------------------------*/
-#warning DO WE NEED THIS METHOD
+/* #warning DO WE NEED THIS METHOD */
 PRIVATE size_t
 db_get_obj_byte_length(DBfile *dbfile, char const *name)
 {
     int q;
     size_t sum = 0;
@@ -8934,11 +8934,11 @@
 
         retval = (dbfile->pub.p_ma) (dbfile, name, meshname,
                                      nmat, matnos, matlist, dims, ndims,
                                      mix_next, mix_mat, mix_zone, mix_vf,
                                      mixlen, datatype, optlist);
-#warning BETTER PLACE TO NULL THESE
+/* #warning BETTER PLACE TO NULL THESE */
         /* Zero out the _ma._matnames pointer so we can't accidentially use it
          * again. Likewise for matcolors. */
         _ma._matnames = NULL;
         _ma._matcolors = NULL;
 
@@ -9333,11 +9333,11 @@
         if (!dbfile->pub.p_mt)
             API_ERROR(dbfile->pub.name, E_NOTIMP);
 
         retval = (dbfile->pub.p_mt) (dbfile, name, nmats, matnames,
                                      optlist);
-#warning BETTER PLACE TO NULL THESE
+/* #warning BETTER PLACE TO NULL THESE */
         /* Zero out the _mm._matnames pointer so we can't accidentially use it
          * again. Likewise for matcolors. */
         _mm._matnames = NULL;
         _mm._matcolors = NULL;
 
@@ -10325,11 +10325,11 @@
             if (lo_offset < 0)
                 API_ERROR("lo_offset<0", E_BADARGS);
             if (hi_offset < 0)
                 API_ERROR("hi_offset<0", E_BADARGS);
 #ifndef _MSC_VER
-#warning HI AND LO OFFSET NOT VALID IN PRESENCE OF EXPLICIT GHOST LABELS
+/* #warning HI AND LO OFFSET NOT VALID IN PRESENCE OF EXPLICIT GHOST LABELS */
 #endif
         }
         else if (!DBGetAllowEmptyObjectsFile(dbfile))
         {
             /* this is an empty object but we don't know if it was intentional */
@@ -13307,11 +13307,11 @@
              len += strlen(strArray[i])+1;
          else
              len += 2;
      }
      s = (char*)malloc(len+1);
-#warning TEST THIS LOGIC
+/* #warning TEST THIS LOGIC */
      for (i=len=0; i<n; i++) {
          char const *p = strArray[i]?strArray[i]:"\n";
          if (i) s[len++] = ';';
          strcpy(s+len, p);
          len += strlen(p);
