From 3cd16bd80845863f8fd46e6a9eebee6ee2956e14 Mon Sep 17 00:00:00 2001
From: Antoine Gerschenfeld <antoine.gerschenfeld@cea.fr>
Date: Wed, 5 Mar 2025 18:09:43 +0100
Subject: [PATCH 2/2] Lata reader from TRUST

---
 .../vtkUnstructuredGridRelevantPointsFilter.C |   67 +-
 .../vtkAvtFileFormatAlgorithm.cxx             |    5 +-
 .../VisItBridge/databases/CMakeLists.txt      |    3 +-
 .../databases/readers/Lata/AbstractIO.cpp     |   69 +
 .../databases/readers/Lata/AbstractIO.h       |   60 +
 .../databases/readers/Lata/ArrOfBit.cpp       |  195 ++
 .../databases/readers/Lata/ArrOfBit.h         |  111 +
 .../databases/readers/Lata/Array_base.cpp     |   20 +
 .../databases/readers/Lata/Array_base.h       |   45 +
 .../databases/readers/Lata/CMakeLists.txt     |  126 +
 .../VisItBridge/databases/readers/Lata/Cast.h |   55 +
 .../databases/readers/Lata/Comm_Group.h       |  185 ++
 .../readers/Lata/Connectivite_som_elem.cpp    |  178 ++
 .../readers/Lata/Connectivite_som_elem.h      |   32 +
 .../databases/readers/Lata/DecBaseInst.h      |   19 +
 .../databases/readers/Lata/Declare_Base.h     |  178 ++
 .../databases/readers/Lata/Declare_Inst.h     |  207 ++
 .../databases/readers/Lata/DescStructure.h    |   31 +
 .../databases/readers/Lata/Descripteur.h      |   35 +
 .../databases/readers/Lata/Device.cpp         |  585 ++++
 .../databases/readers/Lata/Device.h           |  236 ++
 .../databases/readers/Lata/DeviceMemory.h     |   54 +
 .../databases/readers/Lata/Double.h           |  129 +
 .../databases/readers/Lata/EFichier.cpp       |   39 +
 .../databases/readers/Lata/EFichier.h         |   35 +
 .../readers/Lata/Echange_EV_Options.h         |   56 +
 .../databases/readers/Lata/Entree.cpp         |  508 ++++
 .../databases/readers/Lata/Entree.h           |  138 +
 .../readers/Lata/Entree_Fichier_base.cpp      |  155 +
 .../readers/Lata/Entree_Fichier_base.h        |   59 +
 .../databases/readers/Lata/Esp_Dist.h         |   41 +
 .../databases/readers/Lata/Esp_Virt.h         |   36 +
 .../databases/readers/Lata/LataDB.cpp         | 2702 +++++++++++++++++
 .../databases/readers/Lata/LataDB.h           |  317 ++
 .../databases/readers/Lata/LataDBFORT21.h     |  274 ++
 .../databases/readers/Lata/LataDBmed.h        |  554 ++++
 .../databases/readers/Lata/LataFilter.cpp     | 1138 +++++++
 .../databases/readers/Lata/LataFilter.h       |  253 ++
 .../databases/readers/Lata/LataJournal.h      |   25 +
 .../databases/readers/Lata/LataStructures.cpp |  866 ++++++
 .../databases/readers/Lata/LataStructures.h   |  384 +++
 .../databases/readers/Lata/LataTools.cpp      |  108 +
 .../databases/readers/Lata/LataTools.h        |  177 ++
 .../readers/Lata/LataV1_field_definitions.cpp |   72 +
 .../readers/Lata/LataV1_field_definitions.h   |   21 +
 .../databases/readers/Lata/LataVector.h       |   57 +
 .../databases/readers/Lata/LataWriter.cpp     |  423 +++
 .../databases/readers/Lata/LataWriter.h       |   49 +
 .../databases/readers/Lata/LmlReader.cpp      |  483 +++
 .../databases/readers/Lata/LmlReader.h        |   27 +
 .../databases/readers/Lata/MD_Vector.h        |  119 +
 .../databases/readers/Lata/MD_Vector_base.h   |  109 +
 .../databases/readers/Lata/MD_Vector_mono.h   |   65 +
 .../readers/Lata/MD_Vector_std_tools.tpp      |  118 +
 .../databases/readers/Lata/Motcle.cpp         |  349 +++
 .../databases/readers/Lata/Motcle.h           |   73 +
 .../databases/readers/Lata/Nom.cpp            |  600 ++++
 .../VisItBridge/databases/readers/Lata/Nom.h  |  101 +
 .../databases/readers/Lata/Noms.cpp           |   75 +
 .../VisItBridge/databases/readers/Lata/Noms.h |   42 +
 .../databases/readers/Lata/Objet_U.cpp        |  360 +++
 .../databases/readers/Lata/Objet_U.h          |  153 +
 .../databases/readers/Lata/Objet_U_ptr.h      |   78 +
 .../databases/readers/Lata/Octree_Double.cpp  |  209 ++
 .../databases/readers/Lata/Octree_Double.h    |  133 +
 .../databases/readers/Lata/Octree_Double.tpp  |  116 +
 .../databases/readers/Lata/Octree_Int.cpp     |  503 +++
 .../databases/readers/Lata/Octree_Int.h       |   91 +
 .../databases/readers/Lata/Operator.h         |  224 ++
 .../readers/Lata/OperatorBoundary.cpp         |  212 ++
 .../readers/Lata/OperatorDualMesh.cpp         |  225 ++
 .../readers/Lata/OperatorFacesMesh.cpp        |  102 +
 .../readers/Lata/OperatorReconnect.cpp        |  106 +
 .../readers/Lata/OperatorRegularize.cpp       |  315 ++
 .../databases/readers/Lata/PE_Groups.h        |   62 +
 .../databases/readers/Lata/Process.h          |  132 +
 .../databases/readers/Lata/ReaderFORT21.cpp   | 1522 ++++++++++
 .../databases/readers/Lata/ReaderFORT21.h     |  366 +++
 .../readers/Lata/Rebuild_virtual_layer.cpp    |  124 +
 .../readers/Lata/Rebuild_virtual_layer.h      |   28 +
 .../databases/readers/Lata/Schema_Comm.h      |  149 +
 .../readers/Lata/Schema_Comm_Vecteurs.h       |  277 ++
 .../databases/readers/Lata/Separateur.h       |   41 +
 .../databases/readers/Lata/Sortie.h           |  126 +
 .../readers/Lata/Static_Int_Lists.cpp         |  200 ++
 .../databases/readers/Lata/Static_Int_Lists.h |  119 +
 .../databases/readers/Lata/Statistiques.h     |  306 ++
 .../databases/readers/Lata/TRUSTArray.cpp     |  492 +++
 .../databases/readers/Lata/TRUSTArray.h       |  350 +++
 .../databases/readers/Lata/TRUSTArray.tpp     |  303 ++
 .../readers/Lata/TRUSTArray_device.tpp        |  106 +
 .../readers/Lata/TRUSTArray_kokkos.tpp        |  191 ++
 .../readers/Lata/TRUSTArray_tools.tpp         |  206 ++
 .../databases/readers/Lata/TRUSTArrays.h      |   26 +
 .../databases/readers/Lata/TRUSTTab.h         |  402 +++
 .../databases/readers/Lata/TRUSTTab.tpp       |  857 ++++++
 .../readers/Lata/TRUSTTab_kokkos.tpp          |  556 ++++
 .../databases/readers/Lata/TRUSTTab_tools.tpp |   69 +
 .../databases/readers/Lata/TRUSTTabs.h        |   26 +
 .../readers/Lata/TRUSTTabs_forward.h          |   92 +
 .../databases/readers/Lata/TRUSTTrav.h        |  161 +
 .../databases/readers/Lata/TRUSTTravPool.h    |   55 +
 .../databases/readers/Lata/TRUSTVect.h        |  229 ++
 .../databases/readers/Lata/TRUSTVect.tpp      |  385 +++
 .../readers/Lata/TRUSTVect_tools.cpp          |  783 +++++
 .../readers/Lata/TRUSTVect_tools.tpp          |  591 ++++
 .../databases/readers/Lata/TRUST_Deriv.h      |  267 ++
 .../databases/readers/Lata/TRUST_Ref.h        |  143 +
 .../databases/readers/Lata/TRUST_Vector.h     |  241 ++
 .../databases/readers/Lata/TVAlloc.h          |   58 +
 .../databases/readers/Lata/Type_info.h        |  105 +
 .../databases/readers/Lata/UserFields.cpp     |  896 ++++++
 .../databases/readers/Lata/UserFields.h       |   91 +
 .../databases/readers/Lata/View_Types.h       |  193 ++
 .../VisItBridge/databases/readers/Lata/arch.h |  142 +
 .../readers/Lata/avtlataFileFormat.C          |  933 ++++++
 .../readers/Lata/avtlataFileFormat.h          |  115 +
 .../databases/readers/Lata/blas1.h            |  763 +++++
 .../readers/Lata/communications_array.h       |  136 +
 .../databases/readers/Lata/generique.h        |   76 +
 .../databases/readers/Lata/kokkos++.h         |   45 +
 .../databases/readers/Lata/span.hpp           |  614 ++++
 .../databases/readers/Lata/stat_counters.h    |   76 +
 .../VisItBridge/databases/visit_readers.xml   |   19 +-
 124 files changed, 30302 insertions(+), 43 deletions(-)
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/AbstractIO.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/AbstractIO.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/ArrOfBit.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/ArrOfBit.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Array_base.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Array_base.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/CMakeLists.txt
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Cast.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Comm_Group.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Connectivite_som_elem.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Connectivite_som_elem.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/DecBaseInst.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Declare_Base.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Declare_Inst.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/DescStructure.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Descripteur.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Device.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Device.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/DeviceMemory.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Double.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/EFichier.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/EFichier.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Echange_EV_Options.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Entree.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Entree.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Entree_Fichier_base.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Entree_Fichier_base.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Esp_Dist.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Esp_Virt.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/LataDB.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/LataDB.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/LataDBFORT21.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/LataDBmed.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/LataFilter.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/LataFilter.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/LataJournal.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/LataStructures.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/LataStructures.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/LataTools.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/LataTools.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/LataV1_field_definitions.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/LataV1_field_definitions.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/LataVector.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/LataWriter.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/LataWriter.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/LmlReader.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/LmlReader.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/MD_Vector.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/MD_Vector_base.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/MD_Vector_mono.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/MD_Vector_std_tools.tpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Motcle.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Motcle.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Nom.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Nom.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Noms.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Noms.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Objet_U.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Objet_U.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Objet_U_ptr.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Octree_Double.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Octree_Double.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Octree_Double.tpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Octree_Int.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Octree_Int.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Operator.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/OperatorBoundary.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/OperatorDualMesh.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/OperatorFacesMesh.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/OperatorReconnect.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/OperatorRegularize.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/PE_Groups.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Process.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/ReaderFORT21.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/ReaderFORT21.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Rebuild_virtual_layer.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Rebuild_virtual_layer.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Schema_Comm.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Schema_Comm_Vecteurs.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Separateur.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Sortie.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Static_Int_Lists.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Static_Int_Lists.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Statistiques.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUSTArray.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUSTArray.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUSTArray.tpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUSTArray_device.tpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUSTArray_kokkos.tpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUSTArray_tools.tpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUSTArrays.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUSTTab.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUSTTab.tpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUSTTab_kokkos.tpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUSTTab_tools.tpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUSTTabs.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUSTTabs_forward.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUSTTrav.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUSTTravPool.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUSTVect.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUSTVect.tpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUSTVect_tools.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUSTVect_tools.tpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUST_Deriv.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUST_Ref.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TRUST_Vector.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/TVAlloc.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/Type_info.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/UserFields.cpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/UserFields.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/View_Types.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/arch.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/avtlataFileFormat.C
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/avtlataFileFormat.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/blas1.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/communications_array.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/generique.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/kokkos++.h
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/span.hpp
 create mode 100644 Utilities/VisItBridge/databases/readers/Lata/stat_counters.h

diff --git a/Utilities/VisItBridge/Library/VisItLib/visit_vtk/full/vtkUnstructuredGridRelevantPointsFilter.C b/Utilities/VisItBridge/Library/VisItLib/visit_vtk/full/vtkUnstructuredGridRelevantPointsFilter.C
index 2eecea2f..edd6742d 100644
--- a/Utilities/VisItBridge/Library/VisItLib/visit_vtk/full/vtkUnstructuredGridRelevantPointsFilter.C
+++ b/Utilities/VisItBridge/Library/VisItLib/visit_vtk/full/vtkUnstructuredGridRelevantPointsFilter.C
@@ -79,29 +79,21 @@ vtkUnstructuredGridRelevantPointsFilter::RequestData(
     {
     pointMap[i] = -1;
     }
-  vtkCellArray *cells = input->GetCells();
-  auto cellIter = vtk::TakeSmartPointer(cells->NewIterator());
+
   int numOutPts = 0;
-  for (cellIter->GoToFirstCell();
-       !cellIter->IsDoneWithTraversal();
-       cellIter->GoToNextCell())
+  vtkIdList *list = vtkIdList::New();
+  for (i = 0; i < numCells; i++)
     {
-    vtkIdList *cell = cellIter->GetCurrentCell();
-    int npts = static_cast<int>(cell->GetNumberOfIds());
-    for (j = 0 ; j < npts ; j++)
-      {
-      int oldPt = static_cast<int>(cell->GetId(j));
-      if (pointMap[oldPt] == -1)
-        pointMap[oldPt] = numOutPts++;
-      }
+    input->GetCellPoints(i, list);
+    for (j = 0; j < list->GetNumberOfIds(); j++) if (pointMap[list->GetId(j)] < 0) pointMap[list->GetId(j)] = numOutPts++;
     }
 
-  vtkPoints *newPts = vtkPoints::New(input->GetPoints()->GetDataType());
-  newPts->SetNumberOfPoints(numOutPts);
   vtkPointData *inputPD  = input->GetPointData();
   vtkPointData *outputPD = output->GetPointData();
   outputPD->CopyAllocate(inputPD, numOutPts);
   
+  vtkPoints *newPts = vtkPoints::New(input->GetPoints()->GetDataType());
+  newPts->SetNumberOfPoints(numOutPts);
   for (j = 0 ; j < numInPts ; j++)
     {
     if (pointMap[j] != -1)
@@ -112,43 +104,38 @@ vtkUnstructuredGridRelevantPointsFilter::RequestData(
       outputPD->CopyData(inputPD, j, pointMap[j]);
       }
     }
+  output->SetPoints(newPts);
 
   vtkCellData  *inputCD = input->GetCellData();
   vtkCellData  *outputCD = output->GetCellData();
   outputCD->PassData(inputCD);
-  
-  vtkIdList *cellIds = vtkIdList::New();
-
-  output->SetPoints(newPts);
-
-  // now work through cells, changing associated point id to coincide
-  // with the new ones as specified in the pointmap;
 
-  vtkIdList *oldIds = vtkIdList::New(); 
-  vtkIdList *newIds = vtkIdList::New();
-  int id, cellType;
-  cellIter = vtk::TakeSmartPointer(cells->NewIterator());
-  for (cellIter->GoToFirstCell();
-       !cellIter->IsDoneWithTraversal();
-       cellIter->GoToNextCell())
+  std::vector<vtkIdType> points, faces;
+  for (i = 0; i < numCells; i++)
     {
-    vtkIdList *cell = cellIter->GetCurrentCell();
-    cellType = input->GetCellType(cellIter->GetCurrentCellId());
-    int npts = static_cast<int>(cell->GetNumberOfIds());
+      int CellType = input->GetCellType(i);
+      points.resize(0), faces.resize(0);
+      input->GetCellPoints(i, list);
+      
+      for (j = 0; j < list->GetNumberOfIds(); j++) points.push_back(pointMap[list->GetId(j)]);
 
-    newIds->SetNumberOfIds(npts);
-    for (j = 0; j < npts ; j++)
+      if (CellType == VTK_POLYHEDRON) //must deal with faces stream
       {
-      id = cell->GetId(j);
-      newIds->SetId(j, pointMap[id]);
+        input->GetFaceStream(i, list);
+        int nfaces = list->GetId(0), idx = 1;
+        for (j = 0; j < nfaces; j++)
+        {
+          int npts = list->GetId(idx);
+          faces.push_back(npts), idx++;
+          for (int k = 0; k < npts; k++) faces.push_back(pointMap[list->GetId(idx)]), idx++;
+        }
+        output->InsertNextCell(CellType, points.size(), &points[0], nfaces, &faces[0]);
       }
-      output->InsertNextCell(cellType, newIds);
+      else output->InsertNextCell(CellType, points.size(), &points[0]);      
     }
 
   newPts->Delete();
-  oldIds->Delete();
-  newIds->Delete();
-  cellIds->Delete();
+  list->Delete();
   delete [] pointMap;
 
   return 1;
diff --git a/Utilities/VisItBridge/databases/AvtAlgorithms/vtkAvtFileFormatAlgorithm.cxx b/Utilities/VisItBridge/databases/AvtAlgorithms/vtkAvtFileFormatAlgorithm.cxx
index 3078b97c..f82c6049 100644
--- a/Utilities/VisItBridge/databases/AvtAlgorithms/vtkAvtFileFormatAlgorithm.cxx
+++ b/Utilities/VisItBridge/databases/AvtAlgorithms/vtkAvtFileFormatAlgorithm.cxx
@@ -278,7 +278,10 @@ void vtkAvtFileFormatAlgorithm::AssignProperties( vtkDataSet *data,
 
     //update the vtkDataArray to have the name, since GetVar doesn't require
     //placing a name on the returned array
-    scalar->SetName( name.c_str() );
+    std::string displayname(name.c_str()), rem = "_" + meshName;
+    size_t pos = displayname.find(rem);
+    if (pos != std::string::npos) displayname.erase(pos, rem.length());
+    scalar->SetName(displayname.c_str());
 
     //based on the centering we go determine if this is cell or point based
     switch(scalarMeta.centering)
diff --git a/Utilities/VisItBridge/databases/CMakeLists.txt b/Utilities/VisItBridge/databases/CMakeLists.txt
index f52e61b5..24652a90 100644
--- a/Utilities/VisItBridge/databases/CMakeLists.txt
+++ b/Utilities/VisItBridge/databases/CMakeLists.txt
@@ -35,6 +35,7 @@ set(DEFAULT_BRIDGE_READERS
   H5Nimrod
   Image
   LAMMPS
+  Lata
   Lines
   M3D
   M3DC1
@@ -91,7 +92,7 @@ foreach(db ${DEFAULT_BRIDGE_READERS})
   add_subdirectory(readers/${db})
 endforeach(db)
 
-add_definitions("-DRC_CPP_VISIT_BUILD")
+add_definitions("-DRC_CPP_VISIT_BUILD -DLATATOOLS=1 -DINT_is_64_=2")
 
 # set of libraries xmls for readers enabled.
 set(visit_libraries)
diff --git a/Utilities/VisItBridge/databases/readers/Lata/AbstractIO.cpp b/Utilities/VisItBridge/databases/readers/Lata/AbstractIO.cpp
new file mode 100644
index 00000000..0887c31f
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/AbstractIO.cpp
@@ -0,0 +1,69 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <AbstractIO.h>
+#include <arch.h>
+#include <type_traits>
+
+AbstractIO::AbstractIO() :
+  bin_(false),
+#ifdef INT_is_64_   // in 64b, we write 64b integers by default. But sometimes (save/restart files for example) we might want to still write 32b.
+  is_64b_(true),
+#else
+  is_64b_(false),
+#endif
+  avoid_conversion_(false)
+{ }
+
+
+/*! @brief Whether to convert an int into a long when reading/writing out data.
+ *
+ * The rules are:
+ *   - for 32 files, everything is read/written as 'int', even if _TYPE_ 'long' (or trustIdType) was requested - overflow is checked
+ *     in Entree/Sortie classes
+ *   - for 64 files, everything is read/written as 'long', even if _TYPE_ 'int' (or trustIdType) was requested
+ *     This is for historical reasons: in the former 64b version of TRUST all int were replaced by long, we need to
+ *     keep backward compatibility. When we read a former .sauv file written prior to 1.9.5 for example, all integer values are 'long'.
+ *     But we might need to load them in an 'int' variable (for example this is the case with the 'format_sauvegarde'
+ *     value in Probleme_base).
+ *
+ * Note however that we can force the file to written in 32b even when running the 64b executable, thanks to the is_64b
+ * flag. This is what we do in Problem_base, save/restart logic.
+ */
+template<typename _TYPE_>
+bool AbstractIO::must_convert() const
+{
+  static constexpr bool IS_INTEG = std::is_integral<_TYPE_>::value;
+
+  if (!IS_INTEG || avoid_conversion_)
+    return false;
+  else
+    {
+      const bool SAME_BITNESS = (std::is_same<_TYPE_, std::int64_t>::value && is_64b_)  // The file being read is 64b and _TYPE_ is 64b (long)
+                                || (std::is_same<_TYPE_, std::int32_t>::value && !is_64b_);         // The file being read is 32b and _TYPE_ is 32b (int)
+      return !SAME_BITNESS;
+    }
+}
+
+template bool AbstractIO::must_convert<True_int>() const;
+template bool AbstractIO::must_convert<unsigned>() const;
+template bool AbstractIO::must_convert<unsigned long>() const;
+template bool AbstractIO::must_convert<long>() const;
+template bool AbstractIO::must_convert<long long>() const;
+template bool AbstractIO::must_convert<float>() const;
+template bool AbstractIO::must_convert<double>() const;
+
+
+
diff --git a/Utilities/VisItBridge/databases/readers/Lata/AbstractIO.h b/Utilities/VisItBridge/databases/readers/Lata/AbstractIO.h
new file mode 100644
index 00000000..7137455e
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/AbstractIO.h
@@ -0,0 +1,60 @@
+/****************************************************************************
+* Copyright (c) 2025, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef AbstractIO_included
+#define AbstractIO_included
+
+
+/*! @brief Base class for all input/output streams.
+ *
+ * Holds information about binary/ascii format, and 32b/64b information.
+ *
+ *   - bin_ indicates whether the stream is binary or ASCII
+ *   - is_64b_ incidates whether the stream is in 64b or 32b
+ *   - avoid_conversion_ is used for MPI Comm buffer, where we do not want any int/long conversion.
+ *
+ * See method must_convert() and file arch.h.in for more explanations on 32/64b.
+ *
+ * Note that the .sauv files for example are always written in 32b.
+ *
+ * @sa Entree, Sortie, and specifically the comments in operator_template<>() method.
+ */
+class AbstractIO
+{
+public:
+  bool is_64b() const                   { return is_64b_; }
+  virtual void set_64b(bool is_64b)     { is_64b_ = is_64b;  }
+  virtual void set_bin(bool bin)        { bin_ = bin; }
+  bool is_bin()                         { return bin_; }
+  void set_avoid_conversion(bool avoid) { avoid_conversion_ = avoid; }
+  bool avoid_conversion()               { return avoid_conversion_; }
+
+protected:
+  AbstractIO();
+  virtual ~AbstractIO() { }
+
+  template<typename _TYPE_> bool must_convert() const;
+
+  bool bin_;              ///< Is this a binary flux?
+  bool is_64b_;           ///< Will we be reading/writing in 64b?
+
+  /*! If true, no hacking on int/long is performed in operator_template() methods of Entree/Sortie
+   * This is useful for CommBuffer classes (=MPI exchanges) where we always want int to be sent as int, and long to be
+   * sent as long.
+   */
+  bool avoid_conversion_;
+};
+
+#endif /* AbstractIO_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/ArrOfBit.cpp b/Utilities/VisItBridge/databases/readers/Lata/ArrOfBit.cpp
new file mode 100644
index 00000000..bf367efb
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/ArrOfBit.cpp
@@ -0,0 +1,195 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <arch.h>
+#include <ArrOfBit.h>
+#include <cstring>
+
+Implemente_instanciable_sans_constructeur_ni_destructeur_32_64(ArrOfBit_32_64,"ArrOfBit",Objet_U);
+
+/*! @brief Constructeur d'un tableau de taille n, non initialise
+ */
+template <typename _SIZE_>
+ArrOfBit_32_64<_SIZE_>::ArrOfBit_32_64(int_t n)
+{
+  taille = 0;
+  data = 0;
+  resize_array(n);
+}
+
+/*! @brief Destructeur.
+ */
+template <typename _SIZE_>
+ArrOfBit_32_64<_SIZE_>::~ArrOfBit_32_64()
+{
+  if (data)
+    delete[] data;
+  data = 0;
+}
+
+/*! @brief Constructeur par copie (deep copy)
+ */
+template <typename _SIZE_>
+ArrOfBit_32_64<_SIZE_>::ArrOfBit_32_64(const ArrOfBit_32_64& array):Objet_U(array)
+{
+  taille = 0;
+  data = 0;
+  operator=(array);
+}
+
+/*! @brief Taille en "int" du tableau requis pour stocker un tableau de bits de taille donnees.
+ */
+template <typename _SIZE_>
+typename ArrOfBit_32_64<_SIZE_>::int_t ArrOfBit_32_64<_SIZE_>::calculer_int_size(int_t la_taille) const
+{
+  assert(la_taille >= 0);
+  int_t siz = la_taille >> SIZE_OF_INT_BITS;
+  if (la_taille & DRAPEAUX_INT)
+    siz++;
+  return siz;
+}
+
+/*! @brief Change la taille du tableau et copie les donnees existantes.
+ *
+ * Si la taille est plus petite, les donnees sont
+ *  tronquees, et si la taille est plus grande, les nouveaux elements
+ *  ne sont pas initialises.
+ */
+template <typename _SIZE_>
+ArrOfBit_32_64<_SIZE_>& ArrOfBit_32_64<_SIZE_>::resize_array(int_t n)
+{
+  if (taille == n)
+    return *this;
+  assert(n >= 0);
+  if (n > 0)
+    {
+      int_t oldsize = calculer_int_size(taille);
+      int_t newsize = calculer_int_size(n);
+      unsigned int * newdata = new unsigned int[newsize];
+      int_t size_copy = (newsize > oldsize) ? oldsize : newsize;
+      if (size_copy)
+        {
+          memcpy(newdata, data, size_copy);
+          delete[] data;
+        }
+      data = newdata;
+      taille = n;
+    }
+  else
+    {
+      delete[] data; // data!=0 sinon taille==n et on ne serait pas ici
+      data = 0;
+      taille = 0;
+    }
+  return *this;
+}
+
+/*! @brief Operateur copie (deep copy).
+ */
+template <typename _SIZE_>
+ArrOfBit_32_64<_SIZE_>& ArrOfBit_32_64<_SIZE_>::operator=(const ArrOfBit_32_64& array)
+{
+  int_t newsize = calculer_int_size(array.taille);
+  if (taille != array.taille)
+    {
+      if (data)
+        {
+          delete[] data;
+          data = 0;
+        }
+      if (newsize > 0)
+        data = new unsigned int[newsize];
+    }
+  taille = array.taille;
+  if (taille)
+    memcpy(data, array.data, newsize * sizeof(unsigned int));
+  return *this;
+}
+
+/*! @brief Si la valeur est non nulle, met la valeur 1 dans tous les elements du tableau, sinon met la valeur 0.
+ */
+template <typename _SIZE_>
+ArrOfBit_32_64<_SIZE_>& ArrOfBit_32_64<_SIZE_>::operator=(int_t val)
+{
+  unsigned int valeur = val ? (~((unsigned int) 0)) : 0;
+  int_t size = calculer_int_size(taille);
+  for (int_t i = 0; i < size; i++)
+    data[i] = valeur;
+  return *this;
+}
+
+/*! @brief Ecriture du tableau.
+ *
+ * Format: n
+ *  0 1 0 0 1 0 ... (n valeurs)
+ *
+ */
+template <typename _SIZE_>
+Sortie& ArrOfBit_32_64<_SIZE_>::printOn(Sortie& os) const
+{
+#ifndef LATATOOLS
+  os << taille << finl;
+  // Un retour a la ligne tous les 32 bits,
+  // Une espace tous les 8 bits
+  int_t i = 0;
+  for (; i < taille; i++)
+    {
+      os << operator[](i);
+      if ((i & 7) == 7)
+        os << tspace;
+      if ((i & 31) == 31)
+        os << finl;
+    }
+  // Un retour a la ligne si la derniere ligne n'etait pas terminee
+  if (i & 31)
+    os << finl;
+#endif
+  return os;
+}
+
+/*! @brief Lecture du tableau.
+ *
+ * Format: n
+ *  0 1 0 0 1 0 ... (n valeurs)
+ *
+ */
+template <typename _SIZE_>
+Entree& ArrOfBit_32_64<_SIZE_>::readOn(Entree& is)
+{
+#ifndef LATATOOLS
+  int_t newsize;
+  is >> newsize;
+  resize_array(newsize);
+  operator=(0);
+
+  for (int_t i = 0; i < taille; i++)
+    {
+      int bit;
+      is >> bit;
+      if (bit) setbit(i);
+    }
+#endif
+  return is;
+}
+
+/////////////////////////////////////////////////
+//// Template instanciations
+/////////////////////////////////////////////////
+
+template class ArrOfBit_32_64<int>;
+#if INT_is_64_ == 2
+template class ArrOfBit_32_64<trustIdType>;
+#endif
+
diff --git a/Utilities/VisItBridge/databases/readers/Lata/ArrOfBit.h b/Utilities/VisItBridge/databases/readers/Lata/ArrOfBit.h
new file mode 100644
index 00000000..b900fbac
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/ArrOfBit.h
@@ -0,0 +1,111 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef ArrOfBit_included
+#define ArrOfBit_included
+
+#include <assert.h>
+#include <Objet_U.h>
+
+#ifdef setbit
+#undef setbit   // setbit is also a macro in /usr/include/sys/param.h .... too bad ...
+#endif
+
+template <typename _SIZE_>
+class ArrOfBit_32_64 : public Objet_U
+{
+
+  Declare_instanciable_sans_constructeur_ni_destructeur_32_64(ArrOfBit_32_64);
+
+public:
+  using int_t = _SIZE_;
+
+  ArrOfBit_32_64(int_t n=0);
+  ArrOfBit_32_64(const ArrOfBit_32_64& array);              // Constructeur par copie
+  ~ArrOfBit_32_64() override;                                  // Destructeur
+  ArrOfBit_32_64& operator=(const ArrOfBit_32_64& array);   // Operateur copie
+  ArrOfBit_32_64& operator=(int_t i);
+  inline int operator[](int_t i) const;
+  inline void setbit(int_t i) const;
+  inline int testsetbit(int_t i) const;
+  inline void clearbit(int_t i) const;
+  /// Renvoie la taille du tableau en bits
+  inline int_t size_array() const { return taille; }
+  ArrOfBit_32_64& resize_array(int_t n);
+protected:
+  int_t calculer_int_size(int_t taille) const;
+  int_t taille;
+  unsigned int *data;
+  static constexpr unsigned int SIZE_OF_INT_BITS = 5;
+  static constexpr unsigned int DRAPEAUX_INT = 31;
+};
+
+/*! @brief Renvoie 1 si le bit e est mis, 0 sinon.
+ *
+ */
+template <typename _SIZE_>
+inline int ArrOfBit_32_64<_SIZE_>::operator[](int_t e) const
+{
+  assert(e >= 0 && e < taille);
+  unsigned int i = (unsigned int) e;
+  unsigned int x = data[i >> SIZE_OF_INT_BITS];
+  unsigned int flag = 1 << (i & DRAPEAUX_INT);
+  int resultat = ((x & flag) != 0) ? 1 : 0;
+  return resultat;
+}
+
+/*! @brief Met le bit e a 1.
+ *
+ */
+template <typename _SIZE_>
+inline void ArrOfBit_32_64<_SIZE_>::setbit(int_t e) const
+{
+  assert(e >= 0 && e < taille);
+  unsigned int i = (unsigned int) e;
+  unsigned int flag = 1 << (i & DRAPEAUX_INT);
+  data[i >> SIZE_OF_INT_BITS] |= flag;
+}
+
+/*! @brief Renvoie la valeur du bit e, puis met le bit e a 1.
+ *
+ */
+template <typename _SIZE_>
+inline int ArrOfBit_32_64<_SIZE_>::testsetbit(int_t e) const
+{
+  assert(e >= 0 && e < taille);
+  unsigned int i = (unsigned int) e;
+  unsigned int flag = 1 << (i & DRAPEAUX_INT);
+  int index = i >> SIZE_OF_INT_BITS;
+  unsigned int old = data[index];
+  data[index] = old | flag;
+  return ((old & flag) != 0) ? 1 : 0;
+}
+
+/*! @brief Met le bit e a 0.
+ *
+ */
+template <typename _SIZE_>
+inline void ArrOfBit_32_64<_SIZE_>::clearbit(int_t e) const
+{
+  assert(e >= 0 && e < taille);
+  unsigned int i = (unsigned int) e;
+  unsigned int flag = 1 << (i & DRAPEAUX_INT);
+  data[i >> SIZE_OF_INT_BITS] &= ~flag;
+}
+
+using ArrOfBit = ArrOfBit_32_64<int>;
+using BigArrOfBit = ArrOfBit_32_64<trustIdType>;
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Array_base.cpp b/Utilities/VisItBridge/databases/readers/Lata/Array_base.cpp
new file mode 100644
index 00000000..e33b6cf4
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Array_base.cpp
@@ -0,0 +1,20 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <Array_base.h>
+
+Implemente_base_sans_constructeur_ni_destructeur(Array_base, "Array_base", Objet_U);
+Sortie& Array_base::printOn(Sortie& os) const { return os; }
+Entree& Array_base::readOn(Entree& is) { return is; }
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Array_base.h b/Utilities/VisItBridge/databases/readers/Lata/Array_base.h
new file mode 100644
index 00000000..b95eb6b8
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Array_base.h
@@ -0,0 +1,45 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Array_base_included
+#define Array_base_included
+
+#include <Objet_U.h>
+class MD_Vector;
+
+/*! Options de resize:
+*  RESIZE_OPTIONS::NOCOPY_NOINIT: ne pas copier les anciennes valeurs, ne pas initialiser les nouvelles
+*  RESIZE_OPTIONS::COPY_NOINIT: copier les anciennes, ne pas initialiser les nouvelles
+*  RESIZE_OPTIONS::COPY_INIT: copier les anciennes et initialiser les nouvelles a zero
+*/
+enum class RESIZE_OPTIONS { NOCOPY_NOINIT, COPY_NOINIT, COPY_INIT };
+
+/*! Options de stockage */
+enum class STORAGE { STANDARD, TEMP_STORAGE };
+
+/*! GPU Data location */
+enum class DataLocation { HostOnly, Host, Device, HostDevice, PartialHostDevice };
+
+/*! @brief Empty class used as a base for all the arrays.
+ *
+ * Allows to pass a generic type, whatever the real derived nature of the array.
+ * (e.g. Domaine::creer_tableau_sommets())
+ */
+class Array_base : public Objet_U
+{
+  Declare_base_sans_constructeur_ni_destructeur(Array_base);
+};
+
+#endif /* Array_base_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/CMakeLists.txt b/Utilities/VisItBridge/databases/readers/Lata/CMakeLists.txt
new file mode 100644
index 00000000..b1bc8727
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/CMakeLists.txt
@@ -0,0 +1,126 @@
+set(SOURCES
+  AbstractIO.cpp
+  ArrOfBit.cpp
+  Array_base.cpp
+  Connectivite_som_elem.cpp
+  Device.cpp
+  EFichier.cpp
+  Entree.cpp
+  Entree_Fichier_base.cpp
+  LataDB.cpp
+  LataFilter.cpp
+  LataStructures.cpp
+  LataTools.cpp
+  LataV1_field_definitions.cpp
+  LataWriter.cpp
+  LmlReader.cpp
+  Motcle.cpp
+  Nom.cpp
+  Noms.cpp
+  Objet_U.cpp
+  Octree_Double.cpp
+  Octree_Int.cpp
+  OperatorBoundary.cpp
+  OperatorDualMesh.cpp
+  OperatorFacesMesh.cpp
+  OperatorReconnect.cpp
+  OperatorRegularize.cpp
+  ReaderFORT21.cpp
+  Rebuild_virtual_layer.cpp
+  Static_Int_Lists.cpp
+  TRUSTArray.cpp
+  TRUSTVect_tools.cpp
+  UserFields.cpp
+  AbstractIO.h
+  ArrOfBit.h
+  Array_base.h
+  Cast.h
+  Comm_Group.h
+  Connectivite_som_elem.h
+  DecBaseInst.h
+  Declare_Base.h
+  Declare_Inst.h
+  DescStructure.h
+  Descripteur.h
+  Device.h
+  DeviceMemory.h
+  Double.h
+  EFichier.h
+  Echange_EV_Options.h
+  Entree.h
+  Entree_Fichier_base.h
+  Esp_Dist.h
+  Esp_Virt.h
+  LataDB.h
+  LataDBFORT21.h
+  LataDBmed.h
+  LataFilter.h
+  LataJournal.h
+  LataStructures.h
+  LataTools.h
+  LataV1_field_definitions.h
+  LataVector.h
+  LataWriter.h
+  LmlReader.h
+  MD_Vector.h
+  MD_Vector_base.h
+  MD_Vector_mono.h
+  Motcle.h
+  Nom.h
+  Noms.h
+  Objet_U.h
+  Objet_U_ptr.h
+  Octree_Double.h
+  Octree_Int.h
+  Operator.h
+  PE_Groups.h
+  Process.h
+  ReaderFORT21.h
+  Rebuild_virtual_layer.h
+  Schema_Comm.h
+  Schema_Comm_Vecteurs.h
+  Separateur.h
+  Sortie.h
+  Static_Int_Lists.h
+  Statistiques.h
+  TRUSTArray.h
+  TRUSTArrays.h
+  TRUSTTab.h
+  TRUSTTabs.h
+  TRUSTTabs_forward.h
+  TRUSTTrav.h
+  TRUSTTravPool.h
+  TRUSTVect.h
+  TRUST_Deriv.h
+  TRUST_Ref.h
+  TRUST_Vector.h
+  TVAlloc.h
+  Type_info.h
+  UserFields.h
+  View_Types.h
+  arch.h
+  avtlataFileFormat.h
+  blas1.h
+  communications_array.h
+  generique.h
+  kokkos++.h
+  stat_counters.h
+  MD_Vector_std_tools.tpp
+  Octree_Double.tpp
+  TRUSTArray.tpp
+  TRUSTArray_device.tpp
+  TRUSTArray_kokkos.tpp
+  TRUSTArray_tools.tpp
+  TRUSTTab.tpp
+  TRUSTTab_kokkos.tpp
+  TRUSTTab_tools.tpp
+  TRUSTVect.tpp
+  TRUSTVect_tools.tpp
+  avtlataFileFormat.C
+)
+
+ADD_VISIT_READER(VisItLataReader "1.0"
+  VISIT_READER_TYPE "MTMD"
+  VISIT_READER_NAME "avtlataFileFormat"
+  SERVER_SOURCES ${SOURCES}
+  )
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Cast.h b/Utilities/VisItBridge/databases/readers/Lata/Cast.h
new file mode 100644
index 00000000..c005ab17
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Cast.h
@@ -0,0 +1,55 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+
+#ifndef Cast_H
+#define Cast_H
+
+/*! @brief Informations de types : static_type_info(T) : renvoie le type_info de la classe T.
+ *
+ *       ptr_type_info(p) : renvoie le type_info de l'objet pointe par p.
+ *       ref_type_info(r) : renvoie le type_info de l'objet r ou de l'alias r
+ *       sub_type(T,r) : renvoie 1 ssi r est une instance d'une classe fille de T; 0 sinon.
+ *     Les cast securises :
+ *       ptr_cast(T,p) : renvoie (T*)(p) ssi *p est d'un sous type de T; 0 sinon.
+ *       ref_cast(T,r) : : renvoie (T&)(r) ssi r est d'un sous type de T; 0 sinon.
+ *
+ */
+
+class Type_info;
+
+extern int* bad_ref_cast(const Type_info* t1, const Type_info* t2);
+
+#define static_type_info(T)                        \
+  T::info()
+#define ptr_type_info(p)                        \
+  ((p)->get_info())
+#define ref_type_info(r)                        \
+  ((r).get_info())
+
+#define same_type(T,r)                                \
+  (((r).get_info())->same(T::info()))
+#define sub_type(T,r)                                        \
+  (T::info_obj.can_cast((r).get_info()) ? 1 : 0)
+#define ptr_cast(T,p)                                                \
+  (T::info_obj.can_cast((p)->get_info())                        \
+   ? 0 :bad_ref_cast(T::info(),(p)->get_info()), (T*)(p))
+#define ref_cast(T,r)                                                        \
+  (T::info_obj.can_cast((r).get_info())                                        \
+   ? 0 :bad_ref_cast(T::info(),(r).get_info()), T::self_cast(r))
+#define ref_cast_non_const(T,r)                                        \
+  (T::info_obj.can_cast((r).get_info())                                \
+   ? 0 :bad_ref_cast(T::info(),(r).get_info()), (T&)(r))
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Comm_Group.h b/Utilities/VisItBridge/databases/readers/Lata/Comm_Group.h
new file mode 100644
index 00000000..f5ad1841
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Comm_Group.h
@@ -0,0 +1,185 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Comm_Group_included
+#define Comm_Group_included
+
+#include <TRUST_Deriv.h>
+#include <TRUSTArray.h>
+#include <assert.h>
+
+/*! @brief : Cette classe decrit un groupe de processeurs sur lesquels
+ *
+ *   une portion de code s'execute simultanement. Elle fournit
+ *   toutes les methodes permettant d'echanger des donnees entre
+ *   les processeurs du groupe (mpsum, send, recv, ...),
+ *   et de synchroniser les processeurs (barrier).
+ *   Elle est specialisee selon le support reseau (MPI, PVM, ...)
+ *   Attention, ces methodes sont reservees a des operations de bas niveau
+ *   (noyau TRUST).
+ *   Dans le code courant, il faut utiliser les methodes classes de communications
+ *   de haut niveau :
+ *   (envoyer(), envoyer_broadcast(), class Schema_Comm, class Process, etc)
+ *   Pour creer un nouveau groupe et l'utiliser, voir class PE_Groups
+ *   Pour la procedure d'initialisation, voir PE_Groups::Initialize()
+ *
+ */
+class Comm_Group : public Objet_U
+{
+  Declare_base_sans_constructeur_ni_destructeur(Comm_Group);
+public:
+  Comm_Group();
+  ~Comm_Group() override;
+  virtual void   abort() const = 0;
+
+  // COLL_SUM: somme sur tous les procs
+  // COLL_MIN: minimum
+  // COLL_MAX: max
+  // COLL_PARTIAL_SUM calcule la somme partielle des valeurs sur les processeurs de rang
+  // strictement inferieurs a me() (le resultat vaut toujours 0 sur le processeur 0).
+  enum Collective_Op { COLL_SUM, COLL_MIN, COLL_MAX, COLL_PARTIAL_SUM };
+  virtual void mp_collective_op(const double *x, double *resu, int n, Collective_Op op) const = 0;
+  virtual void mp_collective_op(const double *x, double *resu, const Collective_Op *op, int n) const = 0;
+  virtual void mp_collective_op(const float *x, float *resu, int n, Collective_Op op) const = 0;
+  virtual void mp_collective_op(const float *x, float *resu, const Collective_Op *op, int n) const = 0;
+  virtual void mp_collective_op(const int *x, int *resu, int n, Collective_Op op) const = 0;
+  virtual void mp_collective_op(const int *x, int *resu, const Collective_Op *op, int n) const = 0;
+#if INT_is_64_ == 2
+  virtual void mp_collective_op(const trustIdType *x, trustIdType *resu, int n, Collective_Op op) const = 0;
+  virtual void mp_collective_op(const trustIdType *x, trustIdType *resu, const Collective_Op *op, int n) const = 0;
+#endif
+
+  virtual void barrier(int tag) const = 0;
+
+  // Calcule un nouveau tag de communication qui permet d'identifier les
+  // echanges de facon unique pour l'ensemble des groupes.
+  inline int get_new_tag() const;
+
+  inline int rank() const;
+  inline int nproc() const;
+
+  // Veut-on faire des verifications supplementaires sur les communications ?
+  // Ces verifications impliquent des communications en plus, ce qui modifie
+  // le deroulement du programme. C'est donc un mecanisme separe des "assert".
+  inline static int check_enabled();
+
+  enum TypeHint { CHAR, INT, DOUBLE, FLOAT };
+  // Demarre l'echange des buffers.
+  // send_list / recv_list = liste de PEs (rangs dans le groupe courant)
+  // send_size / recv_size = taille des messages en bytes
+  // send_buffers / recv_buffers = adresse des buffers
+  // Les buffers en reception doivent avoir une taille suffisante.
+  // Note au sujet des const :
+  //  send_buffers est completement const, on n'a le droit de rien modifier
+  //  recv_buffers est const, recv_buffers[i] est const mais *(recv_buffers[i])
+  //               n'est pas const car on y stocke les donnees recues.
+  virtual void send_recv_start(const ArrOfInt& send_list,
+                               const ArrOfInt& send_size,
+                               const char * const * const send_buffers,
+                               const ArrOfInt& recv_list,
+                               const ArrOfInt& recv_size,
+                               char * const * const recv_buffers,
+                               TypeHint typehint = CHAR) const = 0;
+  // Attend que les communications lancees par send_recv soient terminees.
+  virtual void send_recv_finish() const = 0;
+
+  // Methodes d'envoi / reception blocantes: a chaque send doit correpondre
+  // simultanement un recv sur le processeur destination.
+  virtual void send(int pe, const void *buffer, int size, int tag) const = 0; // Envoi bloquant
+  virtual void recv(int pe, void *buffer, int size, int tag) const = 0; // Reception bloquante
+
+  // Methodes de broadcast : a appeler sur tous les processeurs en meme temps
+  virtual void broadcast(void *buffer, int size, int pe_source) const = 0;
+
+  // Methodes all_to_all
+  virtual void all_to_all(const void *src_buffer, void *dest_buffer, int data_size) const = 0;
+  virtual void all_gather(const void *src_buffer, void *dest_buffer, int data_size) const = 0;
+  virtual void gather(const void *src_buffer, void *dest_buffer, int data_size, int root) const = 0;
+  virtual void all_gatherv(const void *src_buffer, void *dest_buffer, int send_size, const True_int* recv_size, const True_int* displs) const = 0;
+
+  static void set_check_enabled(int flag);
+protected:
+  Comm_Group(const Comm_Group&);  // interdit !
+  const Comm_Group& operator=(const Comm_Group&);   // interdit !
+  virtual void       init_group(const ArrOfInt& pe_list);
+  void               init_group_trio(int nproc, int rank);
+  friend class PE_Groups;
+
+private:
+  static int check_enabled_;
+  static int static_group_number_;
+
+  // Rang du processeur local dans le groupe, -1 s'il n'est pas dans le groupe
+  int rank_ = -1;
+  // Nombre de processeurs dans le groupe
+  int nproc_ = -1;
+  // Pour chaque pe du calcul complet (taille du tableau = groupe_TRUST().nproc())
+  //  indice au sein du groupe si le pe est dedans,
+  //  -1 si le pe n'est pas dans le groupe
+  ArrOfInt  local_ranks_;
+  // Liste des processeurs du groupes (indices des processeurs dans groupe_TRUST())
+  // (taille du tableau = nproc_)
+  ArrOfInt  world_ranks_;
+
+  // Mon numero de groupe (egal au static_group_number_ au moment de la
+  // creation du groupe).
+  int group_number_ = -1;
+  // On incremente le group_communication_tag_ de cette quantite a chaque
+  // operation. C'est un nombre premier, ce qui permet d'avoir des tags
+  // differents pour chaque groupe pendant un bon bout de temps (jusqu'a ce
+  // que le numero de tag depasse MAXINT...)
+  int group_tag_increment_ = -1;
+  // On incremente le tag a chaque operation, ce qui permet de verifier que les processus sont bien synchronises.
+  mutable int group_communication_tag_ = -1;
+};
+
+inline int Comm_Group::check_enabled()
+{
+  return check_enabled_;
+}
+
+/*! @brief Cette fonction renvoie un nouveau tag de communication pour le groupe.
+ *
+ * Effet de bord : incremente le membre group_communication_tag_.
+ *
+ */
+inline int Comm_Group::get_new_tag() const
+{
+  // B.M. Cette fonctionnalite est finalement tres peu utile en pratique
+  // et quand le compteur depasse une limite ca plante mpi. Je desactive:
+  //group_communication_tag_ += group_tag_increment_;
+  return group_communication_tag_;
+}
+
+/*! @brief Renvoie le rang du processeur local dans le groupe *this.
+ *
+ * ou -1 si je ne suis pas dans le groupe.
+ *
+ */
+inline int Comm_Group::rank() const
+{
+  return rank_;
+}
+
+/*! @brief Renvoie le nombre de processeurs dans le groupe *this
+ *
+ */
+inline int Comm_Group::nproc() const
+{
+  assert(nproc_ >= 0);
+  return nproc_;
+}
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Connectivite_som_elem.cpp b/Utilities/VisItBridge/databases/readers/Lata/Connectivite_som_elem.cpp
new file mode 100644
index 00000000..2ca2dcd8
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Connectivite_som_elem.cpp
@@ -0,0 +1,178 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+#include <Connectivite_som_elem.h>
+#include <Static_Int_Lists.h>
+#include <TRUSTTabs.h>
+
+/*! @brief construction de la structure som_elem pour le domaine donnee On cree pour chaque sommet i la liste des elements adjacents a ce sommet
+ *
+ *   (c'est la liste des elements k tels que il existe j tel que les_elems(k,j) == i)
+ *
+ * @param (nb_sommets)
+ * @param (les_elems)
+ * @param (som_elem)
+ * @param (include_virtual)
+ */
+template <typename _SIZE_>
+void construire_connectivite_som_elem(const _SIZE_       nb_sommets,
+                                      const IntTab_T<_SIZE_>&      les_elems,
+                                      Static_Int_Lists_32_64<_SIZE_>& som_elem,
+                                      bool       include_virtual)
+{
+  // Nombre d'elements du domaine
+  const _SIZE_ nb_elem = (include_virtual) ? les_elems.dimension_tot(0) : les_elems.dimension(0);
+  // Nombre de sommets par element
+  const _SIZE_ nb_sommets_par_element = les_elems.dimension(1);
+
+  // Construction d'un tableau initialise a zero : pour chaque sommet,
+  // nombre d'elements voisins de ce sommet
+  ArrOfInt_T<_SIZE_> nb_elements_voisins(nb_sommets);
+
+  // Premier passage : on calcule le nombre d'elements voisins de chaque
+  // sommet pour creer la structure de donnees
+  _SIZE_ elem;
+  int i;
+
+  for (elem = 0; elem < nb_elem; elem++)
+    {
+      for (i = 0; i < nb_sommets_par_element; i++)
+        {
+          _SIZE_ sommet = les_elems(elem, i);
+          // GF cas des polyedres
+          if (sommet==-1) break;
+          nb_elements_voisins[sommet]++;
+        }
+    }
+
+  som_elem.set_list_sizes(nb_elements_voisins);
+
+  // On reutilise le tableau pour stocker le nombre d'elements dans
+  // chaque liste pendant qu'on la remplit
+  nb_elements_voisins = 0;
+
+  // Remplissage du tableau des elements voisins.
+  for (elem = 0; elem < nb_elem; elem++)
+    {
+      for (i = 0; i < nb_sommets_par_element; i++)
+        {
+          _SIZE_ sommet = les_elems(elem, i);
+          // GF cas des polyedres
+          if (sommet==-1) break;
+          _SIZE_ n = (nb_elements_voisins[sommet])++;
+          som_elem.set_value(sommet, n, elem);
+        }
+    }
+
+  // Tri de toutes les listes dans l'ordre croissant
+  som_elem.trier_liste(-1);
+}
+
+/*! @brief Cherche les elements qui contiennent tous les sommets du tableau sommets_to_find (permet de trouver les elements
+ *
+ *   adjacents a une face ou une arete)
+ *
+ * @param (som_elem) pour chaque sommet, liste triee des elements adjacents (voir construire_connectivite_som_elem)
+ * @param (sommets_to_find) une liste de sommets
+ * @param (elements) resultat de la recherche: la liste des elements qui contiennent tous les sommets de sommets_to_find. Si sommets_to_find est vide, on renvoie un tableau vide. (en cas d'appels repetes a cette fonction, il est conseille de mettre le drapeau "smart_resize")
+ */
+template <typename _SIZE_>
+void find_adjacent_elements(const Static_Int_Lists_32_64<_SIZE_>& som_elem,
+                            const SmallArrOfTID_T<_SIZE_>& sommets_to_find,
+                            SmallArrOfTID_T<_SIZE_>& elements)
+{
+  int nb_som_to_find = sommets_to_find.size_array();
+  // on retire les sommets valant -1 (cas ou plusieurs types de faces)
+  while (sommets_to_find[nb_som_to_find-1]==-1) nb_som_to_find--;
+  if (nb_som_to_find == 0)
+    {
+      elements.resize_array(0);
+      return;
+    }
+  // Algorithme: on initialise elements avec tous les elements adjacents
+  //  au premier sommet de la liste.
+  //  Puis pour chacun des autres sommets de la liste, on retire du tableau
+  //  "elements" les elements qui ne sont pas voisins du sommet.
+  //  A la fin, il ne reste que les elements qui sont dans toutes les listes.
+  {
+    // Initialisation avec les elements adjacents au premier sommet
+    const _SIZE_ sommet = sommets_to_find[0];
+    // OK this is a bit technical here: 'elements' is a small array, even in 64b.
+    // But copy_list_to_array() might return a Big array (in 64b). So we cheat, we pass it a big array
+    // which is actually pointing to the same internal memory block as the small one.
+    // Just need to start with the correct size because copy_list_to_array will resize otherwise:
+    int sz = (int)som_elem.get_list_size(sommet);
+    elements.resize_array(sz);
+    ArrOfInt_T<_SIZE_> elem_as_big;
+    elements.ref_as_big(elem_as_big);
+    som_elem.copy_list_to_array(sommet, elem_as_big);
+  }
+  int nb_elem_found = elements.size_array();
+  int i_sommet;
+  for (i_sommet = 1; i_sommet < nb_som_to_find; i_sommet++)
+    {
+      const _SIZE_ sommet = sommets_to_find[i_sommet];
+      // Calcul des elements communs entre elements[.] et som_elem(sommet,.)
+      // Nombre d'elements communs entre elements et la nouvelle liste de sommets
+      int nb_elems_restants = 0;
+      // Nombre d'elements adjacents au "sommet"
+      const int nb_elem_liste = (int)som_elem.get_list_size(sommet);
+      // On suppose que les listes d'elements sont triees dans l'ordre croissant
+      // On parcourt simultanement les deux listes et on conserve les elements
+      // communs.
+      int i=0, j=0;
+      if (nb_elem_found == 0)
+        break;
+      if (nb_elem_liste > 0)
+        {
+          while (1)
+            {
+              const _SIZE_ elem_i = elements[i];
+              const _SIZE_ elem_j = som_elem(sommet, j);
+              if (elem_i == elem_j)
+                {
+                  // Element commun aux deux listes, on le garde
+                  elements[nb_elems_restants] = elem_i;
+                  nb_elems_restants++;
+                }
+              if (elem_i >= elem_j)
+                {
+                  j++;
+                  if (j >= nb_elem_liste)
+                    break;
+                }
+              if (elem_j >= elem_i)
+                {
+                  i++;
+                  if (i >= nb_elem_found)
+                    break;
+                }
+            }
+        }
+      else
+        {
+          nb_elems_restants = 0;
+        }
+      nb_elem_found = nb_elems_restants;
+    }
+  elements.resize_array(nb_elem_found);
+}
+
+template void construire_connectivite_som_elem(const int nb_sommets, const IntTab_T<int>& les_elems, Static_Int_Lists_32_64<int>& som_elem, bool include_virtual);
+template void find_adjacent_elements(const Static_Int_Lists_32_64<int>& som_elem, const SmallArrOfTID_T<int>& sommets_to_find, SmallArrOfTID_T<int>& elements);
+
+#if INT_is_64_ == 2
+template void construire_connectivite_som_elem(const trustIdType nb_sommets, const IntTab_T<trustIdType>& les_elems, Static_Int_Lists_32_64<trustIdType>& som_elem, bool include_virtual);
+template void find_adjacent_elements(const Static_Int_Lists_32_64<trustIdType>& som_elem, const SmallArrOfTID_T<trustIdType>& sommets_to_find, SmallArrOfTID_T<trustIdType>& elements);
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Connectivite_som_elem.h b/Utilities/VisItBridge/databases/readers/Lata/Connectivite_som_elem.h
new file mode 100644
index 00000000..6ab7e04c
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Connectivite_som_elem.h
@@ -0,0 +1,32 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Connectivite_som_elem_H_INCLU
+#define Connectivite_som_elem_H_INCLU
+
+#include <TRUSTTabs_forward.h>
+
+template <typename _SIZE_>
+class Static_Int_Lists_32_64;
+
+// We do not differentiate here _SIZE_ and _TYPE_ because those functions all work with entity indices.
+// So we are either manipulating IntTab or BigTIDTab, nothing in between.
+template <typename _SIZE_>
+void construire_connectivite_som_elem(const _SIZE_ nb_sommets, const IntTab_T<_SIZE_>& les_elems, Static_Int_Lists_32_64<_SIZE_>& som_elem, bool include_virtual);
+
+template <typename _SIZE_>
+void find_adjacent_elements(const Static_Int_Lists_32_64<_SIZE_>& som_elem, const SmallArrOfTID_T<_SIZE_>& sommets_to_find, SmallArrOfTID_T<_SIZE_>& elements);
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/DecBaseInst.h b/Utilities/VisItBridge/databases/readers/Lata/DecBaseInst.h
new file mode 100644
index 00000000..9a2585fb
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/DecBaseInst.h
@@ -0,0 +1,19 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <Cast.h>
+#include <Type_info.h>
+#include <Declare_Base.h>
+#include <Declare_Inst.h>
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Declare_Base.h b/Utilities/VisItBridge/databases/readers/Lata/Declare_Base.h
new file mode 100644
index 00000000..bbf860ea
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Declare_Base.h
@@ -0,0 +1,178 @@
+/****************************************************************************
+* Copyright (c) 2025, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+
+// .SECTION Description
+// les macros Declare_base_sans_destructeur et
+// Implemente_base_sans_destructeur
+// permettent de creer simplement des classes
+// de bases conforme a TRUST.
+
+// .SECTION Description du header
+// class A_base : public B {
+// Declare_base_sans_destructeur(A_base);
+// };
+// .SECTION Description du source
+// Implemente_base_sans_destructeur(A_base, "A_base", B);
+
+#include <arch.h>
+
+#ifdef LATATOOLS
+#define Declare_base_sans_constructeur_ni_destructeur(_TYPE_)  \
+  public :                                                                \
+  unsigned taille_memoire() const override { return 0; };                                      \
+  int duplique() const override { return 0; };                                                \
+  protected :                                                                \
+  Sortie& printOn(Sortie& x) const override;                                \
+  Entree& readOn(Entree&) override
+
+#define Declare_base_sans_constructeur(_TYPE_)  \
+  public :                                                                \
+  ~_TYPE_();                                                    \
+  Declare_base_sans_constructeur_ni_destructeur(_TYPE_)
+
+#define Declare_base(_TYPE_)                                \
+  public:                                                \
+  _TYPE_();                                                \
+  ~_TYPE_();                                                \
+  Declare_base_sans_constructeur_ni_destructeur(_TYPE_)
+
+#define Implemente_base_sans_constructeur_ni_destructeur(_TYPE_,_NOM_,_BASE_)
+
+#else
+#define Declare_base_sans_constructeur_ni_destructeur(_TYPE_)        \
+                                                                \
+  public :                                                        \
+  static const Type_info info_obj;                                \
+  static const Type_info* info();                                \
+  const Type_info* get_info() const override;                                \
+  /* methode rajoutee pour caster en python */                        \
+  static _TYPE_& self_cast( Objet_U&) ;                                \
+  static const _TYPE_& self_cast(const Objet_U&) ;                \
+  protected :                                                        \
+  Sortie& printOn(Sortie& x) const override;                        \
+  Entree& readOn(Entree&) override
+
+#define Declare_base_sans_constructeur(_TYPE_)                \
+  public:                                                \
+  ~_TYPE_() override;                                                \
+  Declare_base_sans_constructeur_ni_destructeur(_TYPE_)
+
+#define Declare_base_sans_destructeur(_TYPE_)                \
+  public:                                                \
+  _TYPE_();                                                \
+  Declare_base_sans_constructeur_ni_destructeur(_TYPE_)
+
+#define Declare_base(_TYPE_)                                \
+  public:                                                \
+  _TYPE_();                                                \
+  ~_TYPE_() override;                                                \
+  Declare_base_sans_constructeur_ni_destructeur(_TYPE_)
+
+#define Implemente_base_sans_constructeur_ni_destructeur(_TYPE_,_NOM_,_BASE_) \
+                                                                        \
+  const Type_info* name2(_TYPE_,bases)[1]={                                \
+    &(_BASE_::info_obj)};                                                \
+  const Type_info _TYPE_::info_obj(_NOM_, 1, name2(_TYPE_,bases));        \
+                                                                        \
+  _TYPE_& _TYPE_::self_cast( Objet_U& r)   {                                \
+    return ref_cast_non_const(_TYPE_,r); /* _non_const important sinon recursion dans ref_cast */ \
+  }                                                                        \
+  const _TYPE_& _TYPE_::self_cast(const Objet_U& r)   {                        \
+    return ref_cast_non_const(_TYPE_,r); /* _non_const important sinon recursion dans ref_cast */ \
+  }                                                                        \
+  const Type_info*  _TYPE_::get_info() const {                                \
+    return &info_obj;                                                        \
+  }                                                                        \
+  const Type_info*  _TYPE_::info() {                                        \
+    return &info_obj;                                                        \
+  }                                                                          \
+  class __dummy__
+#endif
+
+#define Implemente_base_sans_constructeur(_TYPE_,_NOM_,_BASE_)                \
+  _TYPE_::~_TYPE_() { }                                                        \
+  Implemente_base_sans_constructeur_ni_destructeur(_TYPE_,_NOM_,_BASE_)
+
+#define Implemente_base_sans_destructeur(_TYPE_,_NOM_,_BASE_)                \
+  _TYPE_::_TYPE_() { }                                                        \
+  Implemente_base_sans_constructeur_ni_destructeur(_TYPE_,_NOM_,_BASE_)
+
+#define Implemente_base(_TYPE_,_NOM_,_BASE_)                                \
+  _TYPE_::_TYPE_() { }                                                        \
+  _TYPE_::~_TYPE_() { }                                                        \
+  Implemente_base_sans_constructeur_ni_destructeur(_TYPE_,_NOM_,_BASE_)
+
+
+/////////////////////////////////////////
+/////// TEMPLATE VERSION for 32/64 bits !!! Oh yes baby!
+/////////////////////////////////////////
+
+// The declare remain identical but we create a new macro so that bin/KSH/mk_Instanciable spots it correctly:
+#define Declare_base_sans_constructeur_ni_destructeur_32_64(_TYPE_) Declare_base_sans_constructeur_ni_destructeur(_TYPE_>)
+#define Declare_base_sans_constructeur_32_64(_TYPE_) Declare_base_sans_constructeur(_TYPE_)
+#define Declare_base_sans_destructeur_32_64(_TYPE_) Declare_base_sans_destructeur(_TYPE_)
+#define Declare_base_32_64(_TYPE_) Declare_base(_TYPE_)
+
+// Helper macro for info_obj static variable definition:
+#if INT_is_64_ == 2
+# define info_obj_def_macro_base(_NOM_, _TYPE_) \
+  template <> const Type_info _TYPE_<int>::info_obj(_NOM_, 1, name2(_TYPE_,bases)<int> );  \
+  template <> const Type_info _TYPE_<trustIdType>::info_obj(_NOM_ "_64", 1, name2(_TYPE_, bases)<trustIdType> );
+#else
+# define info_obj_def_macro_base(_NOM_, _TYPE_) \
+  template <> const Type_info _TYPE_<int>::info_obj(_NOM_, 1, name2(_TYPE_,bases)<int> );
+#endif
+
+#ifdef LATATOOLS
+#define Implemente_base_sans_constructeur_ni_destructeur_32_64(_TYPE_,_NOM_,_BASE_)
+
+#else
+// The implemente are of course different:
+#define Implemente_base_sans_constructeur_ni_destructeur_32_64(_TYPE_,_NOM_,_BASE_) \
+                                                                        \
+  template <typename _T_> const Type_info* name2(_TYPE_,bases)[1] = { &(_BASE_::info_obj) };     \
+                                                                                                  \
+  info_obj_def_macro_base(_NOM_, _TYPE_)                               \
+                                                                        \
+  template <typename _T_> _TYPE_<_T_>& _TYPE_<_T_>::self_cast( Objet_U& r)   {                                \
+    return ref_cast_non_const(_TYPE_<_T_>,r); /* _non_const important sinon recursion dans ref_cast */ \
+  }                                                                        \
+  template <typename _T_> const _TYPE_<_T_>& _TYPE_<_T_>::self_cast(const Objet_U& r)   {                        \
+    return ref_cast_non_const(_TYPE_<_T_>,r); /* _non_const important sinon recursion dans ref_cast */ \
+  }                                                                        \
+  template <typename _T_> const Type_info*  _TYPE_<_T_>::get_info() const {                                \
+    return &info_obj;                                                        \
+  }                                                                        \
+  template <typename _T_> const Type_info*  _TYPE_<_T_>::info() {                                        \
+    return &info_obj;                                                        \
+  }                                                                          \
+  class __dummy__
+
+#endif // LATATOOLS
+
+#define Implemente_base_sans_constructeur_32_64(_TYPE_,_NOM_,_BASE_)                \
+  template <typename _T_> _TYPE_<_T_>::~_TYPE_() { }                                                        \
+  Implemente_base_sans_constructeur_ni_destructeur_32_64(_TYPE_,_NOM_,_BASE_)
+
+#define Implemente_base_sans_destructeur_32_64(_TYPE_,_NOM_,_BASE_)                \
+  template <typename _T_> _TYPE_<_T_>::_TYPE_() { }                                                        \
+  Implemente_base_sans_constructeur_ni_destructeur_32_64(_TYPE_,_NOM_,_BASE_)
+
+#define Implemente_base_32_64(_TYPE_,_NOM_,_BASE_)                                \
+  template <typename _T_> _TYPE_<_T_>::_TYPE_() { }                                                        \
+  template <typename _T_> _TYPE_<_T_>::~_TYPE_() { }                                                        \
+  Implemente_base_sans_constructeur_ni_destructeur_32_64(_TYPE_,_NOM_,_BASE_)
+
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Declare_Inst.h b/Utilities/VisItBridge/databases/readers/Lata/Declare_Inst.h
new file mode 100644
index 00000000..7111adf6
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Declare_Inst.h
@@ -0,0 +1,207 @@
+/****************************************************************************
+* Copyright (c) 2025, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+
+// .SECTION Description
+// les macros Declare_instanciable_sans_destructeur et
+// Implemente_instanciable_sans_destructeur
+// permettent de creer simplement des classes
+// de bases conforme a TRUST.
+
+// .SECTION Description du header
+// class A_base : public B {
+// Declare_instanciable_sans_destructeur(A_base);
+// };
+// .SECTION Description du source
+// Implemente_instanciable_sans_destructeur(A_base, "A_base", B);
+#include <Cast.h>
+#include <arch.h>
+
+#ifdef LATATOOLS
+#define Declare_instanciable_sans_constructeur_ni_destructeur(_TYPE_)        \
+                                                                        \
+  public :                                                                \
+  unsigned taille_memoire() const override { return 0; };                                      \
+  int duplique() const override { return 0; };                                                \
+  protected :                                                                \
+  Sortie& printOn(Sortie& x) const override;                                \
+  Entree& readOn(Entree&) override
+
+#else
+#define Declare_instanciable_sans_constructeur_ni_destructeur(_TYPE_)        \
+                                                                        \
+  public :                                                                \
+  static Objet_U* cree_instance() ;                                        \
+  unsigned taille_memoire() const override;                                        \
+  int duplique() const override;                                                \
+  static const Type_info info_obj;                                        \
+  static const Type_info* info();                                        \
+  const Type_info* get_info() const override;                                        \
+  /* methode rajoutee pour caster en python */                                \
+  static _TYPE_& self_cast( Objet_U&) ;                                        \
+  static const _TYPE_& self_cast(const Objet_U&) ;                        \
+  protected :                                                                \
+  Sortie& printOn(Sortie& x) const override;                                \
+  Entree& readOn(Entree&) override
+#endif
+
+#define Declare_instanciable_sans_constructeur(_TYPE_)                \
+  public:                                                        \
+  ~_TYPE_();                                                        \
+  Declare_instanciable_sans_constructeur_ni_destructeur(_TYPE_) \
+ 
+#define Declare_instanciable_sans_destructeur(_TYPE_)                \
+  public:                                                        \
+  _TYPE_();                                                        \
+  Declare_instanciable_sans_constructeur_ni_destructeur(_TYPE_) \
+ 
+#define Declare_instanciable(_TYPE_)                                \
+  public:                                                        \
+  _TYPE_();                                                        \
+  ~_TYPE_();                                                        \
+  Declare_instanciable_sans_constructeur_ni_destructeur(_TYPE_) \
+ 
+#ifdef LATATOOLS
+#define Implemente_instanciable_sans_constructeur_ni_destructeur(_TYPE_,_NOM_,_BASE_)
+
+#else
+#define Implemente_instanciable_sans_constructeur_ni_destructeur(_TYPE_,_NOM_,_BASE_) \
+                                                                        \
+  const Type_info* name2(_TYPE_,bases)[1]={                                \
+    &(_BASE_::info_obj)};                                                \
+  const Type_info _TYPE_::info_obj(_NOM_, _TYPE_::cree_instance, 1, name2(_TYPE_,bases)); \
+                                                                        \
+                                                                        \
+  int _TYPE_::duplique()  const                                        \
+  {                                                                        \
+    _TYPE_* xxx = new _TYPE_(*this);                                        \
+    if(!xxx){Cerr << "Not enough memory " << finl; exit();}                \
+    return xxx->numero();                                                \
+  }                                                                        \
+  _TYPE_& _TYPE_::self_cast( Objet_U& r)   {                                \
+    return ref_cast_non_const(_TYPE_,r); /* _non_const important sinon  recursion dans ref_cast */ \
+  }                                                                        \
+  const _TYPE_& _TYPE_::self_cast(const Objet_U& r)   {                        \
+    return ref_cast_non_const(_TYPE_,r); /* _non_const important sinon  recursion dans ref_cast */ \
+  }                                                                        \
+  Objet_U* _TYPE_::cree_instance()                                        \
+  {  _TYPE_* xxx = new _TYPE_();                                        \
+    if(!xxx){Cerr << "Not enough memory " << finl; exit();}                \
+    return xxx ;                                                        \
+  }                                                                        \
+                                                                        \
+  const Type_info*  _TYPE_::get_info() const {                                \
+    return &info_obj;                                                        \
+  }                                                                        \
+                                                                        \
+  const Type_info*  _TYPE_::info() {                                        \
+    return &info_obj;                                                        \
+  }                                                                        \
+                                                                        \
+  unsigned _TYPE_::taille_memoire() const {                                \
+    return sizeof(_TYPE_);                                                \
+  }                                                                      \
+  class __dummy__
+#endif
+
+#define Implemente_instanciable_sans_constructeur(_TYPE_,_NOM_,_BASE_)        \
+  _TYPE_::~_TYPE_() { }                                                        \
+  Implemente_instanciable_sans_constructeur_ni_destructeur(_TYPE_,_NOM_,_BASE_)
+
+#define Implemente_instanciable_sans_destructeur(_TYPE_,_NOM_,_BASE_)        \
+  _TYPE_::_TYPE_() { }                                                        \
+  Implemente_instanciable_sans_constructeur_ni_destructeur(_TYPE_,_NOM_,_BASE_)
+
+#define Implemente_instanciable(_TYPE_,_NOM_,_BASE_)                        \
+  _TYPE_::_TYPE_() { }                                                        \
+  _TYPE_::~_TYPE_() { }                                                        \
+  Implemente_instanciable_sans_constructeur_ni_destructeur(_TYPE_,_NOM_,_BASE_)
+
+
+/////////////////////////////////////////
+/////// TEMPLATE VERSION for 32/64 bits !!! Oh yes baby!
+/////////////////////////////////////////
+
+// The declare remain identical but we create a new macro so that bin/KSH/mk_Instanciable spots it correctly:
+#define Declare_instanciable_sans_constructeur_ni_destructeur_32_64(_TYPE_) Declare_instanciable_sans_constructeur_ni_destructeur(_TYPE_)
+#define Declare_instanciable_sans_constructeur_32_64(_TYPE_) Declare_instanciable_sans_constructeur(_TYPE_)
+#define Declare_instanciable_sans_destructeur_32_64(_TYPE_) Declare_instanciable_sans_destructeur(_TYPE_)
+#define Declare_instanciable_32_64(_TYPE_) Declare_instanciable(_TYPE_)
+
+// Helper macro for info_obj static variable definition:
+#if INT_is_64_ == 2
+# define info_obj_def_macro_inst(_NOM_, _TYPE_) \
+  template <> const Type_info _TYPE_<int>::info_obj(_NOM_, _TYPE_<int>::cree_instance, 1, name2(_TYPE_,bases)<int> );  \
+  template <> const Type_info _TYPE_<trustIdType>::info_obj(_NOM_ "_64", _TYPE_<trustIdType>::cree_instance, 1, name2(_TYPE_, bases)<trustIdType> );
+#else
+# define info_obj_def_macro_inst(_NOM_, _TYPE_) \
+  template <> const Type_info _TYPE_<int>::info_obj(_NOM_, _TYPE_<int>::cree_instance, 1, name2(_TYPE_,bases)<int> );
+#endif
+
+#ifdef LATATOOLS
+#define Implemente_instanciable_sans_constructeur_ni_destructeur_32_64(_TYPE_,_NOM_,_BASE_)
+#else
+// The implemente are of course different:
+#define Implemente_instanciable_sans_constructeur_ni_destructeur_32_64(_TYPE_,_NOM_,_BASE_) \
+                                                                                              \
+  template <typename _T_> const Type_info* name2(_TYPE_,bases)[1] = { &(_BASE_::info_obj) };     \
+                                                                                                  \
+  info_obj_def_macro_inst(_NOM_, _TYPE_)                               \
+                                                                        \
+  template <typename _T_> int _TYPE_<_T_>::duplique()  const                                        \
+  {                                                                        \
+    _TYPE_<_T_>* xxx = new _TYPE_<_T_>(*this);                                        \
+    if(!xxx){Cerr << "Not enough memory " << finl; Process::exit();}                \
+    return xxx->numero();                                                \
+  }                                                                        \
+  template <typename _T_> _TYPE_<_T_>& _TYPE_<_T_>::self_cast( Objet_U& r)   {                                \
+    return ref_cast_non_const(_TYPE_<_T_>,r); /* _non_const important sinon  recursion dans ref_cast */ \
+  }                                                                        \
+  template <typename _T_> const _TYPE_<_T_>& _TYPE_<_T_>::self_cast(const Objet_U& r)   {                        \
+    return ref_cast_non_const(_TYPE_<_T_>,r); /* _non_const important sinon  recursion dans ref_cast */ \
+  }                                                                        \
+  template <typename _T_> Objet_U* _TYPE_<_T_>::cree_instance()                                        \
+  {  _TYPE_<_T_>* xxx = new _TYPE_<_T_>();                                        \
+    if(!xxx){Cerr << "Not enough memory " << finl; Process::exit();}                \
+    return xxx ;                                                        \
+  }                                                                        \
+                                                                        \
+  template <typename _T_> const Type_info*  _TYPE_<_T_>::get_info() const {                                \
+    return &info_obj;                                                        \
+  }                                                                        \
+                                                                        \
+   template <typename _T_> const Type_info*  _TYPE_<_T_>::info() {                                        \
+    return &info_obj;                                                        \
+  }                                                                        \
+                                                                        \
+  template <typename _T_> unsigned _TYPE_<_T_>::taille_memoire() const {                                \
+    return sizeof(_TYPE_<_T_>);                                                \
+  }                                                                      \
+  class __dummy__
+
+#endif  // LATATOOLS
+
+#define Implemente_instanciable_sans_constructeur_32_64(_TYPE_,_NOM_,_BASE_)        \
+  template <typename _T_> _TYPE_<_T_>::~_TYPE_() { }                                                        \
+  Implemente_instanciable_sans_constructeur_ni_destructeur_32_64(_TYPE_,_NOM_,_BASE_)
+
+#define Implemente_instanciable_sans_destructeur_32_64(_TYPE_,_NOM_,_BASE_)        \
+  template <typename _T_> _TYPE_<_T_>::_TYPE_() { }                                                        \
+  Implemente_instanciable_sans_constructeur_ni_destructeur_32_64(_TYPE_,_NOM_,_BASE_)
+
+#define Implemente_instanciable_32_64(_TYPE_,_NOM_,_BASE_)                        \
+  template <typename _T_> _TYPE_<_T_>::_TYPE_() { }                                                        \
+  template <typename _T_> _TYPE_<_T_>::~_TYPE_() { }                                                        \
+  Implemente_instanciable_sans_constructeur_ni_destructeur_32_64(_TYPE_,_NOM_,_BASE_)
diff --git a/Utilities/VisItBridge/databases/readers/Lata/DescStructure.h b/Utilities/VisItBridge/databases/readers/Lata/DescStructure.h
new file mode 100644
index 00000000..49f00d04
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/DescStructure.h
@@ -0,0 +1,31 @@
+/****************************************************************************
+* Copyright (c) 2023, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef DescStructure_included
+#define DescStructure_included
+
+#include <TRUST_Vector.h>
+#include <Esp_Virt.h>
+#include <Esp_Dist.h>
+
+/*! @brief Sert a relire ancinne structure parallele
+ *
+ */
+class DescStructure : public Objet_U
+{
+  Declare_instanciable(DescStructure);
+};
+
+#endif /* DescStructure_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Descripteur.h b/Utilities/VisItBridge/databases/readers/Lata/Descripteur.h
new file mode 100644
index 00000000..2e21803f
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Descripteur.h
@@ -0,0 +1,35 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Descripteur_included
+#define Descripteur_included
+
+
+#include <Objet_U.h>
+
+/*! @brief
+ *
+ */
+class Descripteur : public Objet_U
+{
+  Declare_instanciable_sans_constructeur(Descripteur);
+public:
+  Descripteur();
+private:
+  int deb_;    // Indice de debut dans le tableau des donnees
+  int nb_;     // Nombre d'elements dans le tableau des donnees
+  int stride_;
+};
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Device.cpp b/Utilities/VisItBridge/databases/readers/Lata/Device.cpp
new file mode 100644
index 00000000..e53095be
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Device.cpp
@@ -0,0 +1,585 @@
+/****************************************************************************
+* Copyright (c) 2025, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <TRUSTTrav.h>
+#include <Device.h>
+#include <DeviceMemory.h>
+#include <ctime>
+#include <string>
+#include <sstream>
+#include <map>
+#include <tuple>
+
+#ifndef LATATOOLS
+#include <comm_incl.h>
+#include <Comm_Group_MPI.h>
+#endif
+
+bool init_openmp_ = false;
+bool clock_on = false;
+bool timer_on = true;
+double clock_start;
+int timer_counter=0;
+
+std::string ptrToString(const void* adr)
+{
+  std::stringstream ss;
+  ss << adr;
+  return ss.str();
+}
+
+// Voir AmgXWrapper (src/init.cpp)
+int AmgXWrapperScheduling(int rank, int nRanks, int nDevs)
+{
+  int devID;
+  if (nRanks <= nDevs) // Less process than devices
+    devID = rank;
+  else // More processes than devices
+    {
+      int nBasic = nRanks / nDevs,
+          nRemain = nRanks % nDevs;
+      if (rank < (nBasic+1)*nRemain)
+        devID = rank / (nBasic + 1);
+      else
+        devID = (rank - (nBasic+1)*nRemain) / nBasic + nRemain;
+    }
+  return devID;
+}
+
+
+#ifdef _OPENMP_TARGET
+// Set MPI processes to devices
+void init_openmp()
+{
+  // ToDo: OMP_TARGET_OFFLOAD=DISABLED equivaut a TRUST_DISABLE_DEVICE=1
+  // donc peut etre supprimer cette derniere variable (qui disable aussi rocALUTION sur GPU dans le code mais pas AmgX encore)...
+  // https://www.openmp.org/spec-html/5.0/openmpse65.html
+  if (init_openmp_ || getenv("TRUST_DISABLE_DEVICE")!=nullptr)
+    return;
+  char const* var = getenv("OMP_TARGET_OFFLOAD");
+  if (var!=nullptr && std::string(var)=="DISABLED")
+    return;
+  init_openmp_ = true;
+  if (getenv("TRUST_CLOCK_ON")!= nullptr) clock_on = true;
+  if (getenv("TRUST_DISABLE_TIMER")!= nullptr) timer_on = false;
+#ifdef MPI_
+  MPI_Comm localWorld;
+  MPI_Comm globalWorld;
+  if (sub_type(Comm_Group_MPI,PE_Groups::current_group()))
+    globalWorld = ref_cast(Comm_Group_MPI,PE_Groups::current_group()).get_mpi_comm();
+  else
+    globalWorld = MPI_COMM_WORLD;
+  MPI_Comm_split_type(globalWorld, MPI_COMM_TYPE_SHARED, 0, MPI_INFO_NULL, &localWorld);
+  True_int rank; // Local rank
+  MPI_Comm_rank(localWorld, &rank);
+  True_int nRanks; // Local number of ranks
+  MPI_Comm_size(localWorld, &nRanks);
+  // Node name:
+  True_int len;
+  char name[MPI_MAX_PROCESSOR_NAME];
+  MPI_Get_processor_name(name, &len);
+  std::string nodeName = name;
+  int nDevs = omp_get_num_devices(); // Local number of devices
+  if (nDevs==0)
+    {
+      Cerr << "Error, no device detected during OpenMP initialization." << finl;
+      Process::exit();
+    }
+  int devID = AmgXWrapperScheduling(rank, nRanks, nDevs);
+  Cerr << "[OpenMP] Initialization on the device(s):"  << finl;
+  cerr << "[OpenMP] Assigning local rank " << rank << " (global rank " << Process::me() << ") of node " << nodeName.c_str() << " to its device " << devID << "/" << nDevs-1 << endl;
+  omp_set_default_device(devID);
+#endif
+  // Dummy target region, so as not to measure startup time later:
+  #pragma omp target
+  { ; }
+  // ToDo Kokkos:
+  if (nDevs>1 && nRanks>nDevs)
+    {
+      Cerr << "Error!" << finl;
+      Cerr << "You can't use more MPI ranks than available  GPU devices per node for the moment !" << finl;
+      Cerr << "Use the same number of MPI ranks than GPU per node." << finl;
+      Cerr << "Or You can force MPI ranks using one device only: CUDA_VISIBLE_DEVICES=0" << finl;
+      Process::exit();
+    }
+  Process::imprimer_ram_totale(); // Impression avant copie des donnees sur GPU
+}
+#endif
+
+#ifndef LATATOOLS
+#ifdef TRUST_USE_CUDA
+#include <cuda_runtime.h>
+void init_cuda()
+{
+  // Necessaire sur JeanZay pour utiliser GPU Direct (http://www.idris.fr/jean-zay/gpu/jean-zay-gpu-mpi-cuda-aware-gpudirect.html)
+  // mais performances moins bonnes (trust PAR_gpu_3D 2) donc desactive en attendant d'autres tests:
+  // Absolument necessaire sur JeanZay (si OpenMPU-Cuda car sinon plantages lors des IO)
+  // Voir: https://www.open-mpi.org/faq/?category=runcuda#mpi-cuda-aware-support pour activer ou non a la compilation !
+#if defined(MPIX_CUDA_AWARE_SUPPORT) && MPIX_CUDA_AWARE_SUPPORT
+  char* local_rank_env;
+  cudaError_t cudaRet;
+  /* Recuperation du rang local du processus via la variable d'environnement
+     positionnee par Slurm, l'utilisation de MPI_Comm_rank n'etant pas encore
+     possible puisque cette routine est utilisee AVANT l'initialisation de MPI */
+  // ToDo pourrait etre appelee plus tard dans AmgX ou PETSc GPU...
+  local_rank_env = getenv("SLURM_LOCALID");
+  if (local_rank_env)
+    {
+      int rank = atoi(local_rank_env);
+      int nRanks = atoi(getenv("SLURM_NTASKS"));
+      if (rank==0) printf("The MPI library has CUDA-aware support and TRUST will try using this feature...\n");
+      /* Definition du GPU a utiliser pour chaque processus MPI */
+      True_int nDevs = 0;
+      cudaGetDeviceCount(&nDevs);
+      int devID = AmgXWrapperScheduling(rank, nRanks, nDevs);
+      cudaRet = cudaSetDevice(devID);
+      if(cudaRet != cudaSuccess)
+        {
+          printf("Error: cudaSetDevice failed\n");
+          abort();
+        }
+      else
+        {
+          if (rank==0) printf("init_cuda() done!");
+          cerr << "[MPI] Assigning rank " << rank << " to device " << devID << endl;
+        }
+    }
+  else
+    {
+      printf("Error : can't guess the local rank of the task\n");
+      abort();
+    }
+#endif     /* MPIX_CUDA_AWARE_SUPPORT */
+}
+#endif /* TRUST_USE_CUDA */
+#endif /* LATATOOLS */
+
+// Adress on device (return host adress if no device):
+template <typename _TYPE_, typename _SIZE_>
+_TYPE_* addrOnDevice(TRUSTArray<_TYPE_,_SIZE_>& tab)
+{
+#ifdef _OPENMP_TARGET
+  if (tab.get_data_location()==DataLocation::HostOnly) return tab.data();
+  _TYPE_ *device_ptr = nullptr;
+  _TYPE_ *ptr = tab.data();
+  #pragma omp target data use_device_ptr(ptr)
+  {
+    device_ptr = ptr;
+  }
+  return device_ptr;
+#else
+  return tab.data();
+#endif
+}
+
+// Allocate on device:
+template <typename _TYPE_, typename _SIZE_>
+_TYPE_* allocateOnDevice(TRUSTArray<_TYPE_,_SIZE_>& tab, std::string arrayName)
+{
+  _TYPE_ *tab_addr = tab.data();
+#ifdef _OPENMP_TARGET
+  if (Objet_U::computeOnDevice)
+    {
+      if (isAllocatedOnDevice(tab)) deleteOnDevice(tab);
+      allocateOnDevice(tab_addr, tab.size_mem(), "an array "+arrayName);
+      tab.set_data_location(DataLocation::Device);
+    }
+#endif
+  return tab_addr;
+}
+
+template <typename _TYPE_, typename _SIZE_>
+_TYPE_* allocateOnDevice(_TYPE_* ptr, _SIZE_ size, std::string arrayName)
+{
+#ifdef _OPENMP_TARGET
+  if (Objet_U::computeOnDevice)
+    {
+      assert(!isAllocatedOnDevice(ptr)); // Verifie que la zone n'est pas deja allouee
+      clock_start = Statistiques::get_time_now();
+      size_t bytes = sizeof(_TYPE_) * size;
+      size_t free_bytes  = DeviceMemory::deviceMemGetInfo(0);
+      size_t total_bytes = DeviceMemory::deviceMemGetInfo(1);
+      if (bytes>free_bytes)
+        {
+          Cerr << "Error ! Trying to allocate " << bytes << " bytes on GPU memory whereas only " << free_bytes << " bytes are available." << finl;
+          Process::exit();
+        }
+      #pragma omp target enter data map(alloc:ptr[0:size])
+      DeviceMemory::getMemoryMap()[ptr] = {size, DataLocation::Host};
+#ifndef NDEBUG
+      static const _TYPE_ INVALIDE_ = (std::is_same<_TYPE_,double>::value) ? DMAXFLOAT*0.999 : ( (std::is_same<_TYPE_,int>::value) ? INT_MIN : 0); // Identique a TRUSTArray<_TYPE_>::fill_default_value()
+      #pragma omp target teams distribute parallel for if (Objet_U::computeOnDevice)
+      for (int i = 0; i < size; i++) ptr[i] = INVALIDE_;
+#endif
+      if (clock_on)
+        {
+          std::string clock(Process::is_parallel() ? "[clock]#"+std::to_string(Process::me()) : "[clock]  ");
+          double ms = 1000 * (Statistiques::get_time_now() - clock_start);
+          printf("%s %7.3f ms [Data]   Allocate %s on device [%9s] %6ld Bytes (%ld/%ldGB free) Currently allocated: %6ld\n", clock.c_str(), ms, arrayName.c_str(), ptrToString(ptr).c_str(), long(bytes), free_bytes/(1024*1024*1024), total_bytes/(1024*1024*1024), long(DeviceMemory::allocatedBytesOnDevice()));
+        }
+    }
+#endif
+  return ptr;
+}
+
+// Delete on device:
+template <typename _TYPE_, typename _SIZE_>
+void deleteOnDevice(TRUSTArray<_TYPE_,_SIZE_>& tab)
+{
+#ifdef _OPENMP_TARGET
+  if (Objet_U::computeOnDevice)
+    {
+      _TYPE_ *tab_addr = tab.data();
+      if (init_openmp_ && tab_addr && isAllocatedOnDevice(tab))
+        {
+          deleteOnDevice(tab_addr, tab.size_mem());
+          tab.set_data_location(DataLocation::HostOnly);
+        }
+    }
+#endif
+}
+
+template <typename _TYPE_, typename _SIZE_>
+void deleteOnDevice(_TYPE_* ptr, _SIZE_ size)
+{
+#ifdef _OPENMP_TARGET
+  if (Objet_U::computeOnDevice)
+    {
+      std::string clock;
+      if (PE_Groups::get_nb_groups()>0 && Process::is_parallel()) clock = "[clock]#"+std::to_string(Process::me());
+      else
+        clock = "[clock]  ";
+      _SIZE_ bytes = sizeof(_TYPE_) * size;
+      if (clock_on)
+        cout << clock << "            [Data]   Delete on device array [" << ptrToString(ptr).c_str() << "] of " << bytes << " Bytes. It remains " << DeviceMemory::getMemoryMap().size()-1 << " arrays." << endl << flush;
+      #pragma omp target exit data map(delete:ptr[0:size])
+      if (PE_Groups::get_nb_groups()>0) DeviceMemory::getMemoryMap().erase(ptr);
+    }
+#endif
+}
+
+// Update const array on device if necessary
+// Before		After		Copy ?
+// HostOnly	    HostDevice	Yes
+// Host		    HostDevice	Yes
+// HostDevice	HostDevice	No
+// Device		Device		No
+template <typename _TYPE_, typename _SIZE_>
+const _TYPE_* mapToDevice(const TRUSTArray<_TYPE_,_SIZE_>& tab, std::string arrayName, const bool enabled)
+{
+  if (!enabled)
+    return tab.data();
+  else
+    {
+      // Update data on device if necessary
+      DataLocation loc = tab.isDataOnDevice() ? tab.get_data_location() : DataLocation::HostDevice;
+      const _TYPE_ *tab_addr = mapToDevice_(const_cast<TRUSTArray<_TYPE_,_SIZE_> &>(tab),
+                                            loc, arrayName);
+      return tab_addr;
+    }
+}
+
+template <typename _TYPE_, typename _SIZE_>
+_TYPE_* mapToDevice_(TRUSTArray<_TYPE_,_SIZE_>& tab, DataLocation nextLocation, std::string arrayName)
+{
+  _TYPE_ *tab_addr = tab.data();
+#ifdef _OPENMP_TARGET
+  if (Objet_U::computeOnDevice)
+    {
+      init_openmp();
+      self_test();
+      DataLocation currentLocation = tab.get_data_location();
+      tab.set_data_location(nextLocation); // Important de specifier le nouveau status avant la recuperation du pointeur:
+      // Important for ref_array/ref_tab support, we take the size of the memory allocated, not the size of the array (tab.size_array()):
+      //int memory_size = tab.size_array();
+      int memory_size = tab.size_mem();
+      if (currentLocation==DataLocation::HostOnly)
+        {
+          // Not a Trav which is already allocated on device:
+          if (!(tab.get_mem_storage() == STORAGE::TEMP_STORAGE && isAllocatedOnDevice(tab_addr)))
+            allocateOnDevice(tab_addr, memory_size);
+          copyToDevice(tab_addr, memory_size, "array "+arrayName);
+        }
+      else if (currentLocation==DataLocation::Host)
+        {
+          copyToDevice(tab_addr, memory_size, "array " + arrayName);
+          if (DeviceMemory::warning(memory_size)) // Warning for large array only:
+            ToDo_Kokkos("H2D update of large array! Add a breakpoint to find the reason.");
+        }
+      else if (currentLocation==DataLocation::PartialHostDevice)
+        Process::exit("Error, can't map on device an array with PartialHostDevice status!");
+    }
+#endif
+  return tab_addr;
+}
+
+template <typename _TYPE_, typename _SIZE_>
+void copyToDevice(_TYPE_* ptr, _SIZE_ size, std::string arrayName)
+{
+#ifdef _OPENMP_TARGET
+  if (Objet_U::computeOnDevice)
+    {
+      assert(isAllocatedOnDevice(ptr) || size==0);
+      _SIZE_ bytes = sizeof(_TYPE_) * size;
+      start_gpu_timer("copyToDevice",bytes);
+      if (timer_on) statistiques().begin_count(gpu_copytodevice_counter_);
+      #pragma omp target update to(ptr[0:size])
+      if (timer_on) statistiques().end_count(gpu_copytodevice_counter_, bytes);
+      std::stringstream message;
+      message << "Copy to device " << arrayName << " [" << ptrToString(ptr) << "]";
+      end_gpu_timer(Objet_U::computeOnDevice, message.str(), bytes);
+    }
+#endif
+}
+
+// Copy non-const array on device if necessary for computation on device
+template <typename _TYPE_, typename _SIZE_>
+_TYPE_* computeOnTheDevice(TRUSTArray<_TYPE_,_SIZE_>& tab, std::string arrayName, const bool enabled)
+{
+  if (!enabled)
+    return tab.data();
+  else
+    {
+      // non-const array will be modified on device:
+      _TYPE_ *tab_addr = mapToDevice_(tab, DataLocation::Device, arrayName);
+      return tab_addr;
+    }
+}
+
+// ToDo OpenMP: rename copy -> update or map ?
+// Copy non-const array to host from device
+template <typename _TYPE_, typename _SIZE_>
+void copyFromDevice(TRUSTArray<_TYPE_,_SIZE_>& tab, std::string arrayName)
+{
+#ifdef _OPENMP_TARGET
+  if (Objet_U::computeOnDevice && tab.get_data_location() == DataLocation::Device)
+    {
+      copyFromDevice(tab.data(), tab.size_mem(), " array " + arrayName);
+      tab.set_data_location(DataLocation::HostDevice);
+    }
+#endif
+}
+template <typename _TYPE_, typename _SIZE_>
+void copyFromDevice(_TYPE_* ptr, _SIZE_ size, std::string arrayName)
+{
+#ifdef _OPENMP_TARGET
+  if (Objet_U::computeOnDevice)
+    {
+      assert(isAllocatedOnDevice(ptr) || size==0);
+      _SIZE_ bytes = sizeof(_TYPE_) * size;
+      start_gpu_timer("copyFromDevice",bytes);
+      if (timer_on) statistiques().begin_count(gpu_copyfromdevice_counter_);
+      #pragma omp target update from(ptr[0:size])
+      if (timer_on) statistiques().end_count(gpu_copyfromdevice_counter_, bytes);
+      std::stringstream message;
+      message << "Copy from device" << arrayName << " [" << ptrToString(ptr) << "] " << size << " items ";
+      end_gpu_timer(Objet_U::computeOnDevice, message.str(), bytes);
+      if (clock_on) printf("\n");
+      if (DeviceMemory::warning(size)) // Warning for large array only:
+        ToDo_Kokkos("D2H update of large array! Add a breakpoint to find the reason if not IO.");
+    }
+#endif
+}
+
+// Copy const array to host from device
+template <typename _TYPE_, typename _SIZE_>
+void copyFromDevice(const TRUSTArray<_TYPE_,_SIZE_>& tab, std::string arrayName)
+{
+  copyFromDevice(const_cast<TRUSTArray<_TYPE_,_SIZE_>&>(tab), arrayName);
+}
+
+// Partial copy of an array (from deb to fin element) from host to device
+// Typical example: Deal with boundary condition (small loop) on the host
+// copyPartialFromDevice(resu, 0, premiere_face_int);   // Faces de bord
+// copyPartialFromDevice(resu, nb_faces, nb_faces_tot); // Pour ajouter les faces de bord virtuelles si necessaire
+template <typename _TYPE_>
+void copyPartialFromDevice(TRUSTArray<_TYPE_>& tab, int deb, int fin, std::string arrayName)
+{
+#ifdef _OPENMP_TARGET
+  if (Objet_U::computeOnDevice)
+    {
+      if (tab.get_data_location()==DataLocation::Device || tab.get_data_location()==DataLocation::PartialHostDevice)
+        {
+          int bytes = sizeof(_TYPE_) * (fin-deb);
+          _TYPE_ *tab_addr = tab.data();
+          start_gpu_timer("copyPartialFromDevice",bytes);
+          if (timer_on) statistiques().begin_count(gpu_copyfromdevice_counter_);
+          #pragma omp target update from(tab_addr[deb:fin-deb])
+          if (timer_on) statistiques().end_count(gpu_copyfromdevice_counter_, bytes);
+          std::string message;
+          message = "Partial update from device of array "+arrayName+" ["+ptrToString(tab_addr)+"]";
+          end_gpu_timer(Objet_U::computeOnDevice, message, bytes);
+          tab.set_data_location(DataLocation::PartialHostDevice);
+        }
+    }
+#endif
+}
+
+// Partial copy of an array (from deb to fin element) from host to device
+template <typename _TYPE_>
+void copyPartialToDevice(TRUSTArray<_TYPE_>& tab, int deb, int fin, std::string arrayName)
+{
+#ifdef _OPENMP_TARGET
+  if (Objet_U::computeOnDevice && tab.get_data_location()==DataLocation::PartialHostDevice)
+    {
+      int bytes = sizeof(_TYPE_) * (fin-deb);
+      _TYPE_ *tab_addr = tab.data();
+      start_gpu_timer("copyPartialToDevice",bytes);
+      if (timer_on) statistiques().begin_count(gpu_copytodevice_counter_);
+      #pragma omp target update to(tab_addr[deb:fin-deb])
+      if (timer_on) statistiques().end_count(gpu_copytodevice_counter_, bytes);
+      std::string message;
+      message = "Partial update to device of array "+arrayName+" ["+ptrToString(tab_addr)+"]";
+      end_gpu_timer(Objet_U::computeOnDevice, message, bytes);
+      tab.set_data_location(DataLocation::Device);
+    }
+#endif
+}
+
+template <typename _TYPE_>
+void copyPartialToDevice(const TRUSTArray<_TYPE_>& tab, int deb, int fin, std::string arrayName)
+{
+#ifdef _OPENMP_TARGET
+  if (Objet_U::computeOnDevice && tab.get_data_location()==DataLocation::PartialHostDevice)
+    {
+      // ToDo OpenMP par de recopie car si le tableau est const il n'a ete modifie sur le host
+      const_cast<TRUSTArray<_TYPE_>&>(tab).set_data_location(DataLocation::Device);
+    }
+#endif
+}
+
+//
+//  Explicit template instanciations
+//
+template double* addrOnDevice<double>(TRUSTArray<double>& tab);
+template int* addrOnDevice<int>(TRUSTArray<int>& tab);
+template float* addrOnDevice<float>(TRUSTArray<float>& tab);
+
+template double* allocateOnDevice<double>(TRUSTArray<double>& tab, std::string arrayName);
+template int* allocateOnDevice<int>(TRUSTArray<int>& tab, std::string arrayName);
+template float* allocateOnDevice<float>(TRUSTArray<float>& tab, std::string arrayName);
+template char* allocateOnDevice<char>(char* ptr, int size, std::string arrayName);
+
+template const double* allocateOnDevice<double>(const TRUSTArray<double>& tab, std::string arrayName);
+template const int* allocateOnDevice<int>(const TRUSTArray<int>& tab, std::string arrayName);
+template const float* allocateOnDevice<float>(const TRUSTArray<float>& tab, std::string arrayName);
+
+template void deleteOnDevice<double>(TRUSTArray<double>& tab);
+template void deleteOnDevice<int>(TRUSTArray<int>& tab);
+template void deleteOnDevice<float>(TRUSTArray<float>& tab);
+template void deleteOnDevice<char>(char* ptr, int size);
+template void deleteOnDevice<int>(int* ptr, int size);
+template void deleteOnDevice<float>(float* ptr, int size);
+template void deleteOnDevice<double>(double* ptr, int size);
+
+template const double* mapToDevice<double>(const TRUSTArray<double>& tab, std::string arrayName, bool enabled);
+template const int* mapToDevice<int>(const TRUSTArray<int>& tab, std::string arrayName, bool enabled);
+template const float* mapToDevice<float>(const TRUSTArray<float>& tab, std::string arrayName, bool enabled);
+template void copyToDevice<char>(char* ptr, int size, std::string arrayName);
+
+template double* mapToDevice_<double>(TRUSTArray<double>& tab, DataLocation nextLocation, std::string arrayName);
+template int* mapToDevice_<int>(TRUSTArray<int>& tab, DataLocation nextLocation, std::string arrayName);
+template float* mapToDevice_<float>(TRUSTArray<float>& tab, DataLocation nextLocation, std::string arrayName);
+
+template double* computeOnTheDevice<double>(TRUSTArray<double>& tab, std::string arrayName, bool enabled);
+template int* computeOnTheDevice<int>(TRUSTArray<int>& tab, std::string arrayName, bool enabled);
+template float* computeOnTheDevice<float>(TRUSTArray<float>& tab, std::string arrayName, bool enabled);
+
+template void copyFromDevice<double>(TRUSTArray<double>& tab, std::string arrayName);
+template void copyFromDevice<int>(TRUSTArray<int>& tab, std::string arrayName);
+template void copyFromDevice<float>(TRUSTArray<float>& tab, std::string arrayName);
+template void copyFromDevice<char>(char* ptr, int size, std::string arrayName);
+
+template void copyFromDevice<double>(const TRUSTArray<double>& tab, std::string arrayName);
+template void copyFromDevice<int>(const TRUSTArray<int>& tab, std::string arrayName);
+template void copyFromDevice<float>(const TRUSTArray<float>& tab, std::string arrayName);
+
+template void copyPartialFromDevice<double>(TRUSTArray<double>& tab, int deb, int fin, std::string arrayName);
+template void copyPartialFromDevice<int>(TRUSTArray<int>& tab, int deb, int fin, std::string arrayName);
+template void copyPartialFromDevice<float>(TRUSTArray<float>& tab, int deb, int fin, std::string arrayName);
+
+template void copyPartialToDevice<double>(TRUSTArray<double>& tab, int deb, int fin, std::string arrayName);
+template void copyPartialToDevice<int>(TRUSTArray<int>& tab, int deb, int fin, std::string arrayName);
+template void copyPartialToDevice<float>(TRUSTArray<float>& tab, int deb, int fin, std::string arrayName);
+
+template void copyPartialToDevice<double>(const TRUSTArray<double>& tab, int deb, int fin, std::string arrayName);
+template void copyPartialToDevice<int>(const TRUSTArray<int>& tab, int deb, int fin, std::string arrayName);
+template void copyPartialToDevice<float>(const TRUSTArray<float>& tab, int deb, int fin, std::string arrayName);
+
+#if INT_is_64_ == 2
+
+// The ones needed for 64 bits:
+template double* addrOnDevice<double>(TRUSTArray<double,trustIdType>& tab);
+template int* addrOnDevice<int>(TRUSTArray<int,trustIdType>& tab);
+template trustIdType* addrOnDevice<trustIdType>(TRUSTArray<trustIdType,trustIdType>& tab);
+template trustIdType* addrOnDevice<trustIdType>(TRUSTArray<trustIdType,int>& tab);
+template float* addrOnDevice<float>(TRUSTArray<float,trustIdType>& tab);
+
+template double* allocateOnDevice<double>(TRUSTArray<double,trustIdType>& tab, std::string arrayName);
+template int* allocateOnDevice<int>(TRUSTArray<int,trustIdType>& tab, std::string arrayName);
+template trustIdType* allocateOnDevice<trustIdType>(TRUSTArray<trustIdType,trustIdType>& tab, std::string arrayName);
+template trustIdType* allocateOnDevice<trustIdType>(TRUSTArray<trustIdType,int>& tab, std::string arrayName);
+template float* allocateOnDevice<float>(TRUSTArray<float,trustIdType>& tab, std::string arrayName);
+
+template const double* allocateOnDevice<double>(const TRUSTArray<double,trustIdType>& tab, std::string arrayName);
+template const int* allocateOnDevice<int>(const TRUSTArray<int,trustIdType>& tab, std::string arrayName);
+template const trustIdType* allocateOnDevice<trustIdType>(const TRUSTArray<trustIdType,trustIdType>& tab, std::string arrayName);
+template const trustIdType* allocateOnDevice<trustIdType>(const TRUSTArray<trustIdType,int>& tab, std::string arrayName);
+template const float* allocateOnDevice<float>(const TRUSTArray<float,trustIdType>& tab, std::string arrayName);
+
+template void deleteOnDevice<double>(TRUSTArray<double,trustIdType>& tab);
+template void deleteOnDevice<int>(TRUSTArray<int,trustIdType>& tab);
+template void deleteOnDevice<trustIdType>(TRUSTArray<trustIdType,trustIdType>& tab);
+template void deleteOnDevice<trustIdType>(TRUSTArray<trustIdType,int>& tab);
+template void deleteOnDevice<float>(TRUSTArray<float,trustIdType>& tab);
+
+template void deleteOnDevice<int>(int* ptr, long size);
+template void deleteOnDevice<int>(int* ptr, long long size);
+template void deleteOnDevice<trustIdType>(trustIdType* ptr, long size);
+template void deleteOnDevice<trustIdType>(trustIdType* ptr, long long size);
+template void deleteOnDevice<trustIdType>(trustIdType* ptr, int size);
+template void deleteOnDevice<float>(float* ptr, long size);
+template void deleteOnDevice<double>(double* ptr, long size);
+template void deleteOnDevice<float>(float* ptr, long long size);
+template void deleteOnDevice<double>(double* ptr, long long size);
+
+template const double* mapToDevice<double>(const TRUSTArray<double,trustIdType>& tab, std::string arrayName, bool enabled);
+template const int* mapToDevice<int>(const TRUSTArray<int,trustIdType>& tab, std::string arrayName, bool enabled);
+template const trustIdType* mapToDevice<trustIdType>(const TRUSTArray<trustIdType,trustIdType>& tab, std::string arrayName, bool enabled);
+template const trustIdType* mapToDevice<trustIdType>(const TRUSTArray<trustIdType,int>& tab, std::string arrayName, bool enabled);
+template const float* mapToDevice<float>(const TRUSTArray<float,trustIdType>& tab, std::string arrayName, bool enabled);
+
+template int* computeOnTheDevice(TRUSTArray<int,trustIdType>& tab, std::string arrayName, bool enabled);
+template trustIdType* computeOnTheDevice(TRUSTArray<trustIdType,trustIdType>& tab, std::string arrayName, bool enabled);
+template trustIdType* computeOnTheDevice(TRUSTArray<trustIdType,int>& tab, std::string arrayName, bool enabled);
+template float* computeOnTheDevice(TRUSTArray<float,trustIdType>& tab, std::string arrayName, bool enabled);
+template double* computeOnTheDevice(TRUSTArray<double,trustIdType>& tab, std::string arrayName, bool enabled);
+
+template void copyFromDevice<int, trustIdType>(TRUSTArray<int,trustIdType>& tab, std::string arrayName);
+template void copyFromDevice<trustIdType, int>(TRUSTArray<trustIdType,int>& tab, std::string arrayName);
+template void copyFromDevice<trustIdType, trustIdType>(TRUSTArray<trustIdType,trustIdType>& tab, std::string arrayName);
+template void copyFromDevice<float, trustIdType>(TRUSTArray<float,trustIdType>& tab, std::string arrayName);
+template void copyFromDevice<double, trustIdType>(TRUSTArray<double,trustIdType>& tab, std::string arrayName);
+
+// With const:
+template void copyFromDevice<int, trustIdType>(const TRUSTArray<int,trustIdType>& tab, std::string arrayName);
+template void copyFromDevice<trustIdType, int>(const TRUSTArray<trustIdType,int>& tab, std::string arrayName);
+template void copyFromDevice<trustIdType, trustIdType>(const TRUSTArray<trustIdType,trustIdType>& tab, std::string arrayName);
+template void copyFromDevice<float, trustIdType>(const TRUSTArray<float,trustIdType>& tab, std::string arrayName);
+template void copyFromDevice<double, trustIdType>(const TRUSTArray<double,trustIdType>& tab, std::string arrayName);
+
+
+#endif
+
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Device.h b/Utilities/VisItBridge/databases/readers/Lata/Device.h
new file mode 100644
index 00000000..edceccbf
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Device.h
@@ -0,0 +1,236 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Device_included
+#define Device_included
+
+#include <TRUSTTabs_forward.h>
+#include <Nom.h>
+#include <stat_counters.h>
+#include <kokkos++.h>
+
+#if defined(TRUST_USE_CUDA) || defined(TRUST_USE_ROCM)
+// Use our own macro _OPENMP_TARGET instead of _OPENMP to differentiate from host OpenMP backend
+#if defined(_OPENMP)
+#define _OPENMP_TARGET
+#endif
+#endif
+#ifdef _OPENMP_TARGET
+#include <omp.h>
+#ifdef TRUST_USE_CUDA
+#include <nvtx3/nvToolsExt.h>
+#endif
+// See https://nvidia.github.io/NVTX/
+// See https://stackoverflow.com/questions/23230003/something-between-func-and-pretty-function/29856690#29856690
+#endif
+
+// TODO - scope all this, global vars are bad.
+extern bool init_openmp_, clock_on, timer_on;
+extern double clock_start;
+extern int timer_counter;
+
+void self_test();
+void init_openmp();
+void init_cuda();
+std::string ptrToString(const void* adr);
+
+#ifdef _OPENMP_TARGET
+#define ToDo_Kokkos(str)                              \
+        printf("[Kokkos %s] Warning, code running slow cause not ported yet: line %d in %s \n", str, __LINE__, __FILE__);
+#else
+#define ToDo_Kokkos(str)
+#endif
+
+// Macro Kernel_Name
+#ifdef _OPENMP_TARGET
+inline const std::string methodName(const std::string& prettyFunction, const int line)
+{
+  size_t colons = prettyFunction.find("::");
+  if (colons != std::string::npos)
+    {
+      // method::class:line
+      size_t begin = prettyFunction.substr(0, colons).rfind(" ") + 1;
+      size_t end = prettyFunction.rfind("(") - begin;
+      return prettyFunction.substr(begin, end) + ":" + std::to_string(line);
+    }
+  else
+    {
+      // return_type function:line
+      colons = prettyFunction.find('(');
+      return prettyFunction.substr(0, colons) + ":" + std::to_string(line);
+    }
+}
+#define __KERNEL_NAME__ methodName(__PRETTY_FUNCTION__,__LINE__)
+#else
+#define __KERNEL_NAME__ ""
+#endif
+
+// Timers GPU avec OpenMP (renommer?)
+inline std::string start_gpu_timer(std::string str="kernel", int bytes=-1)
+{
+#ifdef _OPENMP_TARGET
+  if (init_openmp_ && timer_on)
+    {
+      timer_counter++;
+      if (clock_on) clock_start = Statistiques::get_time_now();
+      if (bytes == -1) statistiques().begin_count(gpu_kernel_counter_, false);
+#ifdef TRUST_USE_CUDA
+      if (!str.empty()) nvtxRangePush(str.c_str());
+#endif
+    }
+#endif
+  return str;
+}
+
+inline void end_gpu_timer(int onDevice, const std::string& str, int bytes=-1) // Return in [ms]
+{
+#ifdef _OPENMP_TARGET
+  if (init_openmp_ && timer_on)
+    {
+      timer_counter--;
+#ifndef NDEBUG
+      if (timer_counter!=0)
+        Cerr << "[Kokkos] timer_counter=" << timer_counter << " : start_gpu_timer() not closed by end_gpu_timer() !" << finl;
+      //Process::exit("Error, start_gpu_timer() not closed by end_gpu_timer() !");
+#endif
+      if (onDevice)
+        {
+#ifdef TRUST_USE_UVM
+          cudaDeviceSynchronize();
+#endif
+#ifdef KOKKOS
+          Kokkos::fence();  // Barrier for real time
+#endif
+        }
+      if (bytes == -1) statistiques().end_count(gpu_kernel_counter_, 0, onDevice, false);
+      if (clock_on) // Affichage
+        {
+          std::string clock(Process::is_parallel() ? "[clock]#" + std::to_string(Process::me()) : "[clock]  ");
+          double ms = 1000 * (Statistiques::get_time_now() - clock_start);
+          if (bytes == -1)
+            {
+              if (!str.empty())
+                printf("%s %7.3f ms [%s] %15s\n", clock.c_str(), ms, onDevice ? "Device" : "Host", str.c_str());
+            }
+          else
+            {
+              double mo = (double) bytes / 1024 / 1024;
+              if (ms == 0 || bytes == 0)
+                printf("%s            [Data]   %15s\n", clock.c_str(), str.c_str());
+              else
+                printf("%s %7.3f ms [Data]   %15s %6ld Bytes %5.1f Go/s\n", clock.c_str(), ms, str.c_str(),
+                       long(bytes), mo / ms);
+              //printf("%s %7.3f ms [Data]   %15s %6ld Mo %5.1f Go/s\n", clock.c_str(), ms, str.c_str(), long(mo), mo/ms);
+            }
+          fflush(stdout);
+        }
+#ifdef TRUST_USE_CUDA
+      if (!str.empty()) nvtxRangePop();
+#endif
+    }
+#endif
+}
+
+template <typename _TYPE_, typename _SIZE_=int>
+extern _TYPE_* addrOnDevice(TRUSTArray<_TYPE_,_SIZE_>& tab);
+
+template <typename _TYPE_, typename _SIZE_=int>
+inline const _TYPE_* addrOnDevice(const TRUSTArray<_TYPE_,_SIZE_>& tab)
+{
+  return addrOnDevice(const_cast<TRUSTArray<_TYPE_,_SIZE_>&>(tab));
+}
+
+template <typename _TYPE_, typename _SIZE_=int>
+extern _TYPE_* allocateOnDevice(TRUSTArray<_TYPE_,_SIZE_>& tab, std::string arrayName="??");
+
+template <typename _TYPE_, typename _SIZE_=int>
+inline const _TYPE_* allocateOnDevice(const TRUSTArray<_TYPE_,_SIZE_>& tab, std::string arrayName="??")
+{
+  return allocateOnDevice(const_cast<TRUSTArray<_TYPE_,_SIZE_>&>(tab), arrayName);
+}
+
+template <typename _TYPE_>
+bool isAllocatedOnDevice(_TYPE_* tab_addr)
+{
+  // Routine omp_target_is_present pour existence d'une adresse sur le device
+  // https://www.openmp.org/spec-html/5.0/openmpse34.html#openmpsu168.html
+#ifdef _OPENMP_TARGET
+  return omp_target_is_present(tab_addr, omp_get_default_device())==1;
+#else
+  return false;
+#endif
+}
+
+template <typename _TYPE_, typename _SIZE_=int>
+bool isAllocatedOnDevice(TRUSTArray<_TYPE_,_SIZE_>& tab)
+{
+#ifdef _OPENMP_TARGET
+  bool isAllocatedOnDevice1 = (tab.get_data_location() != DataLocation::HostOnly);
+  bool isAllocatedOnDevice2 = isAllocatedOnDevice(tab.data());
+  if (isAllocatedOnDevice1!=isAllocatedOnDevice2) Process::exit("isAllocatedOnDevice(TRUSTArray<_TYPE_>& tab) error! Seems tab.get_data_location() is not up-to-date !");
+  return isAllocatedOnDevice2;
+#else
+  return false;
+#endif
+}
+
+template <typename _TYPE_, typename _SIZE_=int>
+extern void deleteOnDevice(TRUSTArray<_TYPE_,_SIZE_>& tab);
+
+template <typename _TYPE_, typename _SIZE_=int>
+extern const _TYPE_* mapToDevice(const TRUSTArray<_TYPE_,_SIZE_>& tab, std::string arrayName="??", const bool enabled=true);
+
+template <typename _TYPE_, typename _SIZE_=int>
+extern _TYPE_* mapToDevice_(TRUSTArray<_TYPE_,_SIZE_>& tab, DataLocation nextLocation, std::string arrayName);
+
+template <typename _TYPE_, typename _SIZE_=int>
+extern _TYPE_* computeOnTheDevice(TRUSTArray<_TYPE_,_SIZE_>& tab, std::string arrayName="??", const bool enabled=true);
+
+template <typename _TYPE_, typename _SIZE_=int>
+extern void copyFromDevice(TRUSTArray<_TYPE_,_SIZE_>& tab, std::string arrayName="??");
+
+template <typename _TYPE_, typename _SIZE_=int>
+extern void copyFromDevice(const TRUSTArray<_TYPE_,_SIZE_>& tab, std::string arrayName="??");
+
+// Partial copies are only used on the 32bits side:
+template <typename _TYPE_>
+extern void copyPartialFromDevice(TRUSTArray<_TYPE_>& tab, int deb, int fin, std::string arrayName="??");
+
+template <typename _TYPE_>
+void copyPartialFromDevice(const TRUSTArray<_TYPE_>& tab, int deb, int fin, std::string arrayName="??")
+{
+  copyPartialFromDevice(const_cast<TRUSTArray<_TYPE_>&>(tab), deb, fin, arrayName);
+}
+
+template <typename _TYPE_>
+extern void copyPartialToDevice(TRUSTArray<_TYPE_>& tab, int deb, int fin, std::string arrayName="??");
+
+template <typename _TYPE_>
+extern void copyPartialToDevice(const TRUSTArray<_TYPE_>& tab, int deb, int fin, std::string arrayName="??");
+
+// ToDo OpenMP implemente methods for pointer (used only for the moment in Schema_Comm_Vecteurs for buffer communication with _TYPE_=char):
+template <typename _TYPE_, typename _SIZE_=int>
+extern _TYPE_* allocateOnDevice(_TYPE_* ptr, _SIZE_ size, std::string arrayName="??");
+
+template <typename _TYPE_, typename _SIZE_=int>
+extern void deleteOnDevice(_TYPE_* ptr, _SIZE_ size);
+
+template <typename _TYPE_, typename _SIZE_=int>
+extern void copyToDevice(_TYPE_* ptr, _SIZE_ size, std::string arrayName="??");
+
+template <typename _TYPE_, typename _SIZE_=int>
+extern void copyFromDevice(_TYPE_* ptr, _SIZE_ size, std::string arrayName="??");
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/DeviceMemory.h b/Utilities/VisItBridge/databases/readers/Lata/DeviceMemory.h
new file mode 100644
index 00000000..5fa1aae1
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/DeviceMemory.h
@@ -0,0 +1,54 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef DeviceMemory_included
+#define DeviceMemory_included
+
+#include <Array_base.h>
+#include <ctime>
+#include <string>
+#include <sstream>
+#include <map>
+#include <unordered_map>
+#include <tuple>
+
+using map_t = std::unordered_map<void*, std::tuple<int, DataLocation>>;
+
+struct DeviceMemory
+{
+public:
+
+  DeviceMemory() = delete;
+
+  static size_t allocatedBytesOnDevice();
+  static size_t deviceMemGetInfo(bool);
+  static map_t& getMemoryMap() { return memory_map_; };
+  static void printMemoryMap();
+  static trustIdType internal_items_size_;
+  static int nb_pas_dt_; // can't reference Schema_temps_base cause Kernel/Utilitaires...
+  static bool warning(trustIdType nb_items);
+
+private:
+  static map_t memory_map_; // Define a map to track memory allocations on device
+  static size_t initial_free_;
+};
+
+#endif
+
+
+
+
+
+
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Double.h b/Utilities/VisItBridge/databases/readers/Lata/Double.h
new file mode 100644
index 00000000..c3ff2ffb
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Double.h
@@ -0,0 +1,129 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef DOUBLE_H
+#define DOUBLE_H
+
+
+#include <blas1.h>
+#include <Objet_U.h>
+#include <cmath>
+
+# ifndef M_E
+#  define M_E                2.7182818284590452354
+# endif
+# ifndef M_LOG2E
+#  define M_LOG2E        1.4426950408889634074
+# endif
+# ifndef M_LOG10E
+#  define M_LOG10E        0.43429448190325182765
+# endif
+# ifndef M_LN2
+#  define M_LN2                0.69314718055994530942
+# endif
+# ifndef M_LN10
+#  define M_LN10        2.30258509299404568402
+# endif
+# ifndef M_PI
+#  define M_PI                3.14159265358979323846
+# endif
+# ifndef M_PI_2
+#  define M_PI_2        1.57079632679489661923
+# endif
+# ifndef M_PI_4
+#  define M_PI_4        0.78539816339744830962
+# endif
+# ifndef M_1_PI
+#  define M_1_PI        0.31830988618379067154
+# endif
+# ifndef M_2_PI
+#  define M_2_PI        0.63661977236758134308
+# endif
+# ifndef M_2_SQRTPI
+#  define M_2_SQRTPI        1.12837916709551257390
+# endif
+# ifndef M_SQRT2
+#  define M_SQRT2        1.41421356237309504880
+# endif
+# ifndef M_SQRT1_2
+#  define M_SQRT1_2        0.70710678118654752440
+# endif
+# ifndef DMAXFLOAT
+#  define DMAXFLOAT        1e+38
+# endif
+# ifndef DMINFLOAT
+#  define DMINFLOAT        1e-30
+# endif
+
+/*! @brief : fonctions utiles sur les double
+ *
+ */
+
+inline double carre(double x) { return x*x; }
+
+inline double* prodvect(const double* a, const double* b, double* resu)
+{
+  resu[0]=a[1]*b[2]-a[2]*b[1];
+  resu[1]=a[2]*b[0]-a[0]*b[2];
+  resu[2]=a[0]*b[1]-a[1]*b[0];
+  return(resu);
+}
+
+inline double determinant(double a[2], double b[2]) { return (a[0]*b[1]-a[1]*b[0]); }
+
+inline double norme(int n, const double* const a)
+{
+  const integer un=1;
+  const integer m=n ;
+  return F77NAME(DNRM2)(&m, a, &un);
+}
+
+inline int est_egal(double x1, double x2, double eps)
+{
+  double somme = std::fabs(x1)+std::fabs(x2);
+  return ( (somme < eps) || (std::fabs(x1-x2) < eps * somme) );
+}
+
+inline int est_egal(double x1, double x2) { return est_egal(x1,x2,Objet_U::precision_geom); }
+
+inline int est_different(double x1, double x2, double eps) { return !est_egal(x1,x2,eps); }
+
+inline int est_different(double x1, double x2) { return !est_egal(x1,x2); }
+
+inline int inf_ou_egal(double x1, double x2, double eps)
+{
+  double somme=std::fabs(x1)+std::fabs(x2);
+  return ( (somme < eps) || (x1 < x2 + eps * somme));
+}
+
+inline int inf_ou_egal(double x1, double x2) { return inf_ou_egal(x1,x2,Objet_U::precision_geom); }
+
+inline int inf_strict(double x1, double x2, double eps)
+{
+  double somme=std::fabs(x1)+std::fabs(x2);
+  return ( (somme > eps) && (x1 < x2 - eps * somme) );
+}
+
+inline int inf_strict(double x1, double x2) { return inf_strict(x1,x2,Objet_U::precision_geom); }
+
+inline int sup_strict(double x1, double x2, double eps) { return !inf_ou_egal(x1,x2,eps); }
+
+inline int sup_strict(double x1, double x2) { return sup_strict(x1,x2,Objet_U::precision_geom); }
+
+inline int sup_ou_egal(double x1, double x2, double eps) { return !inf_strict(x1,x2,eps); }
+
+inline int sup_ou_egal(double x1, double x2) { return sup_ou_egal(x1,x2,Objet_U::precision_geom); }
+
+#endif /* DOUBLE_H */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/EFichier.cpp b/Utilities/VisItBridge/databases/readers/Lata/EFichier.cpp
new file mode 100644
index 00000000..08a5f40f
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/EFichier.cpp
@@ -0,0 +1,39 @@
+/****************************************************************************
+* Copyright (c) 2023, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <EFichier.h>
+
+Implemente_instanciable(EFichier,"EFichier",Entree_Fichier_base);
+
+EFichier::EFichier(const char* name,IOS_OPEN_MODE mode) :Entree_Fichier_base(name,mode)
+{
+  if (Process::me()>1)
+    {
+      Cerr << "Error! You can't use EFichier to open the file " << name << " on several processes! Only on the master process." << finl;
+      Cerr << "May be a LecFicDiffuse is needed ?" << finl;
+      Process::exit();
+    }
+}
+
+Entree& EFichier::readOn(Entree& s)
+{
+  throw;
+}
+
+Sortie& EFichier::printOn(Sortie& s) const
+{
+  throw;
+}
+
diff --git a/Utilities/VisItBridge/databases/readers/Lata/EFichier.h b/Utilities/VisItBridge/databases/readers/Lata/EFichier.h
new file mode 100644
index 00000000..7d52b489
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/EFichier.h
@@ -0,0 +1,35 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef EFichier_included
+#define EFichier_included
+
+
+#include <Entree_Fichier_base.h>
+
+/*! @brief Fichier en lecture Cette classe est a la classe C++ ifstream ce que la classe Entree est a la
+ *
+ *     classe C++ istream. Elle redefinit de facon virtuelle les operateurs de lecture dans un fichier.
+ *
+ */
+
+class EFichier : public Entree_Fichier_base
+{
+  Declare_instanciable(EFichier);
+public:
+  EFichier(const char* name,IOS_OPEN_MODE mode=ios::in);
+};
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Echange_EV_Options.h b/Utilities/VisItBridge/databases/readers/Lata/Echange_EV_Options.h
new file mode 100644
index 00000000..33aa55c7
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Echange_EV_Options.h
@@ -0,0 +1,56 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Echange_EV_Options_included
+#define Echange_EV_Options_included
+
+class Echange_EV_Options
+{
+public:
+  // SYNC is the default: the owner of the shared value sends the value to other processors
+  // SUM: the owner of a shared value receives values from other processors
+  //  that own the same value (either item_commun or in virtual space)
+  //  and computes the sum. The user might want to SYNCHRONIZE afterwards
+  // MAX: same as SUM, but the owner computes the max for all processors that share the data
+  // MAXCOL1: only meaningful for arrays with line_size > 1. For each shared "line"
+  //  of the multidimensionnal array, take the processor for which the first value on the line
+  //  is the highest and copy the whole line to the processor that owns the item.
+  enum Operation { SYNC, SUM, MAX, MINCOL1 };
+  enum Items_Communs { ITEMS_COMMUNS_YES, ITEMS_COMMUNS_NO };
+  enum Items_Virtuels { ITEMS_VIRTUELS_YES, ITEMS_VIRTUELS_NO };
+
+  Echange_EV_Options(Operation op = SYNC,
+                     Items_Communs items_communs = ITEMS_COMMUNS_YES,
+                     Items_Virtuels items_virtuels = ITEMS_VIRTUELS_YES);
+
+  Operation get_op() const { return op_; }
+  Items_Communs get_items_communs() const { return items_communs_; }
+  Items_Virtuels get_items_virtuels() const { return items_virtuels_; }
+
+  int operator==(const Echange_EV_Options& x) const
+  {
+    return op_==x.op_ && items_communs_==x.items_communs_ && items_virtuels_==x.items_virtuels_;
+  }
+protected:
+  Operation op_;
+  // Flag: process items_communs or not ?
+  Items_Communs items_communs_;
+  Items_Virtuels items_virtuels_;
+};
+
+extern const Echange_EV_Options& echange_ev_opt_default;
+
+#endif
+
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Entree.cpp b/Utilities/VisItBridge/databases/readers/Lata/Entree.cpp
new file mode 100644
index 00000000..97ee5def
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Entree.cpp
@@ -0,0 +1,508 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <Entree.h>
+#include <Objet_U.h>
+#include <Nom.h>
+#include <errno.h>
+#include <fstream>
+
+using std::ifstream;
+
+Entree::Entree() : AbstractIO(),
+  check_types_(false),
+  error_action_(ERROR_CONTINUE),
+  diffuse_(true),
+  istream_(nullptr)
+{
+}
+
+Entree::Entree(istream& is) : Entree()
+{
+  istream_ = new istream(is.rdbuf());
+}
+
+Entree::Entree(const Entree& is) : Entree()
+{
+  istream_ = new istream(is.get_istream().rdbuf());
+}
+
+istream& Entree::get_istream()
+{
+  return *istream_;
+}
+
+const istream& Entree::get_istream() const
+{
+  return *istream_;
+}
+void Entree::set_istream(istream* is)
+{
+  istream_ = is;
+}
+
+Entree& Entree::operator >>(Entree& (*f)(Entree&))
+{
+  (*f)(*this);
+  return *this;
+}
+Entree& Entree::operator >>(istream& (*f)(istream&))
+{
+  (*f)(*istream_);
+  return *this;
+}
+Entree& Entree::operator >>(ios& (*f)(ios&))
+{
+  (*f)(*istream_);
+  return *this;
+}
+
+// Operateurs d'affectation
+Entree& Entree::operator=(istream& is)
+{
+  if(istream_)
+    delete istream_;
+  istream_ = new istream(is.rdbuf());
+  return *this;
+}
+
+Entree& Entree::operator=(Entree& is)
+{
+  if(istream_)
+    delete istream_;
+  istream_ = new istream(is.get_istream().rdbuf());
+  return *this;
+}
+
+/*! @brief Lecture d'une chaine dans ostream_ bufsize est la taille du buffer alloue pour ob (y compris
+ *
+ *   le caractere 0 final).
+ *   La chaine contient toujours un 0 meme en cas d'echec.
+ *   La methode renvoie 1 si la lecture est bonne, 0 sinon.
+ *   Si le buffer est trop petit, pour l'instant on fait exit() mais
+ *   par la suite on pourra tester: si strlen(ob)==bufsize-1, alors
+ *   refaire lire() jusqu'a arriver au bout. Si le lire() suivant
+ *   renvoie une chaine de longueur nulle, cela signifie que la taille de la
+ *   chaine etait exactement bufsize-1.
+ *   Attention: le comportement est different en binaire et en ascii.
+ *    En binaire, on lit la chaine jusqu'au prochain '\0'.
+ *    En ascii, on lit la chaine jusqu'au prochain separateur (espace, tab, fin ligne)
+ *
+ */
+int Entree::get(char* ob, std::streamsize bufsize)
+{
+  assert(istream_!=0);
+  assert(bufsize > 0);
+  ob[bufsize-1] = 1;
+  if(bin_)
+    {
+      // En binaire, on lit jusqu'au prochain caractere 0
+      // (y compris espaces, retours a la ligne etc)
+      std::streamsize i;
+      for (i = 0; i < bufsize-1; i++)
+        {
+          (*istream_).read(ob+i, sizeof(char));
+          if (!error_handle(istream_->fail()))
+            ob[i] = 0;
+          if (ob[i] == 0)
+            break;
+        }
+      ob[i] = 0;
+    }
+  else
+    {
+      // L'appel suivant permet a l'operateur>> de limiter le nombre
+      // de caracteres lus. On lira au maximum bufsize-1 caracteres.
+      istream_->width(bufsize);
+      (*istream_) >> ob;
+      if (!error_handle(istream_->fail()))
+        ob[0] = 0;
+    }
+  if (ob[bufsize-1] == 0)
+    {
+      // Note Benoit Mathieu:
+      // Si on a rempli le buffer jusqu'au bout, c'est qu'il est probablement
+      // trop petit. Lire la suite est dangereux car en ascii on ne sait pas
+      // si on a pu lire pile poil la chaine (donc c'est ok), ou si la chaine
+      // n'a pas ete lue en int. Il faut tester tres serieusement la stl et
+      // ca depend sans doute de l'implementation. Donc, si le buffer est plein,
+      // on plante le code et tant pis.
+      Cerr << "Error in Entree::lire(char* ob, int bufsize) : buffer too small" << finl;
+      Process::exit();
+    }
+  return (!istream_->fail());
+}
+
+void error_convert(const char * s, const char * type)
+{
+  Cerr << "Error converting a string to type " <<  type << " : string = " << s << finl;
+  Process::exit();
+}
+
+/*! @brief methode de conversion
+ *
+ */
+void convert_to(const char *s, True_int& ob)
+{
+  errno = 0;
+  char * errorptr = 0;
+  ob = (True_int)strtol(s, &errorptr, 0 /* base 10 par defaut */);
+  if (errno || *errorptr != 0) error_convert(s,"int");
+}
+
+void convert_to(const char *s, long& ob)
+{
+  errno = 0;
+  char * errorptr = 0;
+  ob = strtol(s, &errorptr, 0 /* base 10 par defaut */);
+  if (errno || *errorptr != 0)  error_convert(s,"long");
+}
+
+void convert_to(const char *s, long long& ob)
+{
+  errno = 0;
+  char * errorptr = 0;
+#ifdef HPPA_11 /* NO_PROCESS */
+  ob = strtol(s, &errorptr, 0 /* base 10 par defaut */);
+#else /* NO_PROCESS */
+#ifdef MICROSOFT
+  ob = _strtoi64(s, &errorptr, 0 /* base 10 par defaut */);
+#else
+  ob = strtoll(s, &errorptr, 0 /* base 10 par defaut */);
+#endif
+#endif /* NO_PROCESS */
+  if (errno || *errorptr != 0)  error_convert(s,"long long");
+}
+
+void convert_to(const char *s, float& ob)
+{
+  errno = 0;
+  char * errorptr = 0;
+  ob = strtof(s, &errorptr);
+  if (errno || *errorptr != 0)  error_convert(s,"float");
+}
+
+void convert_to(const char *s, double& ob)
+{
+  errno = 0;
+  char * errorptr = 0;
+  ob = strtod(s, &errorptr);
+  if (errno || *errorptr != 0)  error_convert(s,"double");
+}
+
+// methode virtuelle pour lire un int ou un reel. Dans cette classe de base, on lit dans le istream avec read() (si is_bin() == 1)
+//   ou avec operator>>() (si is_bin() == 0). Si le drapeau check_types est mis, on appelle convert_to() pour verifier les types des objets lus.
+//   Dans ce cas, pour les ints on comprend les formats 123 (decimal), 0xa345 (hexa) et autres.
+//  Si une erreur se produit, on appelle error_handle_()
+//  Note pour les programmeurs des classes derivees:  L'implementation de cette methode doit toujours passer par hande_error()
+Entree& Entree::operator>>(double& ob) { return operator_template<double>(ob); }
+
+// methode virtuelle pour lire un tableau d'ints ou reels (le tableau doit avoir la bonne dimension: attention pas de verification possible)
+int Entree::get(double * ob, std::streamsize n) { return get_template<double>(ob,n); }
+
+Entree& Entree::operator>>(True_int& ob) { return operator_template<True_int>(ob); }
+int Entree::get(True_int * ob, std::streamsize n) { return get_template<True_int>(ob,n); }
+
+Entree& Entree::operator>>(float& ob) { return operator_template<float>(ob); }
+int Entree::get(float * ob, std::streamsize n) { return get_template<float>(ob,n); }
+
+Entree& Entree::operator>>(long& ob) { return operator_template<long>(ob); }
+int Entree::get(long * ob, std::streamsize n) { return get_template<long>(ob,n); }
+
+Entree& Entree::operator>>(long long& ob) { return operator_template<long long>(ob); }
+int Entree::get(long long * ob, std::streamsize n) { return get_template<long long>(ob,n); }
+
+Entree& Entree::operator >>(Objet_U& ob) { return ob.readOn(*this); }
+
+int Entree::jumpOfLines()
+{
+  if(istream_)
+    {
+      int jol = 0;
+      char tmp=(char)istream_->peek();
+      while(isspace(tmp))  //tmp=='\n')
+        {
+          if(tmp=='\n')
+            jol++;
+          istream_->get(tmp);
+          tmp=(char)istream_->peek();
+        }
+      return jol;
+    }
+  return -1;
+}
+
+int Entree::eof()
+{
+  if(istream_)
+    return (istream_->eof());
+  else
+    return -1;
+}
+int Entree::fail()
+{
+  if(istream_)
+    return (istream_->fail());
+  else
+    return -1;
+}
+int Entree::good()
+{
+  if(istream_)
+    return (istream_->good());
+  else
+    return -1;
+}
+Entree::~Entree()
+{
+#ifndef TRUST_USE_UVM // ToDo bug ?
+  if(istream_)
+    delete istream_;
+#endif
+  istream_=nullptr;
+}
+
+/*! @brief Change le mode d'ecriture du fichier.
+ *
+ * Cette methode peut etre appelee n'importe quand.
+ *
+ */
+void Entree::set_bin(bool bin)
+{
+  bin_ = bin;
+  if (istream_)
+    {
+      Cerr<<"Error you cant change binary format after open "<<finl;
+      assert(0);
+      Process::exit();
+    }
+}
+
+/*! @brief indique si le stream doit verifier les types des objets lus (ints et nombres flottants).
+ *
+ * Exemple : l'entree contient 123.456 123.456
+ *   int i;
+ *   check_types(0);
+ *   is >> i;   // i contient 123
+ *   check_types(1);
+ *   is >> i;   // Erreur : on lit la chaine 123.456 et on essaye de la convertir en int
+ *   Voir operator>>(int &)
+ *
+ */
+void Entree::set_check_types(bool flag)
+{
+  check_types_ = flag;
+}
+
+
+/*! @brief Cette fonction est appellee par operateur>>, get, get_nom ouvrir, fermer, lire, etc.
+ *
+ * .. en cas d'echec (lorsque fail() est mis)
+ *   Elle renvoie 0 s'il y a eu une erreur (passer par error_handle() qui
+ *   traite en inline le cas ou il n'y a pas d'erreur), et 1 s'il n'y a pas
+ *   d'erreur.
+ *   (par commodite de codage des methodes qui l'utilisent, on
+ *    ecrira "return error_handle(fail());"
+ *   Elle peut etre configuree pour
+ *    - renvoyer "0" en cas d'erreur et continuer l'execution du code
+ *      (cas d'un ancien code qui ne gere pas les exceptions mais teste
+ *       le drapeau fail() de temps en temps)
+ *      Dans ce cas les methodes operator>> continuent l'execution du code
+ *      meme en cas d'echec, le contenu des variables lues est indefini !
+ *    - faire Process::exit() (cas d'une portion de code dans laquelle
+ *      on ne veut pas faire de gestion d'erreur du tout et ou on suppose
+ *      que tout va toujours bien)
+ *    - lever une exception (permet une gestion rigoureuse des erreurs
+ *      et une information utilisateur optimale en fonction du contexte)
+ *
+ *   @sa set_error_action()
+ *
+ */
+int Entree::error_handle_(int fail_flag)
+{
+  if (!fail_flag)
+    return 1;
+
+  switch(error_action_)
+    {
+    case ERROR_CONTINUE:
+      break;
+    case ERROR_EXIT:
+      Cerr << "Error while reading in Entree object. Exiting.\n";
+      if (istream_)
+        {
+          // On n'utilise pas Entree::eof() car dans le cas d'un Lec_Fic_Dif
+          // eof() est parallele et ca peut bloquer.
+          if (get_istream().eof())
+            Cerr << " End of file reached." << finl;
+          else
+            Cerr << " IO error (not an EOF error)." << finl;
+        }
+      Process::exit();
+      break;
+    case ERROR_EXCEPTION:
+      Entree_Sortie_Error e;
+      throw (e);
+    }
+  return 0;
+}
+
+/*! @brief renvoie error_action_ pour cette entree (permet de la modifier et de restaurer ensuite la valeur anterieure)
+ *
+ */
+Entree::Error_Action Entree::get_error_action()
+{
+  return error_action_;
+}
+
+/*! @brief Change le comportement en cas d'erreur de l'entree, voir error_handle_() et get_error_action()
+ *
+ */
+void Entree::set_error_action(Entree::Error_Action action)
+{
+  error_action_ = action;
+}
+
+// Detection sur un fichier de nom filename
+// est de type binaire
+int is_a_binary_file(Nom& filename)
+{
+  // On parcourt les 1000 premiers octets
+  // Detection tres imparfaite donc limite
+  // aux fichiers geom de TRUST
+  int n=0;
+  int c;
+  std::ifstream fic(filename.getChar());
+  // Si on rencontre un caractere ASCII>127
+  // alors le fichier est de type binaire
+  while((c = fic.get()) != EOF && n++<1000)
+    if ((c>127)||(c<9))
+      return 1;
+  // GF sous windows les caracteres binaire sont surtout <9
+  //  else printf("ici %d %c \n",c,c);
+  return 0;
+}
+
+/*! @brief ToDo TMA : commenter
+ *
+ */
+void Entree::set_diffuse(bool diffuse)
+{
+  // virtual method does nothing ; cf override in Lec_Diffuse_base
+  diffuse_ = true;
+}
+
+
+template<typename _TYPE_>
+int Entree::get_template(_TYPE_ *ob, std::streamsize n)
+{
+  assert(istream_!=0);
+  assert(n >= 0);
+  if (bin_)
+    {
+      if (this->must_convert<_TYPE_>())
+        {
+          // Need to cast, use '>>' operator - see doc in operator_template<>
+          for (int i = 0; i < n; i++) (*this) >> ob[i];
+        }
+      else
+        {
+          // In binary, optimized block reading:
+          char *ptr = (char*) ob;
+          std::streamsize sz = sizeof(_TYPE_);
+          sz *= n;
+          istream_->read(ptr, sz);
+          error_handle(istream_->fail());
+        }
+    }
+  else
+    {
+      // En ascii : on passe par operator>> pour verifier les conversions
+      // Attention : on appelle celui de cette classe, pas de la classe derivee
+      for (int i = 0; i < n; i++) Entree::operator>>(ob[i]);
+    }
+  return (!istream_->fail());
+}
+
+// Explicit instanciations:
+template int Entree::get_template(True_int *ob, std::streamsize n);
+template int Entree::get_template(long *ob, std::streamsize n);
+template int Entree::get_template(long long *ob, std::streamsize n);
+template int Entree::get_template(double *ob, std::streamsize n);
+template int Entree::get_template(float *ob, std::streamsize n);
+
+
+template <typename _TYPE_>
+Entree& Entree::operator_template(_TYPE_& ob)
+{
+  assert(istream_!=0);
+  if (bin_)
+    {
+      // Do we need to worry about 32b / 64b conversion?
+      if (this->must_convert<_TYPE_>())
+        {
+          // Yes, then two cases:
+          // Case 1: requested _TYPE_ is 32b and file is 64b -> only OK if read value is actually within the 32b range
+          if (is_64b_)
+            {
+              std::int64_t pr;
+              char *ptr = (char*) &pr;
+              istream_->read(ptr, sizeof(std::int64_t));
+              if (pr > std::numeric_limits<int>::max())
+                Process::exit("Can't read this int64 binary file with an int32 binary: values too big, overflow!!");
+              // It's ok, we passed the check above, we can safely downcast:
+              ob = static_cast<_TYPE_>(pr);
+            }
+          // Case 2: requested _TYPE_ is 64b and file is 32b -> this is always OK, just need True_int to make sure we really read a 32b value
+          else
+            {
+              True_int pr;
+              char * ptr = (char*) &pr;
+              istream_->read(ptr, sizeof(True_int));
+              ob=(_TYPE_)pr;
+            }
+        }
+      else  // File has the same bit-ness as binary, or we are trying to read a non-problematic type - all OK.
+        {
+          char *ptr = (char*) &ob;
+          istream_->read(ptr, sizeof(_TYPE_));
+          error_handle(istream_->fail());
+        }
+    }
+  else  // Not binary, ascii format
+    {
+      if (check_types_)
+        {
+          char buffer[100];
+          int ok = Entree::get(buffer, 100); // Bien appeler get de cette classe
+          if (ok)
+            convert_to(buffer, ob);
+        }
+      else
+        {
+          (*istream_) >> ob;
+          error_handle(istream_->fail());
+        }
+    }
+  return *this;
+}
+
+// Explicit instanciations:
+template Entree& Entree::operator_template(True_int& ob);
+template Entree& Entree::operator_template(long& ob);
+template Entree& Entree::operator_template(long long& ob);
+template Entree& Entree::operator_template(double& ob);
+template Entree& Entree::operator_template(float& ob);
+
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Entree.h b/Utilities/VisItBridge/databases/readers/Lata/Entree.h
new file mode 100644
index 00000000..835504b1
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Entree.h
@@ -0,0 +1,138 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Entree_included
+#define Entree_included
+
+#include <Process.h>
+#include <AbstractIO.h>
+#include <iostream>
+#include <assert.h>
+#include <stdio.h>
+#include <cstdio> // Pour EOF sur GNU >= 4.4
+#include <arch.h> // pour LIBLATAFILTER int64
+#include <cstdint>// Pour INT32_MAX sur GNU >= 13
+
+using std::istream;
+using std::ios;
+
+template <typename T> class TRUST_Ref;
+class TRUST_Ref_Objet_U;
+class Objet_U;
+class Nom;
+
+/*! @brief Class defining operators and methods for all reading operation in an input flow (file, keyboard
+ * communication buffer, etc.)
+ *
+ * @sa Sortie
+ */
+class Entree: public AbstractIO
+{
+public:
+  // Constructeurs
+  Entree();
+  Entree(istream& is);
+  Entree(const Entree& is);
+  virtual ~Entree();
+
+  void set_bin(bool bin) override;
+
+  // Operateurs d'affectation
+  Entree& operator=(istream& is);
+  Entree& operator=(Entree& is);
+
+  virtual istream& get_istream();
+  virtual const istream& get_istream() const;
+  void set_istream(istream *is);
+
+  Entree& operator >>(Entree& (*f)(Entree&));
+  Entree& operator >>(istream& (*f)(istream&));
+  Entree& operator >>(ios& (*f)(ios&));
+
+  template <typename T>
+  Entree& operator>>(const TRUST_Ref<T>& ) { std::cerr << __func__ << " :: SHOULD NOT BE CALLED ! Use -> !! " << std::endl ; throw; }
+
+  Entree& operator>>(const TRUST_Ref_Objet_U& ) { std::cerr << __func__ << " :: SHOULD NOT BE CALLED ! Use -> !! " << std::endl ; throw; }
+
+  virtual Entree& operator>>(True_int& ob);
+  virtual Entree& operator>>(long& ob);
+  virtual Entree& operator>>(long long& ob);
+  virtual Entree& operator>>(float& ob);
+  virtual Entree& operator>>(double& ob);
+
+  // final
+  virtual Entree& operator>>(Objet_U& ob) final;
+
+  virtual int get(True_int *ob, std::streamsize n);
+  virtual int get(long *ob, std::streamsize n);
+  virtual int get(long long *ob, std::streamsize n);
+  virtual int get(float *ob, std::streamsize n);
+  virtual int get(double *ob, std::streamsize n);
+
+  virtual int get(char *buf, std::streamsize bufsize);
+
+  virtual int eof();
+  virtual int jumpOfLines();
+  virtual int fail();
+  virtual int good();
+  virtual void set_check_types(bool flag);
+  bool check_types() const { return check_types_; }
+  enum Error_Action { ERROR_EXIT, ERROR_CONTINUE, ERROR_EXCEPTION };
+  virtual void set_error_action(Error_Action);
+  Error_Action get_error_action();
+
+  inline operator istream& () { return get_istream(); }
+  inline istream& putback(char ch) { return get_istream().putback(ch); }
+  inline bool get_diffuse() { return diffuse_; }
+
+  virtual void set_diffuse(bool diffuse);
+
+protected:
+  // methode inline pour traiter rapidement le cas trivial. Sinon, appel a la methode virtuelle error_handle_()
+  inline int error_handle(int fail_flag)
+  {
+    if (!fail_flag) return 1;
+    else return error_handle_(fail_flag);
+  }
+
+  virtual int error_handle_(int fail_flag);
+  bool check_types_;
+  Error_Action error_action_;
+  bool diffuse_; // By default true, but some child classes (eg: LecFicDiffuse) could set temporary to false to not diffuse to other processes
+
+private:
+  istream *istream_;
+
+  template <typename _TYPE_>
+  int get_template(_TYPE_ *ob, std::streamsize n);
+
+  template <typename _TYPE_>
+  Entree& operator_template(_TYPE_& ob);
+};
+
+int is_a_binary_file(Nom&);
+
+void convert_to(const char *s, True_int& ob);
+void convert_to(const char *s, long& ob);
+void convert_to(const char *s, long long& ob);
+void convert_to(const char *s, float& ob);
+void convert_to(const char *s, double& ob);
+
+// Classe renvoyee par Entree si une exception est levee lors d'une erreur
+class Entree_Sortie_Error
+{
+};
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Entree_Fichier_base.cpp b/Utilities/VisItBridge/databases/readers/Lata/Entree_Fichier_base.cpp
new file mode 100644
index 00000000..aad64cd6
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Entree_Fichier_base.cpp
@@ -0,0 +1,155 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <Entree_Fichier_base.h>
+#include <Process.h>
+#include <Nom.h>
+
+#ifndef LATATOOLS
+#include <EntreeSortie.h>
+#endif
+
+Implemente_base_sans_constructeur_ni_destructeur(Entree_Fichier_base,"Entree_Fichier_base",Objet_U);
+
+Entree& Entree_Fichier_base::readOn(Entree& s)
+{
+  throw;
+}
+
+Sortie& Entree_Fichier_base::printOn(Sortie& s) const
+{
+  throw;
+}
+Entree_Fichier_base::Entree_Fichier_base()
+{
+  ifstream_=0;
+}
+
+Entree_Fichier_base::Entree_Fichier_base(const char* name,IOS_OPEN_MODE mode)
+{
+  ifstream_ = new ifstream(name, mode);
+  if(ifstream_->fail())
+    {
+      Cerr << "Error while opening the file " << name << finl;
+      Process::exit();
+    }
+  set_istream(ifstream_);
+}
+
+ifstream& Entree_Fichier_base::get_ifstream()
+{
+  return *ifstream_;
+}
+
+Entree_Fichier_base::~Entree_Fichier_base()
+{
+  Entree_Fichier_base::close();
+}
+
+int Entree_Fichier_base::ouvrir(const char* name, IOS_OPEN_MODE mode)
+{
+  if(ifstream_)
+    delete ifstream_;
+  IOS_OPEN_MODE ios_mod=mode;
+  if (bin_)
+    {
+      ios_mod=ios_mod|ios::binary;
+    }
+  ifstream_ = new ifstream(name,ios_mod);
+  int ok = ifstream_->good();
+  set_istream(ifstream_);
+
+  if (bin_)
+    {
+      Nom test;
+      (*this) >> test;
+      if (test == "INT64")
+        {
+          is_64b_ = true;
+#ifndef INT_is_64_
+          Cerr<<"Opening " <<name<< " which is an int64 binary file..."<<finl;
+#endif
+        }
+      else
+        {
+          is_64b_ = false;
+#ifdef INT_is_64_
+          Cerr<<"Opening " <<name<< " which is an int32 binary file..."<<finl;
+#endif
+          // rewind, to go back at begining of file:
+          delete ifstream_;
+          ifstream_ = new ifstream(name,ios_mod);
+          ok = ifstream_->good();
+          set_istream(ifstream_);
+        }
+    }
+  return ok;
+}
+
+void Entree_Fichier_base::close()
+{
+  if(ifstream_)
+    {
+      ifstream_->close();
+      // on ne detruit pas ifstream ca sera fait par entree
+      //      delete ifstream_;
+    }
+}
+
+int Entree_Fichier_base::eof()
+{
+  if(ifstream_)
+    return ifstream_->eof();
+  else
+    return -1;
+}
+
+int Entree_Fichier_base::fail()
+{
+  if(ifstream_)
+    return ifstream_->fail();
+  else
+    return -1;
+}
+
+int Entree_Fichier_base::good()
+{
+  if(ifstream_)
+    return ifstream_->good();
+  else
+    return -1;
+}
+
+void Entree_Fichier_base::precision(int pre)
+{
+  if(ifstream_)
+    ifstream_->precision(pre);
+}
+
+void Entree_Fichier_base::setf(IOS_FORMAT code)
+{
+  if(ifstream_)
+    ifstream_->setf(code);
+}
+
+/*! @brief Return True if the file can be opened for reading, false otherwise.
+ *
+ */
+bool Entree_Fichier_base::Can_be_read(const char * name)
+{
+  std::ifstream ifs(name,ios::in);
+  return ifs.good();
+}
+
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Entree_Fichier_base.h b/Utilities/VisItBridge/databases/readers/Lata/Entree_Fichier_base.h
new file mode 100644
index 00000000..1bc25a49
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Entree_Fichier_base.h
@@ -0,0 +1,59 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Entree_Fichier_base_included
+#define Entree_Fichier_base_included
+
+
+#include <Entree.h>
+#include <Objet_U.h>
+#include <fstream>
+using std::ifstream;
+using std::ofstream;
+using std::streampos;
+
+/*! @brief Fichier en lecture Cette classe est a la classe C++ ifstream ce que la classe Entree est a la
+ *
+ *     classe C++ istream. Elle redefinit de facon virtuelle les operateurs de lecture dans un fichier.
+ *
+ */
+
+class Entree_Fichier_base : public Entree, public Objet_U
+{
+  Declare_base_sans_constructeur(Entree_Fichier_base);
+public:
+  Entree_Fichier_base();
+  Entree_Fichier_base(const Entree_Fichier_base&) = default;
+  Entree_Fichier_base(const char* name,IOS_OPEN_MODE mode=ios::in);
+  ifstream& get_ifstream();
+  void close();
+  int eof() override;
+  int fail() override;
+  int good() override;
+  void precision(int pre);
+  void setf(IOS_FORMAT code);
+
+  virtual int ouvrir(const char* name, IOS_OPEN_MODE mode=ios::in);
+
+  static bool Can_be_read(const char * name);
+
+protected:
+  ifstream* ifstream_;
+
+private:
+  Entree_Fichier_base& operator=(const Entree_Fichier_base&);  // copy is forbidden
+};
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Esp_Dist.h b/Utilities/VisItBridge/databases/readers/Lata/Esp_Dist.h
new file mode 100644
index 00000000..dc4ccb85
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Esp_Dist.h
@@ -0,0 +1,41 @@
+/****************************************************************************
+* Copyright (c) 2023, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Esp_Dist_included
+#define Esp_Dist_included
+
+#include <TRUST_Vector.h>
+#include <Descripteur.h>
+#include <TRUSTArray.h>
+#include <assert.h>
+
+/*! @brief Espace distant utilise pour la gestion des tableaux distribues Cette classe permet de decrire un espace distant d'un vecteur de donnees.
+ *
+ *     Elle porte un int representant le numero de processeur a qui est destine le domaine decrite.
+ *     La description de cet espace distant consiste en un vecteur d'entiers contenant les indices des elements a envoyer.
+ *
+ */
+class Esp_Dist : public TRUSTArray<int>
+{
+  Declare_instanciable_sans_constructeur(Esp_Dist);
+public:
+  Esp_Dist();
+
+private:
+  int PE_voisin_;
+  VECT(Descripteur) desc_ed_;
+};
+
+#endif /* Esp_Dist_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Esp_Virt.h b/Utilities/VisItBridge/databases/readers/Lata/Esp_Virt.h
new file mode 100644
index 00000000..acf36448
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Esp_Virt.h
@@ -0,0 +1,36 @@
+/****************************************************************************
+* Copyright (c) 2023, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Esp_Virt_included
+#define Esp_Virt_included
+
+#include <TRUST_Vector.h>
+#include <Descripteur.h>
+
+/*! @brief Espace virtuel utilise dans la gestion des tableaux distribues.
+ *
+ */
+
+class Esp_Virt : public Objet_U
+{
+  Declare_instanciable_sans_constructeur(Esp_Virt);
+public:
+  Esp_Virt();
+
+private:
+  int PE_voisin_;        // Numero du PE possedant la partie reelle
+  VECT(Descripteur) desc_ev_;
+};
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/LataDB.cpp b/Utilities/VisItBridge/databases/readers/Lata/LataDB.cpp
new file mode 100644
index 00000000..cf98ee84
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/LataDB.cpp
@@ -0,0 +1,2702 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <errno.h>
+#include <LataDB.h>
+#include <stdio.h>
+#include <EFichier.h>
+#include <LataV1_field_definitions.h>
+#include <iostream>
+#include <fstream>
+#include <string.h>
+#include <stdlib.h>
+
+#include <LataDBmed.h>
+#include <LataDBFORT21.h>
+
+// Verbose level for which main lata file interpretation should be printed:
+//  Dump one line for the whole file at verb_level-1
+//  Dump one line for each Geometry, Temps, or Champ at verb_level
+//  Detailed Geometry and Champ metadata is printed out at verb_level+1
+#define verb_level 4
+// Verbose level for data bloc reading:
+//  Dump one line for each read data bloc at this level
+//  Dump detailed subbloc interpretation at level+1
+#define verb_level_data_bloc 5
+
+typedef std::int32_t LataDBInt32;
+typedef std::int64_t LataDBInt64;
+
+void arch_check()
+{
+  if (sizeof(LataDBInt32)!=4)
+    Journal() << "Error in LataDB arch_check : wrong LataDBInt32" << endl;
+  if (sizeof(LataDBInt64)!=8)
+    Journal() << "Error in LataDB arch_check : wrong LataDBInt64" << endl;
+}
+
+const char * LataDBField::memory_buffer_file()
+{
+  return "MEMORY_BUFFERED_DATA";
+}
+
+Field_UName::Field_UName()
+{
+}
+
+Field_UName::Field_UName(const Field_UName& f) :
+  geometry_(f.geometry_), field_name_(f.field_name_), loc_(f.loc_)
+{
+}
+
+Field_UName::Field_UName(const char *domain_name, const char *field_name, const char *loc) :
+  geometry_(domain_name), field_name_(field_name), loc_(loc)
+{
+  if (loc_ == "??")
+    loc_ = "";
+}
+
+Field_UName& Field_UName::operator=(const Field_UName& f)
+{
+  geometry_ = f.geometry_;
+  field_name_ = f.field_name_;
+  loc_ = f.loc_;
+  return *this;
+}
+
+Nom Field_UName::build_string() const
+{
+  Nom n(geometry_);
+  n += "_";
+  n += field_name_;
+  if (loc_ != "" && loc_ != "??")
+    {
+      n += "_";
+      n += loc_;
+    }
+  return n;
+}
+
+void Field_UName::set_field_name(const Nom& n)
+{
+  field_name_ = n;
+}
+
+int Field_UName::operator==(const Field_UName& f) const
+{
+  return (geometry_ == f.geometry_) && (field_name_ == f.field_name_) && (loc_ == f.loc_);
+}
+
+std::ostream& operator<<(std::ostream& os, const Field_UName& uname)
+{
+  os << uname.build_string();
+  return os;
+}
+
+// This is a duplicate of Domain... only used for old latav1 compatibility
+// (otherwise, LataDB should not have to know about element types !)
+LataDB::Element LataDB::element_type_from_string(const Motcle& type_elem)
+{
+  Element type;
+  if (type_elem == "HEXAEDRE")
+    type=hexa;
+  else if (type_elem == "HEXAEDRE_AXI")
+    type=hexa;
+  else if (type_elem == "HEXAEDRE_VEF")
+    type=hexa;
+  else if (type_elem == "QUADRANGLE")
+    type=quadri;
+  else if (type_elem == "QUADRANGLE_3D")
+    type=quadri;
+  else if (type_elem == "RECTANGLE")
+    type=quadri;
+  else if (type_elem == "RECTANGLE_2D_AXI")
+    type=quadri;
+  else if (type_elem == "RECTANGLE_AXI")
+    type=quadri;
+  else if (type_elem == "SEGMENT")
+    type=line;
+  else if (type_elem == "SEGMENT_2D")
+    type=line;
+  else if (type_elem == "TETRAEDRE")
+    type=tetra;
+  else if (type_elem == "TRIANGLE")
+    type=triangle;
+  else if (type_elem == "TRIANGLE_3D")
+    type=triangle;
+  else if (type_elem.debute_par("POLYEDRE"))
+    type=polyedre;
+  else if (type_elem.debute_par("POLYGONE"))
+    type=polygone;
+  else
+    {
+      Journal() << "Error in elem_type_from_string: unknown element type " << type_elem << endl;
+      throw(LataDBError(LataDBError::BAD_ELEM_TYPE));
+    }
+  return type;
+}
+
+void LataDB::get_element_data(const Motcle& elemtype, int& dimension, int& elem_shape, int& face_shape, int& nb_elem_faces)
+{
+  Element elem = element_type_from_string(elemtype);
+  switch(elem)
+    {
+    case line:
+      dimension = 2;
+      elem_shape=2;
+      face_shape=1;
+      nb_elem_faces=2;
+      break;
+    case triangle:
+      dimension = (elemtype=="TRIANGLE") ? 2 : 3;
+      elem_shape=3;
+      face_shape=2;
+      nb_elem_faces=3;
+      break;
+    case quadri:
+      dimension = (elemtype=="QUADRANGLE_3D") ? 3 : 2;
+      elem_shape=4;
+      face_shape=2;
+      nb_elem_faces=4;
+      break;
+    case tetra:
+      dimension = 3;
+      elem_shape=4;
+      face_shape=3;
+      nb_elem_faces=4;
+      break;
+    case hexa:
+      dimension = 3;
+      elem_shape=8;
+      face_shape=4;
+      nb_elem_faces=6;
+      break;
+    case polyedre:
+      dimension = 3;
+      elem_shape=-1;
+      face_shape=-1;
+      nb_elem_faces=-1;
+      break;
+    case polygone:
+      dimension = 2;
+      elem_shape=-1;
+      face_shape=-1;
+      nb_elem_faces=-1;
+      break;
+    default:
+      Journal() << "LataDB::get_element_data element is unspecified" << endl;
+      throw(LataDBError(LataDBError::BAD_ELEM_TYPE));
+    }
+}
+
+// Description: in lata v1 format, the number of components in a Champ entry
+//  is implicitely defined by the field name and the discretisation
+int LataDB::lata_v1_get_nb_comp(const Nom& fieldname, const Motcle& localisation,
+                                   const LataDBGeometry& dom, int dim, LataDBField::Nature& nature,
+                                   LataDBDataType::DataOrdering& ordering)
+{
+  // Search component name in std_components
+  int nb_comp = latav1_component_shape(fieldname);
+  //Motcle maj_field(fieldname);
+  ordering = LataDBDataType::C_ORDERING;
+  nature = LataDBField::SCALAR;
+  Journal(verb_level+1) << " LataV2 known component name found : " << fieldname << endl;
+  if (nb_comp == -1)
+    {
+      // This is a vector component. If it's not a VDF faces, nb_comp = dimension of the problem
+      Element elt = element_type_from_string(dom.elem_type_);
+      if (localisation == "FACES" && (elt == quadri || elt == hexa))
+        {
+          nb_comp = 1;
+          Journal(verb_level+1) << " Vector field. Detected a VDF faces discretisation => nb_comp=1" << endl;
+        }
+      else
+        {
+          nb_comp = dim;
+          nature = LataDBField::VECTOR;
+          ordering = LataDBDataType::F_ORDERING;
+          Journal(verb_level+1) << " Vector field. nb_comp = dimension = " << nb_comp << endl;
+          Journal(verb_level+1) << " Assume fortran ordering" << endl;
+        }
+    }
+  else if (nb_comp == -2)
+    {
+      // This is the vorticity: scalar in 2D, vector in 3D
+      if (dim == 2)
+        {
+          nb_comp = 1;
+          Journal(verb_level+1) << " Scalar field, nb_comp=" << nb_comp << endl;
+        }
+      else
+        {
+          nb_comp = dim;
+          nature = LataDBField::VECTOR;
+          ordering = LataDBDataType::F_ORDERING;
+          Journal(verb_level+1) << " Vector field. nb_comp = dimension = " << nb_comp << endl;
+          Journal(verb_level+1) << " Assume fortran ordering" << endl;
+        }
+    }
+  else
+    {
+      //if (maj_field == "K_EPS") {
+      if (nb_comp>1)
+        {
+          ordering = LataDBDataType::F_ORDERING;
+          Journal(verb_level+1) << " Special K_EPS => Assume fortran ordering" << endl;
+        }
+      Journal(verb_level+1) << " Scalar field, nb_comp=" << nb_comp << endl;
+    }
+  return nb_comp;
+}
+
+// Description: in lata v1 format, the localisation is implicitely defined by the
+//  file name of the data file:
+void lata_v1_get_localisation(const char * filename, Nom& localisation_)
+{
+  if (strstr(filename, ".SOM."))
+    localisation_ = "SOM";
+  else if (strstr(filename, ".ELEM."))
+    localisation_ = "ELEM";
+  else if (strstr(filename, ".FACES."))
+    localisation_ = "FACES";
+  else
+    {
+      Journal() << "Error in lata_v1_get_localisation. Unable to find localisation in filename\n"
+                << filename << endl;
+      throw(LataDBError(LataDBError::READ_ERROR));
+    }
+}
+
+class LataDataFile
+{
+public:
+  enum Mode { READ, WRITE, APPEND };
+  LataDataFile(std::iostream& mem_buffer, const char *prefix, const char *name, const LataDBDataType::MSB& msb, Mode mode=READ)
+  {
+    exception_ = true;
+    msb_=msb;
+    if (strcmp(name, LataDBField::memory_buffer_file()) == 0)
+      {
+        stream_ = &mem_buffer;
+        fname_ = name;
+        Journal(verb_level_data_bloc) << "LataDB: opening internal memory_buffer for read/write" << endl;
+        if (mode == READ)
+          (*stream_).seekg(0, std::ios::beg);
+        else if (mode == WRITE)
+          {
+            // on ne repositionne pas sur un fichier vide, Visual ne supporte pas
+            // et c'est inutil
+            if ((*stream_).tellp()>=0)
+              (*stream_).seekp(0, std::ios::beg);
+          }
+        else
+          {
+            if ((*stream_).tellp()>=0)
+              (*stream_).seekp(0, std::ios::end);
+          }
+        Journal(verb_level_data_bloc+1) << " current position: " << position() << endl;
+        if (!fstream_.good())
+          {
+            Journal() << "LataDataFile: Memory stream error" << endl;
+            throw LataDBError(LataDBError::DATA_ERROR);
+          }
+      }
+    else
+      {
+        if ( !name || name[0]=='\0' || strcmp(name, "??")==0 )
+        {
+          Journal(verb_level_data_bloc) << "[ERROR] LataDataFile: empty data file name" << endl;
+          throw(LataDBError(LataDBError::READ_ERROR));
+        }
+        stream_ = &fstream_;
+        if (name[0]!='/')
+          {
+            fname_ = prefix;
+            fname_ += name;
+          }
+        else
+          {
+            fname_ = name;
+          }
+        Journal(verb_level_data_bloc) << "LataDB: opening data file " << fname_ << endl;
+        if (msb_ == LataDBDataType::ASCII)
+          {
+            switch(mode)
+              {
+              case READ:
+                fstream_.open(fname_, std::fstream::in);
+                break;
+              case WRITE:
+                fstream_.open(fname_, std::fstream::out);
+                break;
+              case APPEND:
+                fstream_.open(fname_, std::fstream::out | std::fstream::app);
+                break;
+              }
+          }
+        else
+          {
+            if (msb_ != LataDBDataType::machine_msb_)
+              {
+                Journal() << "LataDB LataDataFile::write(int) not coded for reverse binary msb" << endl;
+                throw;
+              }
+            switch(mode)
+              {
+              case READ:
+                fstream_.open(fname_, std::fstream::in|std::fstream::binary);
+                break;
+              case WRITE:
+                fstream_.open(fname_, std::fstream::out|std::fstream::binary);
+                break;
+              case APPEND:
+                fstream_.open(fname_, std::fstream::out | std::fstream::app|std::fstream::binary);
+                break;
+              }
+          }
+        if (!fstream_.good())
+          {
+            Journal() << "File not found " << fname_ << endl;
+            throw LataDBError(LataDBError::FILE_NOT_FOUND);
+          }
+      }
+  }
+
+  void set_exception(bool i) { exception_ = i; }
+
+  Size_t position() { return (*stream_).tellp(); }
+
+  enum SeekType { ABSOLUTE, RELATIVE };
+
+  void seek(Size_t pos, SeekType seekt)
+  {
+    Journal(verb_level_data_bloc+1) << "Seeking file " << fname_
+                                    << ((seekt == ABSOLUTE) ? " absolute position " : " relative position ")
+                                    << pos << endl;
+    if (seekt == ABSOLUTE)
+      (*stream_).seekg(pos, std::ios::beg);
+    else
+      (*stream_).seekg(pos, std::ios::cur);
+
+    if (exception_ && !(*stream_).good())
+      {
+        Journal() << "Error seeking to position " << pos << " in file " << fname_ << endl;
+        throw LataDBError(LataDBError::DATA_ERROR);
+      }
+  }
+
+  void set_encoding(LataDBDataType::MSB msb, LataDBDataType::Type type) { msb_ = msb; type_ = type; }
+
+  void set_err_message(const char *message) { message_ = message; }
+
+
+  ///////////////////////////////////
+  ///      Read
+  ///////////////////////////////////
+  // _LATA_T_ in { LataDBInt32, LataDBInt64, float }
+  template<typename _LATA_T_> void read(_LATA_T_ *ptr, Size_t n);
+  template<typename _LATA_T_> LataDataFile& operator>>(_LATA_T_& x)
+  {
+    read<_LATA_T_>(&x, 1);
+    return *this;
+  }
+
+  LataDataFile& operator>>(Nom& n)
+  {
+    n = "";
+    if (msb_ != LataDBDataType::ASCII)
+      {
+        for (;;)
+          {
+            char c[2];
+            c[1] = 0;
+            (*stream_).get(c[0]);
+
+            if (!(*stream_).good())
+              break;
+
+            if (c[0] == '\0')
+              break;
+
+            n += c;
+          }
+      }
+    else
+      {
+        std::string tmp;
+        (*stream_) >> tmp;
+        if ((*stream_).good())
+          n = tmp.c_str();
+      }
+    if (exception_ && !(*stream_).good())
+      {
+        Journal() << "Error reading string in file " << fname_ << endl;
+        throw LataDBError(LataDBError::DATA_ERROR);
+      }
+    return *this;
+  }
+
+  LataDataFile& operator>>(Motcle& n)
+  {
+    Nom n2;
+    operator>>(n2);
+    n = n2;
+    return *this;
+  }
+
+
+  ///////////////////////////////////
+  ///      Write
+  ///////////////////////////////////
+  template<typename _LATA_T_> void write(const _LATA_T_ *ptr, Size_t n, Size_t col);
+  template<typename _LATA_T_> LataDataFile& operator<<(_LATA_T_& x)
+  {
+    write<_LATA_T_>(&x, 1, 1);
+    return *this;
+  }
+
+protected:
+  Nom fname_;
+  const char * message_; // Message printed if error.
+  std::fstream fstream_;
+  std::iostream *stream_; // Points to fstream_ or mem_buffer passed to constructor
+  LataDBDataType::MSB msb_;
+  LataDBDataType::Type type_;
+  bool exception_;
+};
+
+template<typename _LATA_T_>
+void LataDataFile::read(_LATA_T_ *ptr, Size_t n)
+{
+  constexpr bool IS_INT32 = std::is_same<_LATA_T_, LataDBInt32>::value;
+  constexpr bool IS_INT64 = std::is_same<_LATA_T_, LataDBInt64>::value;
+  constexpr bool IS_FLOAT32 = std::is_same<_LATA_T_, float>::value;
+  constexpr bool IS_FLOAT64 = std::is_same<_LATA_T_, double>::value;
+  constexpr const char *TYP_NAM = IS_INT32 ? "int32" : (IS_INT64 ? "int64" : (IS_FLOAT32 ? "float" : "double"));
+
+  if(IS_INT32 || IS_INT64)
+    {
+      if(type_ != LataDBDataType::INT32 && type_ != LataDBDataType::INT64)
+        {
+          Journal() << "Error in lataDB bloc read: trying to read non-integer data into integer array!!" << endl;
+          throw LataDBError(LataDBError::DATA_ERROR);
+        }
+      if(IS_INT32 && type_ == LataDBDataType::INT64)
+        {
+          Journal() << "Error in lataDB bloc read: trying to read 64b-integer data into 32b-integer array!!" << endl;
+          throw LataDBError(LataDBError::DATA_ERROR);
+        }
+    }
+  if ((IS_FLOAT32 || IS_FLOAT64) && type_ != LataDBDataType::REAL32 && type_ != LataDBDataType::REAL64)
+    {
+      Journal() << "Error in lataDB bloc read: trying to read integer data into a non-integer array!!" << endl;
+      throw LataDBError(LataDBError::DATA_ERROR);
+    }
+
+  if (msb_ == LataDBDataType::ASCII)
+    {
+      Journal(verb_level_data_bloc+1) << (ptr ? "Reading" : "Skipping") << " ascii " << TYP_NAM << " data bloc size=" << n << endl;
+      _LATA_T_ toto;
+      for (Size_t i = 0; i < n; i++)
+        {
+          if (ptr)
+            (*stream_) >> ptr[i];
+          else
+            (*stream_) >> toto;
+          if (exception_ && !(*stream_).good())
+            {
+              Journal() << "Error reading ascii file " << fname_ << " " << TYP_NAM << "[" << n << "] at index "
+                        << i << endl << (message_?message_:"") << endl;
+              throw LataDBError(LataDBError::DATA_ERROR);
+            }
+        }
+    }
+  else
+    {
+      if (msb_ != LataDBDataType::machine_msb_)
+        {
+          Journal() << "LataDB LataDataFile::read(_LATA_T_) not coded for reverse binary msb" << endl;
+          throw;
+          // Put code here (and test !) to reverse bytes in the binary bloc:
+        }
+      // Read data in binary, potentially converting int32 into int64:
+      const int SZOF = type_ == LataDBDataType::INT32 ? sizeof(LataDBInt32) : (type_ == LataDBDataType::INT64 ? sizeof(LataDBInt64) : sizeof(_LATA_T_));
+      if (ptr)
+        {
+          Journal(verb_level_data_bloc+1) << "Reading binary " << TYP_NAM << " data bloc size=" << n << endl;
+          // No conversion needed
+          if (!(type_ == LataDBDataType::INT32 && IS_INT64))  // case "LDBType::INT64 && IS_INT32" excluded above in the method
+            (*stream_).read((char*)ptr, n * SZOF);
+          else  // Need to convert: file is INT32 but we want to store in an array which is INT64
+            {
+              Journal(verb_level_data_bloc+1) << "Converting binary data (int32 to int64) bloc size=" << n << endl;
+              std::vector<LataDBInt32> tmp(n);
+              LataDBInt32 * tmp_p = tmp.data();
+              (*stream_).read((char*)tmp_p, n * sizeof(LataDBInt32));  // read as 32b
+              std::copy(tmp_p, tmp_p+n, ptr);  // copy into the 64b array
+            }
+        }
+      else
+        {
+          Journal(verb_level_data_bloc+1) << "Skipping binary " << TYP_NAM << " data bloc size=" << n << endl;
+          seek(n * SZOF, RELATIVE);
+        }
+      // Error checking:
+      if (exception_ && !(*stream_).good())
+        {
+          Journal() << "Error reading binary file " << fname_ << " " << TYP_NAM << "[" << n << "]"
+                    << endl << (message_?message_:"") << endl;
+          throw LataDBError(LataDBError::DATA_ERROR);
+        }
+    }
+}
+
+template<typename _LATA_T_>
+void LataDataFile::write(const _LATA_T_ *ptr, Size_t n, Size_t columns)
+{
+  constexpr bool IS_INT32 = std::is_same<_LATA_T_, LataDBInt32>::value;
+  constexpr bool IS_INT64 = std::is_same<_LATA_T_, LataDBInt64>::value;
+  constexpr bool IS_FLOAT32 = std::is_same<_LATA_T_, float>::value;
+  constexpr bool IS_FLOAT64 = std::is_same<_LATA_T_, double>::value;
+  constexpr const char *TYP_NAM = IS_INT32 ? "int32" : (IS_INT64 ? "int64" : (IS_FLOAT32 ? "float" : "double"));
+
+  Journal(verb_level_data_bloc+1) << "Writing " << TYP_NAM << " data bloc size=" << n << endl;
+
+  if ((IS_INT32 || IS_INT64) && type_ != LataDBDataType::INT32 && type_ != LataDBDataType::INT64)
+    {
+      Journal() << "Error in lataDB bloc read: trying to write integer data into non-integer file block" << endl;
+      throw LataDBError(LataDBError::DATA_ERROR);
+    }
+  if ((IS_FLOAT32 || IS_FLOAT64) && type_ != LataDBDataType::REAL32 && type_ != LataDBDataType::REAL64)
+    {
+      Journal() << "Error in lataDB bloc read: trying to write non-integer data into integer file block" << endl;
+      throw LataDBError(LataDBError::DATA_ERROR);
+    }
+
+  if (msb_ == LataDBDataType::ASCII)
+    {
+      for (Size_t i = 0; i < n; i+=columns)
+        {
+          Size_t j;
+          for (j = 0; j < columns-1; j++)
+            (*stream_) << ptr[i+j] << " ";
+          (*stream_) << ptr[i+j] << endl;
+        }
+    }
+  else
+    {
+      // Nothing to write? Bye!
+      if (!ptr || n == 0) return;
+
+      if (msb_ != LataDBDataType::machine_msb_)
+        {
+          Journal() << "LataDB LataDataFile::write(int) not coded for reverse binary msb" << endl;
+          throw;
+          // Put code here (and test !) to reverse bytes in the binary bloc:
+        }
+
+      Journal(verb_level_data_bloc+1) << "Reading binary " << TYP_NAM << " data bloc size=" << n << endl;
+
+      const int SZOF = type_ == LataDBDataType::INT32 ? sizeof(LataDBInt32) : (type_ == LataDBDataType::INT64 ? sizeof(LataDBInt64) : sizeof(_LATA_T_));
+      if (! ((type_ == LataDBDataType::INT32 && IS_INT64) || (type_ == LataDBDataType::INT64 && IS_INT32)))
+        // No int conversion needed, or float or double
+        (*stream_).write((char*)ptr, n * SZOF);
+      else
+        {
+          // Read data in binary, potentially converting int32 <-> int64:
+          if (type_ == LataDBDataType::INT32 && IS_INT64)  // the nasty case :-)
+            {
+              Journal(verb_level_data_bloc+1) << "Converting binary data (int64 -> int32) bloc size=" << n << endl;
+              // We will downcast, so lots of checks:
+              if (n > std::numeric_limits<LataDBInt32>::max())
+                {
+                  Journal() << "Error casting down 64b array to 32b - array is too big!" << endl;
+                  throw;
+                }
+              LataDBInt32 in = (LataDBInt32)n;
+              std::vector<LataDBInt32> tmp(in);
+              // Now check min/max (cast to _LATA_T_ just for compile - we know that _LATA_T_ = 64b here):
+              if (! (    *std::min_element(ptr, ptr+n) > (_LATA_T_)std::numeric_limits<LataDBInt32>::min()
+                      || *std::max_element(ptr, ptr+n) < (_LATA_T_)std::numeric_limits<LataDBInt32>::max()))
+                {
+                  Journal() << "Error casting down 64b array to 32b - array contains values that do not fit into an int32!" << endl;
+                  throw;
+                }
+              LataDBInt32 * tmp_p = tmp.data();
+              std::copy(ptr, ptr+n, tmp_p);  // copy into the 32b array, downcasting.
+              (*stream_).write((char*)tmp_p, n * sizeof(LataDBInt32)); // write as 32b
+            }
+          else   // type_==LataDBType::INT64 && IS_INT32
+            { // Here we up cast, no check needed
+              Journal(verb_level_data_bloc+1) << "Converting binary data (int32 -> int64) bloc size=" << n << endl;
+              std::vector<LataDBInt64> tmp(n);
+              LataDBInt64 * tmp_p = tmp.data();
+              std::copy(ptr, ptr+n, tmp_p);  // copy into the 64b array, implicitly upcasting.
+              (*stream_).write((char*)tmp_p, n * sizeof(LataDBInt64));  // write as 64b
+
+            }
+        }
+
+      // Exception checking:
+      (*stream_).seekg(0, std::ios::end);
+      if (exception_ && !(*stream_).good())
+        {
+          Journal() << "Error writing file " << fname_ << " " << TYP_NAM << "[" << n << "]" << endl << message_ << endl;
+          throw LataDBError(LataDBError::DATA_ERROR);
+        }
+    }
+}
+
+
+// Description: skips a fortran bloc size descriptor.
+void skip_blocksize(LataDataFile& f, const LataDBDataType& type)
+{
+  if (type.fortran_bloc_markers_ == LataDBDataType::NO_BLOC_MARKER)
+    return;
+  f.set_err_message("Error reading fortran blocsize");
+  f.set_encoding(type.msb_, type.bloc_marker_type_);
+  Size_t i;
+  f >> i;
+  Journal(verb_level_data_bloc+1) << "Skipping blocsize marker value=" << i << endl;
+}
+
+template<class DEST_TYPE>
+DEST_TYPE int_conversion(LataDBInt64 x, const char * err_msg=nullptr)
+{
+  DEST_TYPE result = (DEST_TYPE) x;
+  if ((LataDBInt64) result != x)
+    {
+      Journal() << "LataDB integer conversion failed: " << (err_msg ? err_msg : "") << endl;
+      throw(LataDBError(LataDBError::INTEGER_OVERFLOW));
+    }
+  return result;
+}
+
+void write_blocksize(LataDataFile& f, const LataDBDataType& type, Size_t sz)
+{
+  if (type.fortran_bloc_markers_ == LataDBDataType::NO_BLOC_MARKER)
+    return;
+
+  Journal(verb_level_data_bloc+1) << "Writing blocsize marker value=" << sz << endl;
+  f.set_err_message("Error writing fortran blocsize");
+  f.set_encoding(type.msb_, type.bloc_marker_type_);
+  f << sz;
+}
+
+void bloc_read_skip(LataDataFile& f, LataDBDataType::MSB msb, LataDBDataType::Type type, Size_t size)
+{
+  f.set_encoding(msb, type);
+  switch(type)
+    {
+    case LataDBDataType::INT32:
+      f.read((LataDBInt32*) 0, size);
+      break;
+    case LataDBDataType::INT64:
+      f.read((LataDBInt64*) 0, size);
+      break;
+    case LataDBDataType::REAL32:
+      f.read((float*) 0, size);
+      break;
+    case LataDBDataType::REAL64:
+      f.read((double*) 0, size);
+      break;
+    default:
+      Journal() << "Internal error: bloc read skip not code for this type" << endl;
+      throw;
+    }
+}
+
+// Description: Read "tab.size_array()" values from file "f" at current file location
+//  into the "tab" array. "msb" and "type" must match the data type written in the file.
+template <typename _TAB_>
+void bloc_read(LataDataFile& f, LataDBDataType::MSB msb, LataDBDataType::Type type, _TAB_& tab)
+{
+  f.set_encoding(msb, type);
+  f.read(tab.addr(), tab.size_array());
+}
+
+template <typename _TAB_>
+void bloc_write(LataDataFile& f, LataDBDataType::MSB msb, LataDBDataType::Type type, const _TAB_& tab, Size_t columns)
+{
+  f.set_encoding(msb, type);
+  f.write(tab.addr(), tab.size_array(), columns);
+}
+
+LataDBDataType::MSB LataDBDataType::machine_msb_ = (mymachine_msb) ? LataDBDataType::MSB_BIG_ENDIAN : LataDBDataType::MSB_LITTLE_ENDIAN;
+
+void LataDB::add(int tstep, const LataDBGeometry& item)
+{
+  Noms names = geometry_names(tstep);
+  if (names.rang(item.name_) >= 0)
+    {
+      Journal() << "Error in LataDBTimestep::add(const LataDBGeometry &): duplicate geometry name " << item.name_ << endl;
+      throw(LataDBError(LataDBError::READ_ERROR));
+    }
+  timesteps_[tstep].geoms_.add(item);
+}
+
+void LataDB::add(int tstep, const LataDBField& item)
+{
+  LataDBField& field = timesteps_[tstep].fields_.add(item);
+  field.timestep_ = tstep;
+  field.uname_ = Field_UName(item.geometry_, item.name_, item.localisation_);
+  Journal(verb_level+1) << "LataDB::add " << tstep << " " << field.uname_ << endl;
+}
+
+// Description: returns the number of timesteps in the database
+//  (timestep 0 contains geometries and fields defined before the first TEMPS entry,
+//   hence nb_timesteps() == number of TEMPS entries plus 1)
+// Exceptions: BAD_TIMESTEP
+int LataDB::nb_timesteps() const
+{
+  return timesteps_.size();
+}
+
+// Description: returns the physical time for this timestep
+// Exceptions: BAD_TIMESTEP
+double LataDB::get_time(int tstep) const
+{
+  return get_tstep(tstep).time_;
+}
+
+// Description: returns the requested geometry in the requested timestep
+//  "where" tells where to seach this geometry (in the current timestep or
+//  also in the first timestep.
+// Exceptions: BAD_TIMESTEP NAME_NOT_FOUND
+const LataDBGeometry& LataDB::get_geometry(int tstep, const char* name, TStepSelector where) const
+{
+  if (!name)
+    throw(LataDBError(LataDBError::NAME_NOT_FOUND));
+  while (1)
+    {
+      const LataDBTimestep& t = get_tstep(tstep);
+      const int n = t.geoms_.size();
+      for (int i = 0; i < n; i++)
+        {
+          const LataDBGeometry& geom = t.geoms_[i];
+          if (geom.name_ == name)
+            return geom;
+        }
+      if (where == FIRST_AND_CURRENT && tstep > 0)
+        tstep = 0;
+      else
+        break;
+    }
+  throw(LataDBError(LataDBError::NAME_NOT_FOUND));
+}
+
+// Description: returns the requested field in the requested timestep.
+// Exceptions: BAD_TIMESTEP NAME_NOT_FOUND
+const LataDBField& LataDB::get_field(int tstep, const Field_UName& uname, TStepSelector where) const
+{
+  while (1)
+    {
+      const LataDBTimestep& t = get_tstep(tstep);
+      const int n = t.fields_.size();
+      for (int i = 0; i < n; i++)
+        {
+          const LataDBField& field = t.fields_[i];
+          if (field.uname_ == uname)
+            return field;
+        }
+      if (where == FIRST_AND_CURRENT && tstep > 0)
+        tstep = 0;
+      else
+        break;
+    }
+  throw(LataDBError(LataDBError::NAME_NOT_FOUND));
+}
+
+// Description: shortcut, works only if the specified field exists and is unique.
+const LataDBField& LataDB::get_field(int tstep, const char *geom, const char *name, const char *loc, TStepSelector which_tstep) const
+{
+  Field_UNames fields = field_unames(tstep, geom, name, which_tstep);
+  if (fields.size() > 1)
+    cerr << "get_field(char *geom, char *name, ...) returned more than one field !" << endl;
+  if (fields.size() != 1)
+    throw(LataDBError(LataDBError::NAME_NOT_FOUND));
+  return get_field(tstep, fields[0], which_tstep);
+}
+
+// Description: return 1 if the field exists AND is unique. (means you can call get_field with the
+//  same parameters)
+bool LataDB::field_exists(int tstep, const char *geom, const char *name, TStepSelector which_tstep) const
+{
+  Field_UNames fields = field_unames(tstep, geom, name, which_tstep);
+  return fields.size() == 1;
+}
+
+
+LataDBField& LataDB::getset_field(int tstep, const Field_UName& uname, TStepSelector which_tstep)
+{
+  return (LataDBField&) get_field(tstep, uname, which_tstep);
+}
+
+// Description: returns the names of all geometries defined in the timestep
+//  which_tstep tell where to search for geometries.
+// Exceptions: BAD_TIMESTEP
+Noms LataDB::geometry_names(int tstep, TStepSelector which_tstep) const
+{
+  Noms names;
+  const LataDBTimestep& t = get_tstep(tstep);
+  int n = t.geoms_.size();
+  for (int i = 0; i < n; i++)
+    names.add(t.geoms_[i].name_);
+  if (which_tstep == FIRST_AND_CURRENT && tstep > 0)
+    {
+      const LataDBTimestep& t0 = get_tstep(0);
+      int n2 = t0.geoms_.size();
+      for (int i = 0; i < n2; i++)
+        // add if not:
+        if (names.rang(t0.geoms_[i].name_) < 0)
+          names.add(t0.geoms_[i].name_);
+    }
+  return names;
+}
+
+// Description: returns the unique_identifiers of all fields defined in the timestep and for which
+//  the associated geometry is "geometry" and the name is "name". Some fields may have no associated geometry,
+//  give a null pointer or empty string to get these fields.
+//  If geometry="*", returns list for all geometries
+//  If name="*", returns list for all field names
+// Exceptions: BAD_TIMESTEP
+LataVector<Field_UName> LataDB::field_unames(int tstep, const char * geometry, const char * name, TStepSelector which_tstep) const
+{
+  LataVector<Field_UName> unames;
+  if (!geometry)
+    geometry = "";
+  for (;;)
+    {
+      const LataDBTimestep& t = get_tstep(tstep);
+      int n = t.fields_.size();
+      for (int i = 0; i < n; i++)
+        {
+          const LataDBField& field = t.fields_[i];
+          if ((field.geometry_ == geometry || strcmp(geometry, "*")==0 )
+              && (field.name_ == name || strcmp(name,"*")==0 ))
+            unames.add(field.uname_);
+        }
+      if (tstep == 0 || which_tstep != FIRST_AND_CURRENT)
+        break;
+      tstep = 0;
+    }
+  return unames;
+}
+
+void check(Entree& is, const char * msg)
+{
+  if (!is.good())
+    {
+      Journal() << "LataDB::read_master_file " << msg << endl;
+      throw(LataDBError(LataDBError::READ_ERROR));
+    }
+}
+
+void read_keyword_nom(Entree& is, Nom& motlu)
+{
+  is >> motlu;
+  if (is.eof())
+    {
+      Journal(verb_level) << "LataDB::read_master_file end of file" << endl;
+      motlu = "Fin";
+    }
+  else
+    {
+      check(is, "read string error but not eof !");
+    }
+
+}
+
+void read_keyword(Entree& is, Nom& nomlu, Motcle& motlu)
+{
+  read_keyword_nom(is,nomlu);
+  motlu=nomlu;
+}
+
+// On suppose que motlu contient "blabla=VALEUR". On extrait valeur et on la met dans "param".
+// Bidouille: pour traiter le cas "blabla= VALEUR", s'il n'y a rien apres "=" dans motlu, on
+//  relit un mot dans is.
+void read_long_param(Entree& is, const Motcle& motlu, LataDBInt64& param, const char * err_msg)
+{
+  // Cherche le "="
+  const char *s = motlu;
+  while (((*s) != ('=')) && ((*s) != 0))
+    s++;
+  if (s==0)
+    {
+      Journal() << "LataDB::read_master_file error: " << err_msg << endl;
+      throw(LataDBError(LataDBError::READ_ERROR));
+    }
+  s++;
+  Nom tmp;
+  if (*s==0)
+    {
+      // il y a une espace entre le = et le parametre ?
+      read_keyword_nom(is, tmp);
+      s = tmp;
+    }
+  errno = 0;
+  char *errorptr = 0;
+  param = strtoll(s, &errorptr, 0 /* base 10 par defaut */);
+  if (errno || *errorptr != 0)
+    {
+      Journal() << "LataDB::read_master_file error: " << err_msg << endl
+                << "Error converting a string to type long int : string = " << s << endl;
+      throw(LataDBError(LataDBError::READ_ERROR));
+    }
+}
+
+void read_int_param(Entree& is, const Motcle& motlu, LataDBInt32& param, const char * err_msg)
+{
+  LataDBInt64 i;
+  read_long_param(is, motlu, i, err_msg);
+  param = int_conversion<LataDBInt32>(i, err_msg);
+}
+
+inline void read_tid_param(Entree& is, const Motcle& motlu, trustIdType& param, const char * err_msg)
+{
+  // trustIdType is 'long' if compiling in 64b, or if in lata_tools stuff:
+#if defined(INT_is_64_)
+  read_long_param(is, motlu, param, err_msg);
+#else
+  read_int_param(is, motlu, param, err_msg);
+#endif
+}
+
+
+// Idem que read_int_param pour des chaines de caracteres.
+void read_string_param(Entree& is, const Nom& motlu, Nom& param, const char * err_msg)
+{
+  // Cherche le "="
+  const char *s = motlu;
+  while (((*s) != ('=')) && ((*s) != 0))
+    s++;
+  if (s==0)
+    {
+      Journal() << "LataDB::read_master_file error: " << err_msg << endl;
+      throw(LataDBError(LataDBError::READ_ERROR));
+    }
+  s++;
+  param = s;
+  // S'il n'y a rien apres =, on lit un mot de plus.
+  if (param == "")
+    read_keyword_nom(is, param);
+}
+
+
+void read_noms_param(Entree& is, const Nom& motlu, Noms& param, const char * err_msg)
+{
+  Nom tmp;
+  read_string_param(is,motlu,tmp,err_msg);
+}
+
+// Description: internal tool: checks for valid i and returns the timestep
+// Exceptions: BAD_TIMESTEP
+const LataDBTimestep& LataDB::get_tstep(int i) const
+{
+  if (i < 0 || i >= timesteps_.size())
+    {
+      Journal() << "LataDB::timestep(" << i << ") : wrong timestep" << endl;
+      throw(LataDBError(LataDBError::BAD_TIMESTEP));
+    }
+  return timesteps_[i];
+}
+
+// Description: clears the database
+void LataDB::reset()
+{
+  path_prefix_ = "";
+  header_ = "";
+  case_ = "";
+  software_id_ = "";
+  timesteps_.reset();
+  std::string empty;
+  internal_data_buffer_.str(empty);
+}
+
+// We update only fields found in the string
+// A string can contain both an int type and a float type: we get both in int_type and float_type
+static void read_format_string(const Motcle& n, LataDBDataType& data_type,
+                               LataDBDataType::Type& int_type, LataDBDataType::Type& float_type)
+{
+  int_type = LataDBDataType::UNKNOWN_TYPE;
+  float_type = LataDBDataType::UNKNOWN_TYPE;
+
+  if (n.find("ASCII")>=0)
+    data_type.msb_ = LataDBDataType::ASCII;
+  if (n.find("BIG_ENDIAN")>=0)
+    data_type.msb_ = LataDBDataType::MSB_BIG_ENDIAN;
+  if (n.find("LITTLE_ENDIAN")>=0)
+    data_type.msb_ = LataDBDataType::MSB_LITTLE_ENDIAN;
+
+  if (n.find("INT32")>=0)
+    {
+      int_type = data_type.type_ = LataDBDataType::INT32;
+      data_type.bloc_marker_type_ = LataDBDataType::INT32;
+    }
+  if (n.find("INT64")>=0)
+    {
+      int_type = data_type.type_ = LataDBDataType::INT64;
+      data_type.bloc_marker_type_ = LataDBDataType::INT64;
+    }
+  if (n.find("REAL32")>=0)
+    float_type = data_type.type_ = LataDBDataType::REAL32;
+  if (n.find("REAL64")>=0)
+    float_type = data_type.type_ = LataDBDataType::REAL64;
+
+  if (n.find("C_INDEXING")>=0)
+    data_type.array_index_ = LataDBDataType::C_INDEXING;
+  if (n.find("F_INDEXING")>=0)
+    data_type.array_index_ = LataDBDataType::F_INDEXING;
+  if (n.find("NO_INDEXING")>=0)
+    data_type.array_index_ = LataDBDataType::NOT_AN_INDEX;
+
+  if (n.find("C_ORDERING")>=0)
+    data_type.data_ordering_ = LataDBDataType::C_ORDERING;
+  if (n.find("F_ORDERING")>=0)
+    data_type.data_ordering_ = LataDBDataType::F_ORDERING;
+
+  if (n.find("F_MARKERS_NO")>=0)
+    data_type.fortran_bloc_markers_ = LataDBDataType::NO_BLOC_MARKER;
+  if (n.find("F_MARKERS_SINGLE")>=0)
+    data_type.fortran_bloc_markers_ = LataDBDataType::BLOC_MARKERS_SINGLE_WRITE;
+  if (n.find("F_MARKERS_MULTIPLE")>=0)
+    data_type.fortran_bloc_markers_ = LataDBDataType::BLOC_MARKERS_MULTIPLE_WRITES;
+
+  // Fortran bloc markers are tested after INT32 and INT64 because they
+  //  override the default value:
+  if (n.find("MARKERS32")>=0)
+    data_type.bloc_marker_type_ = LataDBDataType::INT32;
+  if (n.find("MARKERS64")>=0)
+    data_type.bloc_marker_type_ = LataDBDataType::INT64;
+}
+
+// This must work together with read_format_string:
+void build_format_string(const LataDBDataType& default_type, const LataDBDataType& type, Motcle& n)
+{
+  n = "";
+  if (type.msb_ != default_type.msb_)
+    {
+      switch(type.msb_)
+        {
+        case LataDBDataType::ASCII:
+          n += "ASCII,";
+          break;
+        case LataDBDataType::MSB_BIG_ENDIAN:
+          n += "BIG_ENDIAN,";
+          break;
+        case LataDBDataType::MSB_LITTLE_ENDIAN:
+          n += "LITTLE_ENDIAN,";
+          break;
+        default:
+          Journal() << "write master lata: invalid MSB" << endl;
+          throw(LataDBError(LataDBError::INVALID_OPERATION));
+        }
+    }
+
+  // Is an integer type specified in the format string: then the default
+  //  fortran bloc marker_type will be changed (look for MARKER32 in read_format_string)
+  LataDBDataType::Type default_fortran_bloc_type = default_type.bloc_marker_type_;
+
+  if (type.type_ != default_type.type_)
+    {
+      switch(type.type_)
+        {
+        case LataDBDataType::INT32:
+          n += "INT32,";
+          default_fortran_bloc_type = LataDBDataType::INT32;
+          break;
+        case LataDBDataType::INT64:
+          n += "INT64,";
+          default_fortran_bloc_type = LataDBDataType::INT64;
+          break;
+        case LataDBDataType::REAL32:
+          n += "REAL32,";
+          break;
+        case LataDBDataType::REAL64:
+          n += "REAL64,";
+          break;
+        default:
+          Journal() << "write master lata: invalid type" << endl;
+          throw(LataDBError(LataDBError::INVALID_OPERATION));
+        }
+    }
+
+  // Specify indexing only if integer type:
+  if ((type.type_ == LataDBDataType::INT32 || type.type_ == LataDBDataType::INT64)
+      && type.array_index_ != default_type.array_index_)
+    switch(type.array_index_)
+      {
+      case LataDBDataType::C_INDEXING:
+        n += "C_INDEXING,";
+        break;
+      case LataDBDataType::F_INDEXING:
+        n += "F_INDEXING,";
+        break;
+      case LataDBDataType::NOT_AN_INDEX:
+        n += "NO_INDEXING,";
+        break;
+      default:
+        Journal() << "write master lata: invalid array_index_" << endl;
+        throw(LataDBError(LataDBError::INVALID_OPERATION));
+      }
+
+  if (type.data_ordering_ != default_type.data_ordering_)
+    {
+      switch(type.data_ordering_)
+        {
+        case LataDBDataType::C_ORDERING:
+          n += "C_ORDERING,";
+          break;
+        case LataDBDataType::F_ORDERING:
+          n += "F_ORDERING,";
+          break;
+        default:
+          Journal() << "write master lata: invalid data_ordering_" << endl;
+          throw(LataDBError(LataDBError::INVALID_OPERATION));
+        }
+    }
+
+  if (type.fortran_bloc_markers_ != default_type.fortran_bloc_markers_)
+    {
+      switch(type.fortran_bloc_markers_)
+        {
+        case LataDBDataType::NO_BLOC_MARKER:
+          n += "F_MARKERS_NO,";
+          break;
+        case LataDBDataType::BLOC_MARKERS_SINGLE_WRITE:
+          n += "F_MARKERS_SINGLE,";
+          break;
+        case LataDBDataType::BLOC_MARKERS_MULTIPLE_WRITES:
+          n += "F_MARKERS_MULTIPLE,";
+          break;
+        default:
+          Journal() << "write master lata: invalid fortran_bloc_markers_" << endl;
+          throw(LataDBError(LataDBError::INVALID_OPERATION));
+        }
+    }
+
+  // Warning : tricky code to determine if we have to specify fortran bloc marker size:
+  // If we specify a type_ and this type_ is an integer type, then the fortran bloc
+  //  marker has implicitely the same type. We want to override this type if
+  //  this assumption is wrong:
+  if (type.fortran_bloc_markers_ != LataDBDataType::NO_BLOC_MARKER
+      && default_fortran_bloc_type != type.bloc_marker_type_)
+    {
+      switch(type.bloc_marker_type_)
+        {
+        case LataDBDataType::INT32:
+          n += "MARKER32,";
+          break;
+        case LataDBDataType::INT64:
+          n += "MARKER64,";
+          break;
+        default:
+          Journal() << "write master lata: invalid fortran bloc marker type" << endl;
+          throw(LataDBError(LataDBError::INVALID_OPERATION));
+        }
+    }
+
+  // Remove trailing "," if any.
+  n.prefix(",");
+}
+
+// Description: returns the content of the third line of the file
+// Exceptions: FILE_NOT_FOUND, BAD_HEADER (means that this is not a lata file)
+Nom LataDB::read_master_file_options(const char *filename)
+{
+  LataDB db;
+  EFichier is;
+  db.read_master_file_header(filename, is);
+  return db.software_id_; // Returns the content of the third line
+}
+
+// Description:
+//  Opens the file and reads the three firt lines.
+//  Fills the following attributes of the class:
+//   header_
+//   case_
+//   software_id_
+//   old_style_lata_
+void LataDB::read_master_file_header(const char *filename, EFichier& is)
+{
+  if (!filename)
+    filename = ""; // Will trigger an error for sure !
+  is.ouvrir(filename);
+  if (!is.good())   // isnogood ?
+    {
+      Journal() << "LataDB::read_master_file_options failed opening file " << filename << endl;
+      throw(LataDBError(LataDBError::FILE_NOT_FOUND));
+    }
+  Journal(verb_level-1) << "Trying to read master lata file format LATA "
+                        << filename << endl;
+
+  const int bufsize=1024;
+  char s[bufsize+1];
+  // Lecture de l'entete:
+  is.get_istream().getline(s, bufsize);
+  check(is, "failed reading line 1");
+  const char * lata_header = "LATA_V2.";
+  old_style_lata_ = false;
+  if (strncmp(s, lata_header, strlen(lata_header)) == 0)
+    {
+      Journal(2) << "LataDB::read_master_file found lata format " << lata_header << endl;
+      old_style_lata_ = false;
+    }
+  else if ((Motcle(s).debute_par("Trio_U"))||(Motcle(s).debute_par("TRUST")))
+    {
+      Journal(2) << "LataDB::read_master_file found old style lata format" << endl;
+      old_style_lata_ = true;
+    }
+  else
+    {
+      Journal(2) << "LataDB::read_master_file error reading header: expected LATA_V2.0 or TRUST"
+                 << " instead of " << s << endl;
+      throw(LataDBError(LataDBError::BAD_HEADER));
+    }
+  header_ = s;
+  is.get_istream().getline(s, bufsize);
+  check(is, "failed reading line 2");
+  case_ = s;
+  is.get_istream().getline(s, bufsize);
+  check(is, "failed reading line 3");
+  software_id_ = s;
+}
+
+bool is_med(const char* filename)
+{
+  Motcle motcle_nom_fic(filename);
+  return motcle_nom_fic.finit_par(".med");
+}
+
+int is_fort21(const char* filename)
+{
+  Motcle motcle_nom_fic(filename);
+
+  if (motcle_nom_fic.find("FORT21")>=0)
+    return 1;
+  return 0;
+}
+
+// Description: Reads the .lata database in the given file indicating than the
+//  associated data files will be found in directory "prefix".
+//  If not empty, "prefix" must finish with a '/'.
+//  For "prefix" and "filename", if they do not begin with '/', are relative to pwd.
+// Exceptions:
+//  BAD_HEADER  means that the header found in this stream is not LATA_V2
+//  READ_ERROR  means that an error has been found in the file (premature eof,
+//              io error, bad keyword, ...)
+//  FILE_NOT_FOUND means that, well, the lata file could not be opened
+void LataDB::read_master_file(const char *prefix, const char *filename)
+{
+  reset();
+
+  if (!prefix)
+    prefix = "";
+  path_prefix_ = prefix;
+
+  if (is_med(filename))
+    {
+      path_prefix_ = "";
+      read_master_file_med(prefix,filename);
+      return;
+    }
+
+  if (is_fort21(filename))
+    {
+      path_prefix_ = "";
+      read_master_file_fort21(prefix,filename);
+      return;
+    }
+
+  EFichier is;
+  read_master_file_header(filename, is);
+
+  // Defaults for lataV1
+  default_type_int_.msb_ = LataDBDataType::ASCII;
+  default_type_int_.type_ = LataDBDataType::INT32;
+  default_type_int_.array_index_ = LataDBDataType::F_INDEXING;
+  default_type_int_.data_ordering_ = LataDBDataType::C_ORDERING;
+  default_type_int_.fortran_bloc_markers_ = LataDBDataType::BLOC_MARKERS_SINGLE_WRITE;
+  default_type_int_.bloc_marker_type_ = LataDBDataType::INT32;
+  default_float_type_ = LataDBDataType::REAL32;
+
+  // Create timestep 0 (global domain and fields)
+  timesteps_.add(LataDBTimestep());
+  bool interface_file_not_found = false;
+  Nom nomlu;
+  Motcle motlu;
+  read_keyword(is, nomlu,motlu);
+
+  while (1)
+    {
+      if (motlu == "Fin")
+        {
+          Journal(verb_level) << "End of file by FIN" << endl;
+          break;
+        }
+      else if (motlu == "Format")
+        {
+          Journal(verb_level) << "Reading Format " << endl;
+          read_keyword(is, nomlu, motlu);
+          LataDBDataType::Type tmp_int_type;
+          read_format_string(motlu, default_type_int_, tmp_int_type, default_float_type_);
+          default_type_int_.type_ = tmp_int_type;
+          read_keyword(is, nomlu, motlu);
+        }
+      else if (motlu == "Temps")
+        {
+          LataDBTimestep& t = timesteps_.add(LataDBTimestep());
+          const int i = timesteps_.size() - 1;
+          is >> t.time_;
+          check(is, "failed reading time parameter");
+          Journal(verb_level) << "Reading timestep " << i << " t=" << t.time_ << endl;
+          read_keyword(is, nomlu, motlu);
+        }
+      else if (motlu == "Geom")
+        {
+          // This is the new syntax to declare a geometry.
+          // nodes, elements faces, files are declared in separate "champ" entries
+          LataDBGeometry dom;
+          dom.timestep_ = timesteps_.size()-1;
+          is >> dom.name_;
+          check(is, "failed reading domain name");
+          Journal(verb_level) << "New domain " << dom.name_ << endl;
+          while (1)
+            {
+              read_keyword(is, nomlu, motlu);
+              if (motlu.debute_par("type_elem="))
+                {
+                  read_string_param(is, motlu, dom.elem_type_, "error reading type_elem parameter");
+                  Journal(verb_level+1) << " type_elem=" << dom.elem_type_ << endl;
+                }
+              else
+                break;
+            }
+          if (dom.elem_type_ == "")
+            {
+              Journal() << "Error reading Geometry: missing type_elem parameter" << endl;
+              throw(LataDBError(LataDBError::READ_ERROR));
+            }
+          add(timesteps_.size() - 1, dom);
+        }
+      else if (motlu == "Geometrie")
+        {
+          // Declare a geometry: nodes and elements are embedded in a single file described here
+          // (legacy syntax)
+          LataDBGeometry dom;
+          LataDBField som;
+          // Name
+          is >> dom.name_;
+          dom.timestep_ = timesteps_.size()-1;
+          check(is, "failed reading domain name");
+          Journal(verb_level) << "Reading domain " << dom.name_ << endl;
+          som.name_ = "SOMMETS";
+          som.geometry_ = dom.name_;
+          // Filenames
+          Nom n;
+          is >> n;
+          check(is, "failed reading domain filename");
+          som.filename_ = n;
+          trustIdType nb_elem = -1;
+          trustIdType nb_faces = -1;
+          LataDBInt32 nproc = -1;
+          Nom file_decal_som;
+          Nom file_decal_elem;
+          Nom file_decal_faces;
+          while (1)
+            {
+              read_keyword(is, nomlu, motlu);
+              if (motlu.debute_par("nb_som_tot="))
+                {
+                  read_tid_param(is, motlu, som.size_, "bad nb_som_tot parameter");
+                }
+              else if (motlu.debute_par("nb_elem_tot="))
+                {
+                  read_tid_param(is, motlu, nb_elem, "bad nb_elem_tot parameter");
+                }
+              else if (motlu.debute_par("type_elem="))
+                {
+                  read_string_param(is, motlu, dom.elem_type_, "error reading type_elem parameter");
+                }
+              else if (motlu.debute_par("nb_faces_tot="))
+                {
+                  read_tid_param(is, motlu, nb_faces, "bad nb_elem_tot parameter");
+                }
+              else if (motlu.debute_par("format="))
+                {
+                  Motcle fmt;
+                  read_string_param(is, motlu, fmt, "bad format parameter");
+                  if (fmt=="BINARY")
+                    {
+                      default_type_int_.msb_ = LataDBDataType::machine_msb_;
+                    }
+                }
+              else if (motlu.debute_par("joints_sommets"))
+                {
+                  read_keyword(is, nomlu, motlu);
+                  read_int_param(is, motlu, nproc, "bad nproc parameter");
+                  read_keyword(is, nomlu, motlu);
+                  read_string_param(is, nomlu, file_decal_som, "bad decalage file parameter");
+                  Journal(verb_level+1) << " decal_som " << nproc;
+                }
+              else if (motlu.debute_par("joints_elements"))
+                {
+                  read_keyword(is, nomlu, motlu);
+                  read_int_param(is, motlu, nproc, "bad nproc parameter");
+                  read_keyword(is, nomlu, motlu);
+                  read_string_param(is, nomlu, file_decal_elem, "bad decalage file parameter");
+                  Journal(verb_level+1) << " decal_elem " << nproc;
+                }
+              else if (motlu.debute_par("joints_faces"))
+                {
+                  read_keyword(is, nomlu, motlu);
+                  read_int_param(is, motlu, nproc, "bad nproc parameter");
+                  read_keyword(is, nomlu, motlu);
+                  read_string_param(is, nomlu, file_decal_faces, "bad decalage file parameter");
+                  Journal(verb_level+1) << " decal_faces " << nproc;
+                }
+              else
+                break;
+              Journal(verb_level+1) << " " << motlu << endl;
+            }
+          som.datatype_ = default_type_float();
+          LataDBField elem(som);
+          elem.size_ = nb_elem;
+          elem.datatype_ = default_type_int_;
+          LataDBField faces(elem); // copy filename_
+          faces.size_ = nb_faces;
+          LataDBField elem_faces(elem);
+          elem_faces.size_ = nb_elem;
+          elem.name_ = "ELEMENTS";
+          faces.name_ = "FACES";
+          elem_faces.name_ = "ELEM_FACES";
+          elem.geometry_ = dom.name_;
+          faces.geometry_ = dom.name_;
+          elem_faces.geometry_ = dom.name_;
+
+          if (som.size_ < 0 || elem.size_ < 0)
+            {
+              Journal() << "Error reading Geometry: missing or bad nb_som_tot or nb_elem_tot parameter" << endl;
+              throw(LataDBError(LataDBError::READ_ERROR));
+            }
+          if (dom.elem_type_ == "")
+            {
+              Journal() << "Error reading Geometry: missing type_elem parameter" << endl;
+              throw(LataDBError(LataDBError::READ_ERROR));
+            }
+          get_element_data(dom.elem_type_, som.nb_comp_, elem.nb_comp_, faces.nb_comp_, elem_faces.nb_comp_);
+
+          // Add domain and som which are complete. We need the "som" to be in the database
+          //  for the "old lata 2D hack" in read_data2_()
+          add(timesteps_.size() - 1, dom);
+          add(timesteps_.size() - 1, som);
+          // Parse the geometry file to find file_offsets
+          {
+            Journal(verb_level) << " Parsing geometry file to find file offset of data blocs" << endl;
+            LataDataFile f(internal_data_buffer_, path_prefix_, som.filename_,som.datatype_.msb_);
+            BigTIDTab * null = nullptr; // Null pointer => don't actually read the data
+            read_data2_(f, som, null);
+            elem.datatype_.file_offset_ = f.position();
+            Journal(verb_level+1) << "  elements at file offset " << elem.datatype_.file_offset_ << endl;
+            if (faces.size_ >= 0)
+              {
+                read_data2_(f, elem, null);
+                faces.datatype_.file_offset_ = f.position();
+                Journal(verb_level+1) << "  faces at file offset " << faces.datatype_.file_offset_ << endl;
+                read_data2_(f, faces, null);
+                elem_faces.datatype_.file_offset_ = f.position();
+                Journal(verb_level+1) << "  elem_faces at file offset " << elem_faces.datatype_.file_offset_ << endl;
+              }
+          }
+
+          add(timesteps_.size() - 1, elem);
+          if (faces.size_ >= 0)
+            {
+              Journal(verb_level+1) << " Adding FACES and ELEM_FACES " << faces.size_ << endl;
+              add(timesteps_.size() - 1, faces);
+              add(timesteps_.size() - 1, elem_faces);
+            }
+          if (nproc > -1)
+            {
+              LataDBField joint(elem);
+              joint.datatype_.file_offset_ = 0;
+              joint.size_ = nproc;
+              joint.nb_comp_ = 2;
+              joint.reference_ = "";
+              joint.name_ = "JOINTS_SOMMETS";
+              joint.filename_ = file_decal_som;
+              add(timesteps_.size() - 1, joint);
+              joint.reference_ = "";
+              joint.name_ = "JOINTS_ELEMENTS";
+              joint.filename_ = file_decal_elem;
+              add(timesteps_.size() - 1, joint);
+              if (file_decal_faces != "??")
+                {
+                  joint.reference_ = "";
+                  joint.name_ = "JOINTS_FACES";
+                  joint.filename_ = file_decal_faces;
+                  add(timesteps_.size() - 1, joint);
+                }
+            }
+        }
+      else if (motlu == "Champ")
+        {
+          LataDBField field;
+          field.datatype_ = default_type_float();
+          is >> field.name_;
+          check(is, "failed reading field name");
+          Journal(verb_level) << "Reading field " << field.name_ << endl;
+          Nom n;
+          is >> n;
+          check(is, "failed reading field filename");
+          field.filename_ = n;
+          Journal(verb_level+1) << " filename=" << n << endl;
+
+          if ((field.name_ == "INTERFACES" || field.name_ == "PARTICULES") && old_style_lata_)
+            {
+              // This is the old dirty syntax for moving meshes
+
+              Journal(verb_level+1) << " Parsing an oldstyle interface file" << endl;
+              // Open the file and read the content
+              try
+                {
+                  LataDBDataType::MSB msb = default_type_int_.msb_;
+                  LataDataFile f(internal_data_buffer_, path_prefix_, field.filename_,msb);
+
+                  LataDBDataType::Type int_type = default_type_int_.type_;
+                  LataDBDataType::Type float_type = default_float_type_;
+                  LataDBGeometry dom;
+                  dom.timestep_ = timesteps_.size()-1;
+                  dom.name_ = field.name_;
+                  LataDBField som;
+                  som.name_ = "SOMMETS";
+                  som.filename_ = field.filename_;
+                  som.geometry_ = field.name_;
+                  som.datatype_ = default_type_float();
+                  som.datatype_.fortran_bloc_markers_ = LataDBDataType::NO_BLOC_MARKER;
+                  ArrOfTID tmptab(2);
+                  bloc_read(f, msb, int_type, tmptab);
+                  som.nb_comp_ = (int)tmptab[0]; // dimension
+                  som.size_ = tmptab[1]; // nb nodes
+                  Journal(verb_level+1) << " Nb nodes=" << som.size_ << " dimension=" << som.nb_comp_ << endl;
+                  som.datatype_.file_offset_ = f.position();
+                  bloc_read_skip(f, msb, float_type, som.size_ * som.nb_comp_);
+                  LataDBField elem;
+                  elem.name_ = "ELEMENTS";
+                  elem.filename_ = field.filename_;
+                  elem.geometry_ = field.name_;
+                  elem.datatype_ = default_type_int_;
+                  elem.datatype_.fortran_bloc_markers_ = LataDBDataType::NO_BLOC_MARKER;
+                  elem.datatype_.array_index_ = LataDBDataType::C_INDEXING;
+                  bloc_read(f, msb, int_type, tmptab);
+                  elem.nb_comp_ = (int)tmptab[0];
+                  elem.size_ = tmptab[1];
+                  Journal(verb_level+1) << " Nb elements=" << elem.size_ << " shape=" << elem.nb_comp_ << endl;
+                  if (field.name_ == "PARTICULES")
+                    {
+                      // Special case for front-tracking markers
+                      Journal(verb_level+1) << " PARTICULES: element type = point" << endl;
+                      dom.elem_type_ = "POINT";
+                    }
+                  else
+                    {
+                      if (elem.nb_comp_ == 2)
+                        dom.elem_type_ = "SEGMENT";
+                      else if (elem.nb_comp_ == 3)
+                        dom.elem_type_ = "TRIANGLE_3D";
+                      else
+                        {
+                          Journal() << "Error reading an interface: invalid element shape " << elem.nb_comp_ << endl;
+                          throw(LataDBError(LataDBError::READ_ERROR));
+                        }
+                    }
+                  elem.datatype_.file_offset_ = f.position();
+                  bloc_read_skip(f, msb, int_type, elem.size_ * elem.nb_comp_);
+                  add(timesteps_.size() - 1, dom);
+                  add(timesteps_.size() - 1, som);
+                  add(timesteps_.size() - 1, elem);
+                  // Read components:
+                  ArrOfInt tmptab2(1);
+                  while(1)
+                    {
+                      LataDBField fieldbis;
+                      f.set_encoding(msb, int_type);
+                      f.set_exception(0);
+                      f >> fieldbis.localisation_;
+                      f.set_exception(1);
+                      if (fieldbis.localisation_ == "")
+                        break;
+                      fieldbis.filename_ = som.filename_;
+                      fieldbis.geometry_ = som.geometry_;
+                      fieldbis.datatype_ = som.datatype_;
+                      tmptab2.resize_array(1);
+                      bloc_read(f, msb, int_type, tmptab2);
+                      fieldbis.nb_comp_ = tmptab2[0];
+                      if (fieldbis.nb_comp_ == som.nb_comp_)
+                        fieldbis.nature_ = LataDBField::VECTOR;
+                      else
+                        fieldbis.nature_ = LataDBField::SCALAR;
+                      f >> fieldbis.name_;
+                      if (fieldbis.localisation_ == "SOM")
+                        {
+                          fieldbis.size_ = som.size_;
+                        }
+                      else
+                        {
+                          fieldbis.size_ = elem.size_;
+                        }
+                      Journal(verb_level+1) << " Interface field " << fieldbis.localisation_ << " "
+                                            << fieldbis.name_ << endl;
+                      fieldbis.datatype_.file_offset_ = f.position();
+                      bloc_read_skip(f, msb, float_type, fieldbis.size_ * fieldbis.nb_comp_);
+                      add(timesteps_.size() - 1, fieldbis);
+                    }
+                }
+              catch (LataDBError& err)
+                {
+                  // If file is missing, issue the "missing file" message and continue
+                  if (err.err_ != LataDBError::FILE_NOT_FOUND)
+                    throw;
+                  else
+                    interface_file_not_found=true;
+                }
+              // Read next keyword:
+              read_keyword(is, nomlu, motlu);
+            }
+          else
+            {
+              if (old_style_lata_)
+                {
+                  // Old (legacy) syntax for champs: we must guess the properties from the filename!
+
+                  field.datatype_ = default_type_float();
+                  // Extract other data from filename (nb_comp_, localisation_, etc)
+                  // find geometry name
+                  Noms dom_names = geometry_names(0 /* timestep */);
+                  const int nb_geom = dom_names.size();
+                  int i;
+                  for (i = 0; i < nb_geom; i++)
+                    {
+                      Nom testname(".");
+                      testname += dom_names[i];
+                      testname += ".";
+                      if (Motcle(n).find(testname)>=0)
+                        break;
+                    }
+                  if (i == nb_geom)
+                    {
+                      Journal() << "Error in LataDB_V1::read_master_file: could not find domain for Champ " << n << endl;
+                      throw(LataDBError(LataDBError::READ_ERROR));
+                    }
+                  Journal(verb_level+1) << " geometry=" << dom_names[i] << endl;
+                  const LataDBGeometry& dom = get_geometry(0, dom_names[i]);
+                  field.geometry_ = dom_names[i];
+                  lata_v1_get_localisation(n, field.localisation_);
+                  Journal(verb_level+1) << " localisation=" << field.localisation_ << endl;
+                  const LataDBField& sommets = get_field(0 /* timestep */, dom_names[i], "SOMMETS", "*");
+                  const int dim = sommets.nb_comp_;
+                  field.nb_comp_ = lata_v1_get_nb_comp(field.name_, field.localisation_, dom, dim, field.nature_, field.datatype_.data_ordering_);
+                  Journal(verb_level+1) << " composantes=" << field.nb_comp_ << endl;
+                  if (field.localisation_.debute_par("SOM"))
+                    field.size_ = sommets.size_;
+                  else if (field.localisation_.debute_par("ELEM"))
+                    field.size_ = get_field(0 /* timestep */, dom_names[i], "ELEMENTS", "*").size_;
+                  else if (field.localisation_.debute_par("FACE"))
+                    field.size_ = get_field(0 /* timestep */, dom_names[i], "FACES", "*").size_;
+                  else
+                    {
+                      Journal() << "Error in LataDB_V1::read_master_file: invalid localisation "
+                                << field.localisation_ << endl;
+                      throw(LataDBError(LataDBError::READ_ERROR));
+                    }
+                  // Read next keyword:
+                  read_keyword(is, nomlu, motlu);
+                }
+              else
+                {
+                  // NEW LATAV2 SYNTAX for fields
+                  // The default data type is "float_"
+                  field.datatype_ = default_type_float();
+                  field.size_ = -1;
+                  while(1)
+                    {
+                      read_keyword(is, nomlu, motlu);
+                      if (motlu.debute_par("geometrie="))
+                        {
+                          read_string_param(is, nomlu, field.geometry_, "error reading geometrie parameter");
+                          // Check that the geometry exists
+                          get_geometry(timesteps_.size() - 1, field.geometry_, FIRST_AND_CURRENT);
+                        }
+                      else if (motlu.debute_par("composantes="))
+                        {
+                          LataDBInt32 nc;
+                          read_int_param(is, motlu, nc, "bad composantes parameter");
+                          field.nb_comp_ = (int)nc;
+                        }
+                      else if (motlu.debute_par("localisation="))
+                        {
+                          read_string_param(is, motlu, field.localisation_, "error reading localisation parameter");
+                        }
+                      else if (motlu.debute_par("format="))
+                        {
+                          LataDBDataType::Type tmp_int_type; // Unused
+                          LataDBDataType::Type tmp_float_type; // unused
+                          read_format_string(motlu, field.datatype_, tmp_int_type, tmp_float_type);
+                        }
+                      else if (motlu.debute_par("size="))
+                        {
+                          read_tid_param(is, motlu, field.size_, "error reading size parameter");
+                        }
+                      else if (motlu.debute_par("file_offset="))
+                        {
+                          read_long_param(is, motlu, field.datatype_.file_offset_, "error reading file offset parameter");
+                        }
+                      else if (motlu.debute_par("nature="))
+                        {
+                          Motcle nat;
+                          read_string_param(is, motlu, nat, "error reading nature parameter");
+                          if (nat.find("SCALAR")>=0)
+                            field.nature_ = LataDBField::SCALAR;
+                          else if (nat.find("VECTOR")>=0)
+                            field.nature_ = LataDBField::VECTOR;
+                          else
+                            {
+                              Journal() << "Error in LataDB_V1::read_master_file: invalid nature "
+                                        << nat << endl;
+                              throw(LataDBError(LataDBError::READ_ERROR));
+                            }
+                        }
+                      else if (motlu.debute_par("reference="))
+                        {
+                          Nom ref;
+                          read_string_param(is, motlu, ref, "error reading reference parameter");
+                          field.reference_ = ref;
+                        }
+                      else if (motlu.debute_par("noms_compo="))
+                        {
+                          Noms ref;
+                          read_noms_param(is, motlu, ref, "error reading noms_compo");
+                          Journal(verb_level+1)<<"noms_compos pas interprete "<<motlu<<endl;
+                        }
+                      else
+                        break;
+                      Journal(verb_level+1) << " " << motlu << endl;
+                    }
+                  if (field.size_ < 0)
+                    {
+                      // This is untested. Deactivate for the moment.
+                      //              Journal(verb_level) << " No size parameter given. Take size of the localisation field: ";
+                      // if (field_exists(timesteps_.size() - 1, field.geometry_, field.localisation_, FIRST_AND_CURRENT)) {
+                      // field.size_ = get_field(timesteps_.size() - 1, field.geometry_, field.localisation_, FIRST_AND_CURRENT).size_;
+                      // } else {
+                      Journal() << " Error, no size parameter for field " << field.name_ << " and localisation " << field.localisation_
+                                << " does not match any existing field" << endl;
+                      throw(LataDBError(LataDBError::READ_ERROR));
+                      // }
+                    }
+                }
+              add(timesteps_.size() - 1, field);
+            }
+        }
+      else if (motlu == "import_file")
+        {
+          // Load another lata master file recursively and merge timesteps
+          Nom filenamebis;
+          is >> filenamebis; // Read filename (without prefix)
+          LataDB newdb;
+          Nom filename2(prefix);
+          filename2 += filenamebis;
+          Journal(verb_level) << "Importing another lata database from file: " << filename << endl;
+          newdb.read_master_file(prefix, filename2);
+        }
+      else
+        {
+          Journal() << "Error: unknown keyword: " << motlu << endl;
+          throw(LataDBError(LataDBError::READ_ERROR));
+        }
+    }
+  if (interface_file_not_found)
+    throw LataDBError(LataDBError::FILE_NOT_FOUND);
+}
+
+// Read field data from file f into data array "data".
+//  If data is a null pointer, just skip the data bloc and leave the file pointer
+//  at the beginning of the next data bloc (used to parse the geometry file if file_offset
+//  are not specified in the lata master file)
+template <class C_Tab>
+void LataDB::read_data2_(LataDataFile& f, const LataDBField& fld,
+                         C_Tab * const data, // const pointer to non const data !
+                         Size_t debut, Size_t n, const BigArrOfTID *lines_to_read) const
+{
+
+  if (is_med(fld.filename_))
+    {
+      assert(lines_to_read == nullptr);
+      read_data2_med_(fld,data, debut,n);
+      return;
+    }
+  if (is_fort21(fld.filename_))
+    {
+      assert(lines_to_read == nullptr);
+      int is_read =read_data2_fort21_(f,fld,data, debut,n);
+      if (is_read) return;
+    }
+  // Si file_offset_ vaut 0 on y va car on peut avoir lu a un autre endroit avant.
+  if (fld.datatype_.file_offset_ >= 0)
+    {
+      Journal(verb_level_data_bloc+1) << " Seeking at position " << fld.datatype_.file_offset_ << endl;
+      f.seek(fld.datatype_.file_offset_, LataDataFile::ABSOLUTE);
+    }
+  if (n < 0)
+    {
+      if (lines_to_read)
+        n = lines_to_read->size_array();
+      else
+        n = fld.size_;
+    }
+
+  // The assert below is only useful in 32b, where Size_t is 64b, but trustIdType is 32b. Still even then, it should always be
+  // the case (checking that: 1. we are not in LATATOOLS, 2. we have not opened a 64b file with a 32b exec)
+  assert(n < std::numeric_limits<trustIdType>::max());
+  trustIdType n_tid = (trustIdType)n;
+
+  // in old lata format, 2d data is written as 3d:
+  // Yeah: dirty specs make dirty code...
+  Size_t size_in_file = fld.size_;
+  int nb_comp_in_file = fld.nb_comp_;
+  // int old_lata_hack = 0;
+  if (old_style_lata_ && (Motcle(fld.geometry_) != "INTERFACES") && (Motcle(fld.geometry_) != "PARTICULES"))
+    {
+      const LataDBField& som = get_field(0, fld.geometry_, "SOMMETS", "*");
+      if (som.nb_comp_ == 2)
+        {
+          //old_lata_hack = 1;
+          if (fld.name_ == "ELEMENTS")
+            {
+              nb_comp_in_file *= 2;
+            }
+          else if (fld.name_ == "SOMMETS")
+            {
+              nb_comp_in_file = 3; // all coordinates in 3D
+              size_in_file *= 2;
+            } // else if (fld.localisation_.debute_par("SOM")) {
+          // size_in_file *= 2;
+          // }
+          Journal(verb_level_data_bloc+1) << "Old lata hack for 2D" << endl;
+        }
+    }
+
+  if (fld.nb_comp_ < 0 || fld.size_ < 0)
+    {
+      Journal() << "Error in LataDB::read_data_: nb_comp_ or size_ not initialized for component " << fld.name_ << endl;
+      throw;
+    }
+
+  if ((!lines_to_read) && (debut < 0 || debut + n > fld.size_))
+    {
+      Journal() << "Error in LataDB::read_data_: [debut,debut+n] invalid range (size=" << fld.size_ << ")" << endl;
+      throw;
+    }
+
+  if (data)
+    data->resize(n_tid, nb_comp_in_file);
+
+  switch (fld.datatype_.data_ordering_)
+    {
+    case LataDBDataType::C_ORDERING:
+      // data written like this: tab(0,0) tab(0,1) tab(0,2) ... tab(1,0) tab(1,1) tab(1,2) ...
+      if (fld.datatype_.fortran_bloc_markers_ == LataDBDataType::BLOC_MARKERS_MULTIPLE_WRITES)
+        {
+          Journal() << "Error in LataDB::read_data_: fortran_bloc_markers_=MULTIPLE_WRITES is incompatible with data_ordering=C" << endl;
+          throw LataDBError(LataDBError::DATA_ERROR);
+        }
+      skip_blocksize(f, fld.datatype_);
+      if (data)
+        {
+          if (!lines_to_read)
+            {
+              bloc_read_skip(f, fld.datatype_.msb_, fld.datatype_.type_, debut * nb_comp_in_file);
+              bloc_read(f, fld.datatype_.msb_, fld.datatype_.type_, *data);
+              bloc_read_skip(f, fld.datatype_.msb_, fld.datatype_.type_, (size_in_file - debut - n) * nb_comp_in_file);
+            }
+          else
+            {
+              C_Tab tmp;
+              // Read 1024 lines chunks at a time even if only some values are needed inside
+              Size_t chunk_size = 0;
+              Size_t current_chunk_pos = 0;
+              Size_t current_file_pos = 0;
+              const trustIdType nl = lines_to_read->size_array();
+              for (trustIdType i = 0; i < nl; i++)
+                {
+                  const trustIdType next_line = (*lines_to_read)[i];
+                  // Is this line in the current chunk ?
+                  if (next_line >= current_chunk_pos + chunk_size)
+                    {
+                      // No => read the chunk containing this line
+                      chunk_size = size_in_file - next_line;
+                      if (chunk_size > 1024)
+                        chunk_size = 1024;
+                      tmp.resize((int)chunk_size, nb_comp_in_file);
+                      bloc_read_skip(f, fld.datatype_.msb_, fld.datatype_.type_, (next_line - current_file_pos) * nb_comp_in_file);
+                      bloc_read(f, fld.datatype_.msb_, fld.datatype_.type_, tmp);
+                      current_chunk_pos = next_line;
+                      current_file_pos = next_line + chunk_size;
+                    }
+                  // Extract data from tmp array
+                  const Size_t tmp_index0 = next_line - current_chunk_pos;
+                  assert(tmp_index0 < std::numeric_limits<trustIdType>::max());  // See similar check above
+                  const trustIdType tmp_index = (trustIdType)tmp_index0;
+                  for (int j = 0; j < nb_comp_in_file; j++)
+                    (*data)(i, j) = tmp(tmp_index, j);
+                }
+              if (current_file_pos != size_in_file)
+                bloc_read_skip(f, fld.datatype_.msb_, fld.datatype_.type_, (size_in_file - current_file_pos) * nb_comp_in_file);
+            }
+        }
+      else
+        {
+          // just skip the data
+          bloc_read_skip(f, fld.datatype_.msb_, fld.datatype_.type_, size_in_file *  nb_comp_in_file);
+        }
+      skip_blocksize(f, fld.datatype_);
+      break;
+    case LataDBDataType::F_ORDERING:
+      {
+        // data written like this: tab(0,0) tab(1,0) tab(2,0) ... tab(0,1) tab(1,1) tab(2,1) ... tab(0,2) tab(1,2) tab(2,2) ...
+        int multiple_bloc_markers = (fld.datatype_.fortran_bloc_markers_ == LataDBDataType::BLOC_MARKERS_MULTIPLE_WRITES);
+        // reverse rows and columns of the array
+        C_Tab tmp;
+        if (!multiple_bloc_markers)
+          skip_blocksize(f, fld.datatype_);
+        for (int i = 0; i < nb_comp_in_file; i++)
+          {
+            if (multiple_bloc_markers)
+              skip_blocksize(f, fld.datatype_);
+            if (data)
+              {
+                if (!lines_to_read)
+                  {
+                    tmp.resize(n_tid, 1);
+                    bloc_read_skip(f, fld.datatype_.msb_, fld.datatype_.type_, debut);
+                    bloc_read(f, fld.datatype_.msb_, fld.datatype_.type_, tmp);
+                    bloc_read_skip(f, fld.datatype_.msb_, fld.datatype_.type_, size_in_file - debut - n);
+                    for (trustIdType j = 0; j < n_tid; j++)
+                      (*data)(j, i) = tmp(j, 0);
+                  }
+                else
+                  {
+                    // Read 1024 lines chunks at a time even if only some values are needed inside
+                    Size_t chunk_size = 0;
+                    Size_t current_chunk_pos = 0;
+                    Size_t current_file_pos = 0;
+                    const trustIdType nl = lines_to_read->size_array();
+                    for (trustIdType j = 0; j < nl; j++)
+                      {
+                        const trustIdType next_line = (*lines_to_read)[j];
+                        // Is this line in the current chunk ?
+                        if (next_line >= current_chunk_pos + chunk_size)
+                          {
+                            // No => read the chunk containing this line
+                            chunk_size = size_in_file - next_line;
+                            if (chunk_size > 1024)
+                              chunk_size = 1024;
+                            tmp.resize((int)chunk_size, 1);
+                            bloc_read_skip(f, fld.datatype_.msb_, fld.datatype_.type_, (next_line - current_file_pos));
+                            bloc_read(f, fld.datatype_.msb_, fld.datatype_.type_, tmp);
+                            current_chunk_pos = next_line;
+                            current_file_pos = next_line + chunk_size;
+                          }
+                        // Extract data from tmp array
+                        const Size_t tmp_index0 = next_line - current_chunk_pos;
+                        assert(tmp_index0 < std::numeric_limits<trustIdType>::max());  // See similar check above
+                        const trustIdType tmp_index = (trustIdType)tmp_index0;
+                        (*data)(j, i) = tmp(tmp_index, 0);
+                      }
+                    if (current_file_pos != size_in_file)
+                      bloc_read_skip(f, fld.datatype_.msb_, fld.datatype_.type_, (size_in_file - current_file_pos));
+                  }
+              }
+            else
+              {
+                bloc_read_skip(f, fld.datatype_.msb_, fld.datatype_.type_, size_in_file);
+              }
+            if (multiple_bloc_markers)
+              skip_blocksize(f, fld.datatype_);
+          }
+        if (!multiple_bloc_markers)
+          skip_blocksize(f, fld.datatype_);
+        break;
+      }
+    default:
+      Journal() << "Error in LataDB::read_data_: data_ordering not implemented" << endl;
+      throw;
+    }
+
+  // old lata 2d hack :
+  if (data && nb_comp_in_file != fld.nb_comp_)
+    {
+      // drop column in data array
+      C_Tab tmp(*data);
+      data->resize(n_tid, fld.nb_comp_);
+      for (trustIdType i = 0; i < n_tid; i++)
+        for (int j = 0; j < fld.nb_comp_; j++)
+          (*data)(i,j) = tmp(i,j);
+    }
+}
+
+// Description:
+//  Read n * fld.nb_comp_ values in the file filename_, starting from debut * fld.nb_comp_
+template <typename C_Tab>
+void LataDB::read_data_(const LataDBField& fld, C_Tab& data, Size_t debut, Size_t n) const
+{
+  Journal(verb_level_data_bloc) << "LataDB::read_data(" << fld.timestep_ << "," << fld.uname_
+                                << ") Reading " << path_prefix_ << fld.filename_ << " start at " << debut << " size "
+                                << n << endl;
+
+  LataDataFile f(internal_data_buffer_, path_prefix_, fld.filename_,fld.datatype_.msb_);
+  read_data2_(f, fld, &data, debut, n);
+
+}
+
+// Description:
+//  Read n * fld.nb_comp_ values in the file filename_, starting from debut * fld.nb_comp_
+template <class C_Tab>
+void LataDB::read_data_(const LataDBField& fld, C_Tab& data, const BigArrOfTID& lines_to_read) const
+{
+  Journal(verb_level_data_bloc) << "LataDB::read_data(" << fld.timestep_ << "," << fld.uname_
+                                << ") Reading " << path_prefix_ << fld.filename_ << ",  " << lines_to_read.size_array() << " non contiguous lines"
+                                << endl;
+
+  LataDataFile f(internal_data_buffer_, path_prefix_, fld.filename_,fld.datatype_.msb_);
+  read_data2_(f, fld, &data, -1, -1, &lines_to_read);
+}
+
+// Description: reads n * nb_comp values in the file filename_ starting from debut*nb_comp_
+//  If array_index is F_STYLE, substract 1 to all values.
+void LataDB::read_data(const LataDBField& fld, BigIntTab& data, Size_t debut, Size_t n) const
+{
+  read_data_(fld, data, debut, n);
+  if (fld.datatype_.array_index_ == LataDBDataType::F_INDEXING)
+    {
+      BigIntTab& data2 = data;
+      const trustIdType n2 = data2.size_array();
+      for (trustIdType i = 0; i < n2; i++)
+        data2[i]--;
+    }
+}
+
+#if INT_is_64_ == 2
+void LataDB::read_data(const LataDBField& fld, BigTIDTab& data, Size_t debut, Size_t n) const
+{
+  read_data_(fld, data, debut, n);
+  if (fld.datatype_.array_index_ == LataDBDataType::F_INDEXING)
+    {
+      BigTIDTab& data2 = data;
+      const trustIdType n2 = data2.size_array();
+      for (trustIdType i = 0; i < n2; i++)
+        data2[i]--  ;
+    }
+}
+#endif
+
+// Description: reads n * nb_comp values in the file filename_ starting from debut*nb_comp_
+void LataDB::read_data(const LataDBField& fld, BigDoubleTab& data, Size_t debut, Size_t n) const
+{
+  Journal() << "LataDB::read_data not coded for double" << endl;
+  throw;
+}
+
+void LataDB::read_data(const LataDBField& fld, BigFloatTab& data, Size_t debut, Size_t n) const
+{
+  read_data_(fld, data, debut, n);
+}
+
+// Description: reads lines_to_read.size_array() * nb_comp values.
+//  If array_index is F_STYLE, substract 1 to all values.
+void LataDB::read_data(const LataDBField& fld, BigIntTab& data, const BigArrOfTID& lines_to_read) const
+{
+  read_data_(fld, data, lines_to_read);
+  if (fld.datatype_.array_index_ == LataDBDataType::F_INDEXING)
+    {
+      BigIntTab& data2 = data;
+      const trustIdType n = data2.size_array();
+      for (trustIdType i = 0; i < n; i++)
+        data2[i]--;
+    }
+}
+
+#if INT_is_64_ == 2
+void LataDB::read_data(const LataDBField& fld, BigTIDTab& data, const BigArrOfTID& lines_to_read) const
+{
+  read_data_(fld, data, lines_to_read);
+  if (fld.datatype_.array_index_ == LataDBDataType::F_INDEXING)
+    {
+      BigTIDTab& data2 = data;
+      const trustIdType n = data2.size_array();
+      for (trustIdType i = 0; i < n; i++)
+        data2[i]--;
+    }
+}
+#endif
+
+// Description: reads lines_to_read.size_array() * nb_comp values.
+void LataDB::read_data(const LataDBField& fld, BigDoubleTab& data, const BigArrOfTID& lines_to_read) const
+{
+  Journal() << "LataDB::read_data not coded for double" << endl;
+  throw;
+}
+
+// Description: reads lines_to_read.size_array() * nb_comp values.
+void LataDB::read_data(const LataDBField& fld, BigFloatTab& data, const BigArrOfTID& lines_to_read) const
+{
+  read_data_(fld, data, lines_to_read);
+}
+
+
+// Description: copy the source LataDB object, keeping only timesteps, geometries and fields
+//  that are specified (timestep 0 is always included, do not put it in the list).
+//  field_nms can contain field.name_ (like VITESSE), or extended name with localisation
+//  (like VITESSE_ELEM)
+void LataDB::filter_db(const LataDB& source, const Noms& geometry_nms,
+                       const Motcles& field_nms, const ArrOfInt& timesteps)
+{
+  path_prefix_ = source.path_prefix_;
+  header_ = source.header_;
+  case_ = source.case_;
+  software_id_ = source.software_id_;
+  old_style_lata_ = source.old_style_lata_;
+  default_type_int_ = source.default_type_int_;
+  default_float_type_ = source.default_float_type_;
+
+  const int nb_tsteps = timesteps.size_array();
+  for (int it = 0; it < nb_tsteps + 1; it++)
+    {
+      int src_tstep = 0;
+      if (it > 0)
+        src_tstep = timesteps[it-1];
+      LataDBTimestep& tstep = timesteps_.add(LataDBTimestep());
+      tstep.time_ = source.get_time(src_tstep);
+      // Copy geometries
+      const Noms& geoms = source.geometry_names(src_tstep);
+      int ig;
+      for (ig = 0; ig < geoms.size(); ig++)
+        if (geometry_nms.rang(geoms[ig]) >= 0)
+          tstep.geoms_.add(source.get_geometry(src_tstep, geoms[ig]));
+      // Copy fields
+      const Noms& geoms2 = geometry_names(nb_timesteps()-1, FIRST_AND_CURRENT);
+
+      for (ig = 0; ig < geoms2.size(); ig++)
+        {
+          LataVector<Field_UName> unames = source.field_unames(src_tstep, geoms2[ig], "*");
+          for (int i_f = 0; i_f < unames.size(); i_f++)
+            {
+              const LataDBField& src = source.get_field(src_tstep, unames[i_f]);
+              Nom name_loc = src.name_;
+              name_loc += "_";
+              name_loc += src.localisation_;
+              if (field_nms.rang(src.name_) >= 0 || field_nms.rang(name_loc) >= 0)
+                tstep.fields_.add(src);
+            }
+        }
+    }
+}
+
+// Description: set the default value of the path prefix where write_data() will write the data
+// Warning: there is no check that the master lata file is actually written at the same place
+//  and that all the files and data blocks mentionned in the database actually exist.
+// For the file_offset_ field, -2 is considered "unknown".
+void LataDB::set_path_prefix(const char * s)
+{
+  path_prefix_ = s;
+}
+
+#define UPDATE_MACRO(x,unknown) if (((old_type.x==unknown)||(type.x==old_type.x))&&(new_type.x!=unknown)) type.x=new_type.x
+
+// Description: changes the data type of all fields in the database.
+//  The property "x" is changed to "new_type.x" if "new_type.x" is not "unknown"
+//  and if "old_type.x" is "unknown" or "equal to the previous property"
+// Example: convert all data to ASCII:
+//   LataDBDataType old_type; // All defaults to "unknown" => we update all fields
+//   LataDBDataType new_type;
+//   new_type.msb_ = LataDBDataType::ASCII; // Change msb_ property to ASCII:
+// Example 2: change all REAL32 data to REAL64
+//   LataDBDataType old_type;
+//   old_type.type_ = LataDBDataType::REAL32;
+//   LataDBDataType new_type;
+//   new_type.msb_ = LataDBDataType::REAL64;
+void LataDB::change_all_data_types(const LataDBDataType& old_type, const LataDBDataType& new_type)
+  {
+    const int nb_tsteps = timesteps_.size();
+    for (int src_tstep = 0; src_tstep < nb_tsteps; src_tstep++)
+      {
+        LataVector<LataDBField>& fields = timesteps_[src_tstep].fields_;
+        const int nb_fields = fields.size();
+        for (int i_field = 0; i_field < nb_fields; i_field++)
+          {
+            LataDBDataType& type = fields[i_field].datatype_;
+            // For each field, if "old_type" is "unknown" or equal to the previous value,
+            //  and if "new_type" is not "unknown, then update the field
+            UPDATE_MACRO(msb_, LataDBDataType::UNKNOWN_MSB);
+            UPDATE_MACRO(type_, LataDBDataType::UNKNOWN_TYPE);
+            UPDATE_MACRO(array_index_, LataDBDataType::UNKNOWN_ARRAYINDEX);
+            UPDATE_MACRO(data_ordering_, LataDBDataType::UNKNOWN_ORDERING);
+            UPDATE_MACRO(fortran_bloc_markers_, LataDBDataType::UNKNOWN_MARKERS);
+            UPDATE_MACRO(bloc_marker_type_, LataDBDataType::UNKNOWN_TYPE);
+          }
+      }
+  }
+#undef UPDATE_MACRO
+
+void LataDB::change_all_data_filenames(const Nom& old_prefix, const Nom& new_prefix)
+{
+  const int nb_tsteps = timesteps_.size();
+  for (int i = 0; i < nb_tsteps; i++)
+    {
+      LataVector<LataDBField>& fields = timesteps_[i].fields_;
+      // Browse all fields:
+      const int nb_fields = fields.size();
+      for (int j = 0; j < nb_fields; j++)
+        {
+          Nom& filename = fields[j].filename_;
+          Nom old_filename = filename;
+          filename = new_prefix;
+          if (old_filename.debute_par(old_prefix))
+            {
+              const int n = old_filename.longueur()-1;
+              const char * s = old_filename;
+              for (int ii = old_prefix.longueur()-1; ii < n; ii++)
+                filename += Nom(s[ii]);
+            }
+          else if (old_filename == LataDBField::memory_buffer_file())
+            {
+              filename += Nom(".data");
+            }
+          else
+            {
+              filename += Nom('_');
+              filename += old_filename;
+            }
+          Journal(verb_level+1) << " Changing filename " << old_filename << " -> " << filename << endl;
+        }
+    }
+}
+
+// This method takes all filenames mentionned in the database and sets the file_offset_ entry:
+//  - set to 0 for the first field where a given filename appears,
+//  - then for all subsequent files referring to the same name:
+//      If split_files != 0, rename the files by appending a "_number" and set file_offset to 0
+//      otherwise set file_offset_ to 1
+void LataDB::check_all_data_fileoffsets(bool split_files)
+{
+  Noms existing_filenames;
+  ArrOfInt counts; // For each filenames, number of fields referring to it
+
+  const int nb_tsteps = timesteps_.size();
+  for (int i = 0; i < nb_tsteps; i++)
+    {
+      LataVector<LataDBField>& fields = timesteps_[i].fields_;
+      // Browse all fields:
+      const int nb_fields = fields.size();
+      for (int j = 0; j < nb_fields; j++)
+        {
+          LataDBField& field = fields[j];
+          const int rank = existing_filenames.rang(field.filename_);
+          if (rank < 0)
+            {
+              // New filename
+              existing_filenames.add(field.filename_);
+              counts.append_array(1);
+              field.datatype_.file_offset_ = 0;
+              Journal(verb_level+1) << " Changing fileoffset to 0 for file " << field.filename_
+                                    << " " << field.name_ << endl;
+            }
+          else
+            {
+              // Existing filename
+              if (split_files)
+                {
+                  int n = counts[rank]++;
+                  field.filename_ += "_";
+                  field.filename_ += Nom(n);
+                  field.datatype_.file_offset_ = 0;
+                  Journal(verb_level+1) << " Changing fileoffset to 0 and renaming file " << field.filename_
+                                        << " " << field.name_ << endl;
+                }
+              else
+                {
+                  field.datatype_.file_offset_ = 1;
+                  Journal(verb_level+1) << " Changing fileoffset to 1 for file " << field.filename_
+                                        << " " << field.name_ << endl;
+                }
+            }
+        }
+    }
+}
+
+// Returns the rank of the created timestep (always at the end)
+int LataDB::add_timestep(double time)
+{
+  const int n = nb_timesteps();
+  // Timestep 0 can have any time: test only versus other timesteps:
+  if (n > 1 && time <= get_time(n-1))
+    {
+      Journal() << "Error in LataDB::add_timestep(" << time
+                << "): time is below or equal to last timestep " << get_time(n-1) << endl;
+      throw(LataDBError(LataDBError::INVALID_OPERATION));
+    }
+  LataDBTimestep& t = timesteps_.add(LataDBTimestep());
+  t.time_ = time;
+  Journal(verb_level+1) << "LataDB::add_timestep " << n << " " << time << endl;
+  return n;
+}
+
+static void add_geom_check(const LataDBGeometry& geom, int test_flag, const char *message)
+{
+  if (!test_flag)
+    {
+      Journal() << "Error in LataDB::add_geometry, name_=" << geom.name_ << endl
+                << " geometry data is invalid because of: " << message << endl;
+      throw(LataDBError(LataDBError::INVALID_OPERATION));
+    }
+}
+
+void LataDB::add_geometry(const LataDBGeometry& geom)
+{
+  add_geom_check(geom, geom.timestep_ >= 0 && geom.timestep_ < nb_timesteps(), "timestep");
+  Noms geoms= geometry_names(geom.timestep_, CURRENT);
+  add_geom_check(geom, geom.name_ != "" && geom.name_ != "??" && geoms.rang(geom.name_) < 0, "empty or already existing name");
+
+  add(geom.timestep_, geom);
+  Journal(verb_level+1) << "LataDB::add_geometry " << geom.name_ << endl;
+}
+
+void LataDB::set_elemtype(int tstep, const char *geom_name, const char *elem_type)
+{
+  LataDBGeometry& geom = (LataDBGeometry&) get_geometry(tstep, geom_name);
+  geom.elem_type_ = elem_type;
+}
+
+
+static void add_field_check(const LataDBField& field, int test_flag, const char *message)
+{
+  if (!test_flag)
+    {
+      Journal() << "Error in LataDB::add_field, name_=" << field.name_ << " geometry=" << field.geometry_ << endl
+                << " field data is invalid because of: " << message << endl;
+      throw(LataDBError(LataDBError::INVALID_OPERATION));
+    }
+}
+
+// Adds a new field to the database.
+// The field.datatype_.file_offset_ will be interpreted in a particular way if the data is
+//  written with write_data(), see write_data() documentation.
+// Take special care if the same file is referenced more than once in the database:
+//  only one file should have file_offset_ <= 0 and this one will have to be written first
+//  with write_data()  (or you know what you are doing...)
+void LataDB::add_field(const LataDBField& field)
+{
+  add_field_check(field, field.timestep_ >= 0 && field.timestep_ < nb_timesteps(), "timestep");
+  add_field_check(field, field.filename_ != "" && field.filename_ != "??", "filename");
+  add_field_check(field, field.nb_comp_ > 0, "nb_comp");
+  Noms geoms = geometry_names(field.timestep_, FIRST_AND_CURRENT);
+  add_field_check(field, field.geometry_ == "" || geoms.rang(field.geometry_) >= 0, "unknown geometry name");
+  add_field_check(field, field.name_ != "" && field.name_ != "??", "empty name");
+  add_field_check(field, field.component_names_.size() == 0 || field.component_names_.size() == field.nb_comp_, "number of component_names");
+  add_field_check(field, field.size_ >= 0, "size");
+  add_field_check(field, field.datatype_.msb_ != LataDBDataType::UNKNOWN_MSB, "datatype msb unspecified");
+  add_field_check(field, field.datatype_.type_ == LataDBDataType::INT32
+                  || field.datatype_.type_ == LataDBDataType::INT64
+                  || field.datatype_.type_ == LataDBDataType::REAL32
+                  || field.datatype_.type_ == LataDBDataType::REAL64, "datatype type unspecified");
+  // If integer type, we must say the indexing type:
+  add_field_check(field,
+                  field.datatype_.type_ == LataDBDataType::REAL32
+                  || field.datatype_.type_ == LataDBDataType::REAL64
+                  || field.datatype_.array_index_ != LataDBDataType::UNKNOWN_ARRAYINDEX,
+                  "datatype array indexing unspecified");
+  add_field_check(field, field.datatype_.data_ordering_ != LataDBDataType::UNKNOWN_ORDERING, "datatype data ordering unspecified");
+  add_field_check(field, field.datatype_.fortran_bloc_markers_ != LataDBDataType::UNKNOWN_MARKERS, "datatype fortran bloc markers unspecified");
+  add_field_check(field, field.datatype_.file_offset_ >= 0, "datatype file_offset_");
+  // ouf...
+  add(field.timestep_, field);
+  Journal(verb_level+1) << "LataDB::add_field : " << field.name_ << " " << field.geometry_ << " " << field.filename_ << " " << field.uname_ << endl;
+}
+
+LataDBDataType LataDB::default_type_float() const
+{
+  LataDBDataType type = default_type_int_;
+  type.type_ = default_float_type_;
+  return type;
+}
+
+// Description: Writes the lata master file to filename (filename must contain the path
+//  if you don't want to write in the current working directory). All data contained
+//  in the database is dumped to the file.
+void LataDB::write_master_file(const char *filename) const
+{
+  if (!filename)
+    {
+      Journal() << "LataDB::write_master_file got a null filename !!!" << endl;
+      throw(LataDBError(LataDBError::INVALID_OPERATION));
+    }
+  std::ofstream os(filename);
+  if (!os.good())   // isnogood ?
+    {
+      Journal() << "LataDB::write_master_file failed opening file " << filename << endl;
+      throw(LataDBError(LataDBError::FILE_NOT_FOUND));
+    }
+  // Try to write, if error, catch and close the file:
+  Journal(verb_level-1) << "Writing lata master file:" << filename << endl;
+  os << "LATA_V2.1" << endl;
+  os << case_ << endl;
+  os << software_id_ << endl;
+
+  // ****************************************************************
+  // Writing data format information:
+  {
+    Motcle fmt, fmt2;
+    build_format_string(LataDBDataType(), default_type_int_, fmt);
+    build_format_string(default_type_int_, default_type_float(), fmt2);
+    os << "Format " << fmt << "," << fmt2 << endl;
+  }
+
+  // ***************************************************************
+  // Writing timesteps:
+  const int nb_tsteps = nb_timesteps();
+  for (int tstep = 0; tstep < nb_tsteps; tstep++)
+    {
+      if (tstep > 0)
+        os << "TEMPS " << get_time(tstep) << endl;
+
+      Noms geoms = geometry_names(tstep);
+      const int nb_geoms = geoms.size();
+      for (int i_geom = 0; i_geom < nb_geoms; i_geom++)
+        {
+          const LataDBGeometry& geom = get_geometry(tstep, geoms[i_geom], FIRST_AND_CURRENT);
+          // Do not write geometries of the first timestep
+          if (geom.timestep_ == tstep)
+            os << "GEOM  " << geom.name_ << " type_elem=" << geom.elem_type_ << endl;
+        }
+      Field_UNames unames = field_unames(tstep, "*", "*");
+      for (int i_field = 0; i_field < unames.size(); i_field++)
+        {
+          const LataDBField& field = get_field(tstep, unames[i_field]);
+          os << "CHAMP " << field.name_
+             << " " << field.filename_;
+          if (field.geometry_ != "")
+            os << " geometrie=" << field.geometry_;
+          os << " size=" << field.size_;
+          os << " composantes=" << field.nb_comp_;
+          if (field.localisation_ != "??" && field.localisation_ != "")
+            os << " localisation=" << field.localisation_;
+          if (field.component_names_.size() > 0)
+            {
+              os << " noms_compo=";
+              const int n = field.component_names_.size();
+              for (int i = 0; i < n; i++)
+                {
+                  os << field.component_names_[i];
+                  if (i < n-1)
+                    os << ",";
+                }
+            }
+          switch(field.nature_)
+            {
+            case LataDBField::UNKNOWN:
+              break;
+            case LataDBField::WALLSCALAR:
+            case LataDBField::SCALAR:
+              os << " nature=scalar";
+              break;
+            case LataDBField::VECTOR:
+              os << " nature=vector";
+              break;
+            default:
+              Journal() << "LataDB::write_master_file error: unknown NATURE" << endl;
+              throw(LataDBError(LataDBError::INVALID_OPERATION));
+            }
+          if (field.reference_ != "" && field.reference_ != "??")
+            os << " reference=" << field.reference_;
+          Motcle format_string;
+          build_format_string(default_type_float(), field.datatype_, format_string);
+          if (format_string != "")
+            os << " format=" << format_string;
+          if (field.datatype_.file_offset_ > 0)
+            os << " file_offset=" << field.datatype_.file_offset_;
+          os << endl;
+        }
+    }
+  os << "FIN" << endl;
+  write_master_file_to_call_ = false;
+}
+
+// Description: internal template to write a data block. We provide explicit methods write_data()
+//  to the user instead of a template.
+template <class C_Tab>
+Size_t LataDB::write_data_(int tstep, const Field_UName& uname, const C_Tab& data)
+{
+  using int_t = typename C_Tab::int_t;
+  LataDBField& fld = getset_field(tstep, uname);
+
+  LataDataFile f(internal_data_buffer_, path_prefix_, fld.filename_,
+                 fld.datatype_.msb_,
+                 (fld.datatype_.file_offset_ <= 0) ? LataDataFile::WRITE : LataDataFile::APPEND);
+  fld.datatype_.file_offset_ = f.position();
+  Journal(verb_level_data_bloc) << "Writing block data at offset " << fld.datatype_.file_offset_ << endl;
+  if (fld.nb_comp_ != data.dimension(1) || fld.size_ != data.dimension(0))
+    {
+      Journal() << "Error in LataDB::write_data_: nb_comp_ or size_ declared in the field doesnt match array dimensions." << fld.name_ << endl;
+      throw;
+    }
+
+  const trustIdType n = fld.size_;
+
+  switch (fld.datatype_.data_ordering_)
+    {
+    case LataDBDataType::C_ORDERING:
+      {
+        if (fld.datatype_.fortran_bloc_markers_ == LataDBDataType::BLOC_MARKERS_MULTIPLE_WRITES)
+          {
+            Journal() << "Error in LataDB::write_data_: fortran_bloc_markers_=MULTIPLE_WRITES is incompatible with data_ordering=C" << endl;
+            throw LataDBError(LataDBError::DATA_ERROR);
+          }
+        const int_t sz = data.size_array();
+        write_blocksize(f, fld.datatype_, sz);
+        bloc_write(f, fld.datatype_.msb_, fld.datatype_.type_, data, fld.nb_comp_);
+        write_blocksize(f, fld.datatype_, sz);
+        break;
+      }
+    case LataDBDataType::F_ORDERING:
+      {
+        int multiple_bloc_markers = (fld.datatype_.fortran_bloc_markers_ == LataDBDataType::BLOC_MARKERS_MULTIPLE_WRITES);
+        // reverse rows and columns of the array
+        C_Tab tmp;
+        tmp.resize(n, 1);
+        if (!multiple_bloc_markers)
+          write_blocksize(f, fld.datatype_, data.size_array());
+        for (int i = 0; i < fld.nb_comp_; i++)
+          {
+            if (multiple_bloc_markers)
+              write_blocksize(f, fld.datatype_, n);
+            for (trustIdType j = 0; j < n; j++)
+              tmp(j, 0) = data(j, i);
+            bloc_write(f, fld.datatype_.msb_, fld.datatype_.type_, tmp, 1);
+            if (multiple_bloc_markers)
+              write_blocksize(f, fld.datatype_, n);
+          }
+        if (!multiple_bloc_markers)
+          write_blocksize(f, fld.datatype_, data.size_array());
+        break;
+      }
+    default:
+      Journal() << "Error in LataDB::write_data_: data_ordering not implemented" << endl;
+      throw;
+    }
+  write_master_file_to_call_ = true;
+  return f.position();
+}
+
+// Writes the data to disk according to datatype_ of the field.
+// The filename will be "path_prefix_ + field.filename_".
+// The path_prefix_ can be changed with set_path_prefix()
+// If field.datatype_.file_offset_<=0, any existing file is deleted and the data is written at offset 0
+// otherwise the data is written at the end of the file and file_offset_ for this field is updated.
+// Returns the Size_t of the file pointer after writing the data (points to the end of the file)
+// The call to write_master_file() must be done after all write_data (otherwise the file_offset_ might be wrong)
+Size_t LataDB::write_data(int tstep, const Field_UName& uname, const BigDoubleTab& tab)
+{
+  Journal() << " LataDB::write_data not coded for double" << endl;
+  throw;
+}
+
+// See write_data(..., const DoubleTab &)
+Size_t LataDB::write_data(int tstep, const Field_UName& uname, const BigFloatTab& tab)
+{
+  return write_data_(tstep, uname, tab);
+}
+
+// See write_data(..., const DoubleTab &)
+Size_t LataDB::write_data(int tstep, const Field_UName& uname, const BigIntTab& tab)
+{
+  if (get_field(tstep, uname).datatype_.array_index_ == LataDBDataType::F_INDEXING)
+    {
+      BigIntTab tmp;
+      tmp.resize(tab.dimension(0), (int)tab.dimension(1));
+      BigArrOfInt& array = tmp;
+      const BigArrOfInt& src = tab;
+      for (trustIdType i = 0; i < array.size_array(); i++)
+        array[i] = src[i] + 1;
+      return write_data_(tstep, uname, tmp);
+    }
+
+  return write_data_(tstep, uname, tab);
+}
+
+#if INT_is_64_ == 2
+Size_t LataDB::write_data(int tstep, const Field_UName& uname, const BigTIDTab& tab)
+{
+  if (get_field(tstep, uname).datatype_.array_index_ == LataDBDataType::F_INDEXING)
+    {
+      BigTIDTab tmp;
+      tmp.resize(tab.dimension(0), (int)tab.dimension(1));
+      BigArrOfTID& array = tmp;
+      const BigArrOfTID& src = tab;
+      for (trustIdType i = 0; i < array.size_array(); i++)
+        array[i] = src[i] + 1;
+      return write_data_(tstep, uname, tmp);
+    }
+
+  return write_data_(tstep, uname, tab);
+}
+#endif
+
+LataDB::~LataDB()
+{
+  //clean map
+  if (basicmeshses_)
+    delete basicmeshses_;
+}
+
+const char *LataDBError::describe() const
+{
+  switch(err_)
+    {
+    case READ_ERROR:
+      return "READ_ERROR";
+    case BAD_HEADER:
+      return "BAD_HEADER";
+    case BAD_TIMESTEP:
+      return "BAD_TIMESTEP";
+    case NAME_NOT_FOUND:
+      return "NAME_NOT_FOUND";
+    case DATA_ERROR:
+      return "DATA_ERROR";
+    case FILE_NOT_FOUND:
+      return "FILE_NOT_FOUND";
+    case BAD_ELEM_TYPE:
+      return "BAD_ELEM_TYPE";
+    case INVALID_OPERATION:
+      return "INVALID_OPERATION";
+    case INTEGER_OVERFLOW:
+      return "INTEGER_OVERFLOW";
+    default:
+      ;
+    }
+  return "LataDB_unknown_error";
+}
+#undef verb_level
+#undef verb_level_data_bloc
diff --git a/Utilities/VisItBridge/databases/readers/Lata/LataDB.h b/Utilities/VisItBridge/databases/readers/Lata/LataDB.h
new file mode 100644
index 00000000..669e17b6
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/LataDB.h
@@ -0,0 +1,317 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef LataDB_include_
+#define LataDB_include_
+
+#include <LataTools.h>
+#include <TRUSTArray.h>
+#include <sstream>
+#include <map>
+#include <ReaderFORT21.h>
+
+// This file describes the LataDB class and all associated data structures.
+//  LataDB stores all the meta contained in the .lata master file, and not more.
+//  It provides services to add meta-data, read data to a user specified array,
+//  and write data to a lata file.
+
+
+// .Description: LataDBError is the type used for thrown exceptions in LataDBxxx classes
+class LataDBError
+{
+public:
+  // READ_ERROR: low level io error while reading .lata file
+  // BAD_HEADER: the header in the .lata file is not correct
+  // BAD_TIMESTEP: request for a non existant timestep
+  // NAME_NOT_FOUND: request for a non existant domain or field name
+  // DATA_ERROR: low level io error while reading a data bloc file
+  // FILE_NOT_FOUND: a file (.lata or data) couldn't be opened on disc.
+  // INVALID_OPERATION: trying to read from a modified database, etc...
+  // INTEGER_OVERFLOW: trying to convert an integer to a too small data type
+  //  (if error when reading a data file, you must recompile with typedef long long entier,
+  //   if error when writing a data file, you must use INT64 type_ for data blocks)
+  enum ErrType { READ_ERROR, BAD_HEADER, BAD_TIMESTEP, NAME_NOT_FOUND, DATA_ERROR,
+                 FILE_NOT_FOUND, BAD_ELEM_TYPE, INVALID_OPERATION, INTEGER_OVERFLOW
+               };
+  LataDBError(ErrType err) : err_(err) {};
+  ErrType err_;
+  const char *describe() const;
+};
+
+// .Description: This is the data type for a specific part of a data bloc.
+//  In order to read a data bloc, we need a LataDBDataType for the "bloc size" id (this is an integer),
+//  and a LataDBDataType for the bloc content. LataDBGeometry blocs need two types, one for
+//  the node coordinates and one for the elements
+class LataDBDataType
+{
+public:
+  enum MSB { UNKNOWN_MSB, MSB_BIG_ENDIAN, MSB_LITTLE_ENDIAN, ASCII };
+  MSB msb_;
+  enum Type { UNKNOWN_TYPE, INT32, INT64, REAL32, REAL64 };
+  Type type_;
+  // Array index is ignored if type_ is REAL.
+  // NOT_AN_INDEX: array does not contain indexes.
+  // C_INDEXING: If array contains indexes to other items, 0 <= array[i] < nb_items
+  // F_INDEXING: 1 <= array[i] <= nb_items (Fortran index)
+  // See LataDB::read_data
+  enum ArrayIndex { UNKNOWN_ARRAYINDEX, NOT_AN_INDEX, C_INDEXING, F_INDEXING };
+  ArrayIndex array_index_;
+  // C_ORDERING: If multidimensionnal array is read, data ordering is like in C
+  //               (all components for first node, then all components for second node, etc)
+  // F_ORDERING: like in fortran (first all values for component 0 then all values for compo 1 etc)
+  enum DataOrdering { UNKNOWN_ORDERING, C_ORDERING, F_ORDERING };
+  DataOrdering data_ordering_;
+
+  //   _NO_BLOC:         no fortran bloc marker
+  //   _SINGLE_WRITE:    all data written in one fortran write instruction
+  //   _MULTIPLE_WRITES: one fortran write instruction for each component
+  enum FortranBlocMarkers { UNKNOWN_MARKERS, NO_BLOC_MARKER, BLOC_MARKERS_SINGLE_WRITE, BLOC_MARKERS_MULTIPLE_WRITES };
+  FortranBlocMarkers fortran_bloc_markers_;
+
+  // The data type for fortran bloc markers
+  Type bloc_marker_type_;
+
+  // Data is located at this offset in the file
+  Size_t file_offset_;
+
+  LataDBDataType() : msb_(UNKNOWN_MSB), type_(UNKNOWN_TYPE), array_index_(UNKNOWN_ARRAYINDEX),
+    data_ordering_(UNKNOWN_ORDERING), fortran_bloc_markers_(UNKNOWN_MARKERS), bloc_marker_type_(UNKNOWN_TYPE),
+    file_offset_(0)
+  {};
+  static MSB machine_msb_;
+};
+
+// .Description: Description of a geometry (= a mesh)
+class LataDBGeometry
+{
+public:
+  LataDBGeometry() { timestep_ = -1; }
+  // Item name
+  Nom name_;
+  // Type of elements
+  Motcle elem_type_;
+  int timestep_;
+};
+
+// This is a unique identifier for fields
+//  at this time, contains domain name, field name and localisation,
+//  might be further extended if needed
+class Field_UName
+{
+public:
+  Field_UName();
+  Field_UName(const char *domain_name, const char *field_name, const char *loc);
+  Field_UName(const Field_UName&);
+  int operator==(const Field_UName&) const;
+  Field_UName& operator=(const Field_UName&);
+  Nom build_string() const;
+  const Motcle& get_localisation() const { return loc_; }
+  const Motcle& get_field_name() const { return field_name_; }
+  const Nom& get_geometry() const { return geometry_; }
+  void set_field_name(const Nom&);
+
+protected:
+  Nom geometry_;       // WARNING: geometry name might be lower-case e.g. 'dom'
+  Motcle field_name_;
+  Motcle loc_;
+};
+
+std::ostream& operator<<(std::ostream&, const Field_UName&);
+
+typedef LataVector<Field_UName> Field_UNames;
+class EFichier;
+
+// .Description: Description of a field
+class LataDBField
+{
+public:
+  LataDBField() { timestep_ = -1; nb_comp_ = -1; nature_ = UNKNOWN; size_ = -1; }
+
+  // Unique identifier
+  Field_UName uname_;
+  // Field name (without localisation spec)
+  Nom name_;
+  // Where is it ?
+  int timestep_;
+  // Filename containing the data
+  // Special names: memory_buffer_file() => data stored in the LataDB memory buffer.
+  Nom filename_;
+  // Number of components
+  int nb_comp_;
+  // LataDBGeometry
+  Nom geometry_;
+  // Name of the components
+  Noms component_names_;
+  Noms unites_;
+  // Scalar or vector ?
+  enum Nature { UNKNOWN, SCALAR, VECTOR, WALLSCALAR };
+  Nature nature_;
+  // Type and formatting info of the data
+  LataDBDataType datatype_;
+  // Localisation (elem, som, faces, ...)
+  Motcle localisation_;
+  // Ref
+  Nom reference_;
+  // Size (number of lines)
+  trustIdType size_;
+
+  static const char * memory_buffer_file();
+};
+
+// .Description: Description of one timestep (contains a vector of items)
+class LataDBTimestep
+{
+public:
+  LataDBTimestep() { time_ = -1.; }
+  double time_;
+
+protected:
+  friend class LataDB;
+  LataVector<LataDBGeometry> geoms_;
+  LataVector<LataDBField> fields_;
+};
+
+class LataDataFile;
+class MapBasicMesh;
+
+class LataDB
+{
+public:
+  LataDB() :
+     path_prefix_(""),
+     old_style_lata_(0),
+     write_master_file_to_call_(0),
+     internal_data_buffer_(std::ios::in | std::ios::out | std::ios::app | std::ios::binary),
+     basicmeshses_(nullptr)
+  {  }
+
+  LataDB(const LataDB& src) :
+    header_(src.header_),
+    case_(src.case_),
+    software_id_(src.software_id_),
+    default_type_int_(src.default_type_int_),
+    default_float_type_(src.default_float_type_),
+    timesteps_(src.timesteps_),
+    path_prefix_(src.path_prefix_),
+    old_style_lata_(src.old_style_lata_),
+    write_master_file_to_call_(src.write_master_file_to_call_),
+    basicmeshses_(nullptr)
+  {
+    // Note B.M. il faudrait copier internal_data_buffer_ pour faire marcher lml->lata mais je ne sais pas faire...
+  }
+  virtual ~LataDB();
+  void reset();
+  virtual void read_master_file(const char * path_prefix_, const char * filename);
+  void read_master_file_med(const char *prefix, const char *filename);
+  void read_master_file_fort21(const char *prefix, const char *filename);
+  static Nom   read_master_file_options(const char * filename);
+
+  virtual void filter_db(const LataDB& source,
+                         const Noms& geometry_names,
+                         const Motcles& field_names,
+                         const ArrOfInt& timesteps);
+
+  int                 nb_timesteps() const;
+  double                 get_time(int tstep) const;
+  enum TStepSelector { CURRENT, FIRST_AND_CURRENT };
+  Noms                   geometry_names(int tstep, TStepSelector which_tstep = CURRENT) const;
+  Field_UNames           field_unames(int tstep, const char * geometry, const char * name, TStepSelector which_tstep = CURRENT) const;
+  const LataDBGeometry&  get_geometry(int tstep, const char * name, TStepSelector which_tstep = CURRENT) const;
+  bool                   field_exists(int tstep, const char *geom, const char *name, TStepSelector which_tstep = CURRENT) const;
+  const LataDBField&     get_field(int tstep, const Field_UName& uname, TStepSelector which_tstep = CURRENT) const;
+  const LataDBField&     get_field(int tstep, const char *geom, const char *name, const char *loc, TStepSelector which_tstep = CURRENT) const;
+  const Nom&             path_prefix() const { return path_prefix_; };
+  void                   set_path_prefix(const char * s);
+
+  // First line in the .lata file
+  Nom header_;
+  // Second line in the .lata file
+  Nom case_;
+  // Third line in the .lata file
+  Nom software_id_;
+
+  LataDBDataType default_type_float() const; // Everything same as int, but type_=default_float_type_
+  LataDBDataType default_type_int_;
+  LataDBDataType::Type default_float_type_;
+
+  virtual void read_data(const LataDBField&, BigDoubleTab& data, Size_t debut=0, Size_t n=-1) const;
+  virtual void read_data(const LataDBField&, BigFloatTab& data, Size_t debut=0, Size_t n=-1) const;
+  virtual void read_data(const LataDBField&, BigIntTab& data, Size_t debut=0, Size_t n=-1) const;
+
+  virtual void read_data(const LataDBField&, BigDoubleTab& data, const BigArrOfTID& lines_to_read) const;
+  virtual void read_data(const LataDBField&, BigFloatTab& data, const BigArrOfTID& lines_to_read) const;
+  virtual void read_data(const LataDBField&, BigIntTab& data, const BigArrOfTID& lines_to_read) const;
+
+#if INT_is_64_ == 2
+  virtual void read_data(const LataDBField&, BigTIDTab& data, Size_t debut=0, Size_t n=-1) const;
+  virtual void read_data(const LataDBField&, BigTIDTab& data, const BigArrOfTID& lines_to_read) const;
+#endif
+
+  enum Element { line, triangle, quadri, tetra, hexa, triangle_3D, quadri_3D, polyedre,polygone, unspecified };
+  static Element element_type_from_string(const Motcle& type_elem);
+
+  // Tools to create/update the database and write lata data to disk
+  void   change_all_data_types(const LataDBDataType& old_type, const LataDBDataType& new_type);
+  void   change_all_data_filenames(const Nom& old_prefix, const Nom& new_prefix);
+  void   check_all_data_fileoffsets(bool split_files);
+  int    add_timestep(double time);
+  void   add_geometry(const LataDBGeometry& geom);
+  void   set_elemtype(int tstep, const char *geom_name, const char *elem_type);
+  bool   check_duplicate_filename(const char *filename) const;
+  void   add_field(const LataDBField& field);
+  void   write_master_file(const char *filename) const;
+  Size_t write_data(int tstep, const Field_UName&, const BigDoubleTab&);
+  Size_t write_data(int tstep, const Field_UName&, const BigFloatTab&);
+  Size_t write_data(int tstep, const Field_UName&, const BigIntTab&);
+#if INT_is_64_ == 2
+  Size_t write_data(int tstep, const Field_UName&, const BigTIDTab&);
+#endif
+
+protected:
+  LataDBField& getset_field(int tstep, const Field_UName& uname, TStepSelector which_tstep = CURRENT);
+  void          read_master_file_header(const char *filename, EFichier& is);
+  static int lata_v1_dim_from_elem_type(const Motcle& elem_type);
+  static int lata_v1_get_nb_comp(const Nom& fieldname, const Motcle& localisation, const LataDBGeometry& dom, int dim, LataDBField::Nature& nature, LataDBDataType::DataOrdering&);
+  static void get_element_data(const Motcle& elemtype, int& dimension, int& elem_shape, int& face_shape, int& nb_elem_faces);
+
+  const LataDBTimestep& get_tstep(int i) const;
+  void add(int tstep, const LataDBGeometry& item);
+  void add(int tstep, const LataDBField& item);
+  template <class C_Tab> void read_data_(const LataDBField&, C_Tab& data, Size_t debut, Size_t n) const;
+  template <class C_Tab> void read_data_(const LataDBField&, C_Tab& data, const BigArrOfTID& lines_to_read) const;
+  template <class C_Tab> void read_data2_(LataDataFile& f, const LataDBField& fld, C_Tab * const data, Size_t debut=0, Size_t n=-1, const BigArrOfTID *lines_to_read=nullptr) const;
+  template <class C_Tab> void read_data2_med_( const LataDBField& fld, C_Tab * const data, Size_t debut=0, Size_t n=-1) const;
+  template <class C_Tab> int read_data2_fort21_(LataDataFile& f, const LataDBField& fld, C_Tab * const data, Size_t debut=0, Size_t n=-1) const;
+  template <class C_Tab> Size_t write_data_(int tstep, const Field_UName& uname, const C_Tab&);
+
+  // Timestep 0 contains global domains and field definition
+  // Timestep 1..size()-1 contain the data for each "TEMPS" entry
+  LataVector<LataDBTimestep> timesteps_;
+
+  // Path prefix for all data blocks (used by read_data() and write_data())
+  Nom path_prefix_;
+
+  // Is this an old-style lata file ? (with INTERFACES special files and 2D elements expanded to 3D elements)
+  bool old_style_lata_;
+
+  // This flag tells if some write_data calls have been made since the last write_master_file
+  // If yes, issue a message to say that's wrong !
+  mutable bool write_master_file_to_call_;
+
+  // This is a memory buffer where data can be written to create a temporary data base
+  mutable std::stringstream internal_data_buffer_;
+  mutable MapBasicMesh*  basicmeshses_;
+};
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/LataDBFORT21.h b/Utilities/VisItBridge/databases/readers/Lata/LataDBFORT21.h
new file mode 100644
index 00000000..90b0e02a
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/LataDBFORT21.h
@@ -0,0 +1,274 @@
+/****************************************************************************
+ * Copyright (c) 2022, CEA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+#include "ReaderFORT21.h"
+
+/* Description: Reads the .lata database in the given file indicating than the
+ *  associated data files will be found in directory "prefix".
+ *  If not empty, "prefix" must finish with a '/'.
+ *  For "prefix" and "filename", if they do not begin with '/', are relative to pwd.
+ * Exceptions:
+ *  BAD_HEADER  means that the header found in this stream is not LATA_V2
+ *  READ_ERROR  means that an error has been found in the file (premature eof,
+ *              io error, bad keyword, ...)
+ *  FILE_NOT_FOUND means that, well, the lata file could not be opened
+ */
+
+
+void clear_map_mesh(std::map<std::string,ReaderFORT21::BasicMesh*>& map_basicmeshses_)
+{
+  for (auto& a : map_basicmeshses_)
+    {
+      delete a.second;
+      a.second=NULL;
+    }
+  map_basicmeshses_.clear();
+}
+
+class MapBasicMesh
+{
+  friend LataDB;
+public:
+  ~MapBasicMesh() { /*clear_map_mesh(map_basicmeshses_);i*/ }
+private:
+  mutable std::map<std::string,ReaderFORT21::BasicMesh>  map_basicmeshses_;
+};
+
+void LataDB::read_master_file_fort21(const char *prefix, const char *filename)
+{
+
+  Journal(1) << "read_master_file_fort21 " <<prefix<<" " <<filename << endl;
+  ReaderFORT21 parser;
+  parser.setFile(filename);
+  parser.parse();
+  parser.fix_bad_times();
+
+  // Defaults for lataV1
+  default_type_int_.msb_ = LataDBDataType::MSB_LITTLE_ENDIAN;
+  default_type_int_.type_ = LataDBDataType::INT32;
+  default_type_int_.array_index_ = LataDBDataType::C_INDEXING;
+  default_type_int_.data_ordering_ = LataDBDataType::C_ORDERING;
+  default_type_int_.fortran_bloc_markers_ = LataDBDataType::NO_BLOC_MARKER;
+  default_type_int_.bloc_marker_type_ = LataDBDataType::INT32;
+  default_float_type_ = LataDBDataType::REAL32;
+
+  // Create timestep 0 (global domain and fields)
+  timesteps_.add(LataDBTimestep());
+
+  // on ajoute les geom
+  // on verra apres pour les champs elem et som
+  std::vector<std::string> geoms= parser.getElementNames();
+
+  basicmeshses_ = new MapBasicMesh();
+  std::map<std::string,ReaderFORT21::BasicMesh>& map_basicmeshses = basicmeshses_->map_basicmeshses_;
+  //int first=1;
+  for (unsigned int i=0; i<geoms.size(); i++)
+    {
+      LataDBGeometry dom;
+      dom.timestep_ = timesteps_.size()-1;
+      dom.name_=geoms[i];
+      ReaderFORT21::BasicMesh mesh= parser.getMeshStack(geoms[i]);
+
+      if (mesh.type_mesh_!=ReaderFORT21::MESH_Polygone)
+        continue;
+      Journal(2) << "Adding geom "<<geoms[i]<<std::endl;
+      map_basicmeshses[geoms[i]]= mesh;
+      //new  ReaderFORT21::BasicMesh; *(map_basicmeshses[geoms[i]])= mesh;
+      int ncells=mesh.nb_elems_,nnodes=mesh.nbnodes_, nbcomp=mesh.nodes_per_elem_;
+      int spacedim=mesh.space_dim_;
+
+      dom.elem_type_="Polygone";
+      {
+        LataDBField som;
+        som.name_ = "SOMMETS";
+        som.geometry_ = dom.name_;
+        som.filename_ = filename;
+        som.size_=nnodes;
+        som.datatype_ = default_type_float(); // ??
+        som.nb_comp_=spacedim;
+
+        LataDBField elem;
+        elem.name_ = "ELEMENTS";
+        elem.geometry_ = dom.name_;
+        elem.filename_ = filename;
+        elem.size_=ncells;
+        elem.datatype_ = default_type_float(); // ??
+
+        elem.nb_comp_ = nbcomp;
+
+        add(timesteps_.size() - 1, dom);
+        add(timesteps_.size() - 1, som);
+        add(timesteps_.size() - 1, elem);
+      }
+    }
+  std::vector<double> times =parser.getTimes();
+  for (auto t: times)
+    {
+
+      LataDBTimestep& tt =
+          timesteps_.add(LataDBTimestep());
+      tt.time_ = t;
+    }
+  for (auto a: map_basicmeshses)
+    {
+      const std::string& geomname = a.first;
+      std::vector<std::string> fields;
+      fields= parser.getVarFieldNames(geomname);
+      //auto index_t =parser.getTimesIndexStack(geomname);
+      auto timesf=parser.getTimesStack(geomname);
+
+      const ReaderFORT21::BasicMesh& mesh = (a.second);
+
+      for (unsigned int i=0; i<fields.size(); i++)
+        {
+          LataDBField som;
+
+          som.name_ = fields[i];
+          //if (som.name_.finit_par("%")) continue;
+
+          som.filename_ = filename;
+
+
+          som.nature_ = LataDBField::SCALAR;
+
+
+          Nom meshname = geomname;
+          som.geometry_ = meshname;
+
+          ReaderFORT21::FieldInfo fieldinfo = parser.getVarFieldInfo(meshname.getString(),fields[i]);
+          if (fieldinfo.type_of_field()== ReaderFORT21::T_REAL)
+            {
+              som.datatype_ = default_type_float(); // ??
+            }
+          else if (fieldinfo.type_of_field()== ReaderFORT21::T_INT)
+            {
+              som.datatype_ = default_type_int_; // ??
+            }
+          else
+            continue;
+          if ((fieldinfo.size()*fieldinfo.nb_parts()==mesh.nb_elems_)||(fieldinfo.size()*fieldinfo.nb_parts()==mesh.nb_elems_+2))
+            {
+              som.size_=mesh.nb_elems_;
+              if (fieldinfo.nb_parts()>1) som.size_=fieldinfo.size();
+              som.localisation_="ELEM";
+              if (fieldinfo.nb_parts()>1) som.nature_ = LataDBField::WALLSCALAR;
+
+            }
+          else
+            continue;
+          som.nb_comp_=1;
+
+
+
+          for (unsigned int  index=0; index<timesf.size(); index++)
+            {
+              file_pos_t fp = parser.getOffsetVarField(geomname,fields[i],index) ;
+              //     std::cout<< "pf "<< geomname <<" "<< fields[i]<<" " << index<< " "<<fp<< std::endl;
+              som.datatype_.file_offset_ = fp;
+              add(index+1,som);
+            }
+        }
+    }
+}
+
+
+template <class C_Tab>
+int LataDB::read_data2_fort21_( LataDataFile& f,
+                                const LataDBField& fld,
+                                C_Tab * const data, // const pointer to non const data !
+                                Size_t debut, Size_t n) const
+{
+  Journal(6)<< "read_data2_fort21_  " << fld.name_<<" on " <<fld.geometry_<<" "<<fld.datatype_.file_offset_<<endl;
+
+  if (fld.name_=="SOMMETS")
+    {
+      assert(debut==0);
+      if (!basicmeshses_)
+        basicmeshses_ = new MapBasicMesh();
+      std::map<std::string,ReaderFORT21::BasicMesh>& map_basicmeshses = basicmeshses_->map_basicmeshses_;
+      if (map_basicmeshses.count(fld.geometry_.getString())<1)
+        {
+          ReaderFORT21 parser;
+          parser.setFile(fld.filename_.getString());
+          parser.parse();
+          map_basicmeshses[fld.geometry_.getString()] = parser.getMeshStack(fld.geometry_.getString());
+        }
+      const ReaderFORT21::BasicMesh& mesh = (map_basicmeshses[fld.geometry_.getString()]);
+
+      //    cerr<<"load sommets "<<endl;
+      data->resize(int(fld.size_),fld.nb_comp_);
+      BigFloatTab* data2= dynamic_cast<BigFloatTab*>(data);
+      if (data2 == nullptr)
+        {
+          std::cerr << "Unexpected error!" << std::endl;
+          throw;
+        }
+      for (int i=0; i<fld.size_; i++)
+        for (int j=0; j<fld.nb_comp_; j++)
+          (*data2)(i,j)=float(mesh.coords_[fld.nb_comp_*i+j]);
+
+      return 1;
+    }
+  else if (fld.name_=="ELEMENTS")
+    {
+      assert(debut==0);
+      std::map<std::string,ReaderFORT21::BasicMesh>& map_basicmeshses = basicmeshses_->map_basicmeshses_;
+      const ReaderFORT21::BasicMesh& mesh = map_basicmeshses[fld.geometry_.getString()];
+
+      data->resize(int(fld.size_),fld.nb_comp_);
+      BigTIDTab* data2= dynamic_cast<BigTIDTab*>(data);
+      if (data2 == nullptr)
+        {
+          std::cerr << "Unexpected error!" << std::endl;
+          throw;
+        }
+      for (int i=0; i<fld.size_; i++)
+        for (int j=0; j<fld.nb_comp_; j++)
+          (*data2)(i,j)=mesh.connectivity_[fld.nb_comp_*i+j];
+
+      return 1;
+    }
+  else
+    {
+      if (fld.nature_ == LataDBField::WALLSCALAR)
+        {
+          std::map<std::string,ReaderFORT21::BasicMesh>& map_basicmeshses = basicmeshses_->map_basicmeshses_;
+          const ReaderFORT21::BasicMesh& mesh = (map_basicmeshses[fld.geometry_.getString()]);
+          // cas particulier.... a coder
+          //
+          // case LataDBField::SCALAR:
+          int size=int(fld.size_);
+          int nb_parts= mesh.nb_elems_/size;
+          //std::cout<<"Special "<< nb_parts<<" "<<fld.name_<<" "<<fld.geometry_<< " "<<fld.size_<< " "<<mesh.nb_elems_<<std::endl;
+          // int aNameSize =  16;
+          data->resize(size*nb_parts,fld.nb_comp_);
+
+          LataDBField fld2(fld);
+          fld2.nature_=LataDBField::SCALAR;
+          C_Tab tmp(int(size),1);
+          int aNameSize=16+8;
+          for (int p=0; p<nb_parts; p++)
+            {
+
+              read_data2_(f,fld2,&tmp,debut,int(fld2.size_));
+              fld2.datatype_.file_offset_+=aNameSize +fld2.size_*sizeof(tmp(0,0));
+              for (trustIdType i = 0; i < fld2.size_; i++)
+                (*data)(int(i+p*fld2.size_),0) = tmp(i,0);
+            }
+          return 1;
+        }
+      return 0;
+    }
+}
+
diff --git a/Utilities/VisItBridge/databases/readers/Lata/LataDBmed.h b/Utilities/VisItBridge/databases/readers/Lata/LataDBmed.h
new file mode 100644
index 00000000..ce95f23d
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/LataDBmed.h
@@ -0,0 +1,554 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+//#define WITH_MEDLOADER
+#ifndef WITH_MEDLOADER
+void LataDB::read_master_file_med(const char *prefix, const char *filename)
+{
+  Journal() << "MED PLUGIN not compiled!" << endl;
+  throw;
+}
+
+template <class C_Tab>
+void LataDB::read_data2_med_(const LataDBField& fld, C_Tab * const data, // const pointer to non const data !
+                             Size_t debut, Size_t n) const
+{
+  Journal() << "MED PLUGIN not compiled!" << endl;
+  throw;
+}
+#else
+
+#include <medcoupling++.h>
+#include <MEDLoader.hxx>
+#include <MEDCouplingMemArray.hxx>
+#include <MEDCouplingUMesh.hxx>
+#include <MEDCouplingFieldDouble.hxx>
+#include <CellModel.hxx>
+#include <MEDFileField.hxx>
+
+using std::vector;
+using std::pair;
+using std::string;
+
+
+Nom latadb_name_from_type_geo(const med_geometry_type& type_geo)
+{
+  Nom type_elem;
+  switch(type_geo)
+    {
+    case MED_QUAD4:
+      type_elem="Rectangle";
+      break;
+    case MED_HEXA8:
+      type_elem="Hexaedre";
+      break;
+    case MED_TRIA3:
+      type_elem="Triangle";
+      break;
+    case MED_TETRA4:
+      type_elem="Tetraedre";
+      break;
+    case MED_PENTA6:
+      type_elem="Prisme";
+      break;
+    case MED_POLYHEDRON:
+      type_elem="Polyedre";
+      break;
+    case MED_POLYGON:
+      type_elem="Polygone";
+      break;
+    case MED_SEG2:
+      type_elem="Segment";
+      break;
+    default:
+      Cerr<<"type_geo " << (int)type_geo <<" is not a supported element."<<finl;
+      throw;
+      break;
+    }
+  return type_elem;
+}
+
+
+// passage de la connectivite trio a MED si sens=1
+// de MED a trio si sens=-1
+ArrOfInt renum_conn(const LataDB::Element& type)
+{
+  //  cerr<<"type elem "<<type_elem<<endl;
+  ArrOfInt filter;
+  if (type==LataDB::quadri )
+    {
+      filter.resize_array(4) ;
+
+      filter[0] = 0 ;
+      filter[1] = 2 ;
+      filter[2] = 3 ;
+      filter[3] = 1 ;
+    }
+
+  if (type== LataDB::hexa  )
+    {
+      filter.resize_array(8) ;
+
+      filter[0] = 0 ;
+      filter[1] = 2 ;
+      filter[2] = 3 ;
+      filter[3] = 1 ;
+      filter[4] = 4 ;
+      filter[5] = 6 ;
+      filter[6] = 7 ;
+      filter[7] = 5 ;
+    }
+  return filter;
+}
+
+extern med_geometry_type typmai3[MED_N_CELL_FIXED_GEO];
+
+void latadb_get_info_mesh_med(const char* filename,const char* meshname,med_geometry_type& type_geo,trustIdType& ncells,
+                              trustIdType& nnodes,True_int& spacedim, True_int& nbcomp,bool& is_structured, std::vector<int>& NIJK)
+{
+  using namespace MEDCoupling;
+
+  is_structured=false;
+  True_int meshDim;
+  try
+    {
+      // In 32b, MEDCoupling is 32b, but if we are in LATATOOLS mode (lata_tools and VisIt plugin, trustIdType is 64b ...)
+      mcIdType tmp_nod;
+      auto res = GetUMeshGlobalInfo(filename, meshname, meshDim, spacedim, tmp_nod);
+      nnodes = tmp_nod;
+
+      // on prend que la dimension la plus grande et on verifie que l'on a qu'un type elt
+      if (res.size()>1)
+        {
+          cerr<<"warning multi dimension in "<<meshname<<endl;
+          //throw;
+        }
+      if (res[0].size()>1)
+        {
+          cerr<<"error multi elements in "<<meshname<<endl;
+          throw;
+        }
+      type_geo=typmai3[res[0][0].first];
+
+      if ((type_geo==MED_POLYGON)||(type_geo==MED_POLYHEDRON))
+        {
+          //on est force de lire le maillage pour avoir le bon nombre de cellules
+          MCAuto<MEDCouplingUMesh> mesh(ReadUMeshFromFile(filename,meshname));
+          ncells = mesh->getNumberOfCells();
+          const mcIdType *idx = mesh->getNodalConnectivityIndex()->getConstPointer();
+          nbcomp = 0;
+          for (trustIdType i = 0; i < ncells; i++)
+            {
+              int c = (int)(idx[i + 1] - idx[i] - 1);
+              if (nbcomp < c)
+                nbcomp = c;
+            }
+        }
+      else
+        ncells=res[0][0].second;
+    }
+  catch (...)
+    {
+      // No UMesh try CMesh
+      MEDCouplingMesh* mesh = ReadMeshFromFile(filename, meshname);
+      /*
+        type_geo,int& ncells,int& nnodes,int& spacedim, int &nbcomp
+       */
+      MCAuto<MEDCouplingCMesh> cmesh (dynamic_cast<MEDCouplingCMesh*>(mesh));
+      if (cmesh == nullptr)
+        {
+          cerr << "Error: can not read CMesh ... " << meshname << endl;
+          throw;
+        }
+      spacedim=cmesh-> getSpaceDimension() ;
+
+      // See comment of DomainIJK:
+      std::vector<mcIdType> nijk_64 = cmesh->getNodeGridStructure();
+      for (int i=0; i<nijk_64.size(); i++)
+        NIJK[i] = (int)nijk_64[i]; // downcast
+
+      ncells=mesh->getNumberOfCells();
+      nnodes=mesh->getNumberOfNodes();
+
+      if (spacedim==3)
+        type_geo =MED_HEXA8;
+      else if (spacedim==2)
+        type_geo =MED_QUAD4;
+      else
+        abort();
+      is_structured=true;
+      //abort();
+      return;
+    }
+}
+
+
+// Description: Reads the .lata database in the given file indicating than the
+//  associated data files will be found in directory "prefix".
+//  If not empty, "prefix" must finish with a '/'.
+//  For "prefix" and "filename", if they do not begin with '/', are relative to pwd.
+// Exceptions:
+//  BAD_HEADER  means that the header found in this stream is not LATA_V2
+//  READ_ERROR  means that an error has been found in the file (premature eof,
+//              io error, bad keyword, ...)
+//  FILE_NOT_FOUND means that, well, the lata file could not be opened
+void LataDB::read_master_file_med(const char *prefix, const char *filename)
+{
+  Journal() << "MED " << MED_NUM_MAJEUR << "." << MED_MINOR_NUM << "." << MED_RELEASE_NUM << " PLUGIN ! " << endl;
+
+  // Defaults for lataV1
+  default_type_int_.msb_ = LataDBDataType::ASCII;
+  default_type_int_.type_ = LataDBDataType::INT32;
+  default_type_int_.array_index_ = LataDBDataType::F_INDEXING;
+  default_type_int_.data_ordering_ = LataDBDataType::C_ORDERING;
+  default_type_int_.fortran_bloc_markers_ = LataDBDataType::BLOC_MARKERS_SINGLE_WRITE;
+  default_type_int_.bloc_marker_type_ = LataDBDataType::INT32;
+  default_float_type_ = LataDBDataType::REAL32;
+
+  // Create timestep 0 (global domain and fields)
+  timesteps_.add(LataDBTimestep());
+
+  // on ajoute les geom
+  // on verra apres pour les champs elem et som
+  vector<string> geoms= MEDCoupling::GetMeshNames(filename);
+
+  vector<double> times;
+  LataDBTimestep  table;
+  bool first=true;
+
+  for (int i=0; i<geoms.size(); i++)
+    {
+      LataDBGeometry dom;
+      dom.timestep_ = timesteps_.size()-1;
+      dom.name_=geoms[i];
+      med_geometry_type type_geo;
+      trustIdType ncells,nnodes;
+      True_int nbcomp, spacedim;
+      bool is_structured;
+      std::vector<int> NIJK;
+      latadb_get_info_mesh_med(filename,geoms[i].c_str(),type_geo,ncells,nnodes,spacedim,nbcomp,is_structured,NIJK);
+
+      dom.elem_type_=latadb_name_from_type_geo(type_geo);
+
+      if (!is_structured)
+        {
+          LataDBField som;
+          som.name_ = "SOMMETS";
+          som.geometry_ = dom.name_;
+          som.filename_ = filename;
+          som.size_=nnodes;
+          som.datatype_ = default_type_float(); // ??
+          som.nb_comp_=spacedim;
+
+          LataDBField elem;
+          elem.name_ = "ELEMENTS";
+          elem.geometry_ = dom.name_;
+          elem.filename_ = filename;
+          elem.size_=ncells;
+          elem.datatype_ = default_type_float(); // ??
+
+          int dim,ff,ef;
+          get_element_data(dom.elem_type_, dim, elem.nb_comp_, ff, ef);
+          if (elem.nb_comp_ == -1) elem.nb_comp_ = nbcomp;
+
+          add(timesteps_.size() - 1, dom);
+          add(timesteps_.size() - 1, som);
+          add(timesteps_.size() - 1, elem);
+        }
+      else
+        {
+          add(timesteps_.size() - 1, dom);
+          {
+            LataDBField som;
+            som.name_ = "SOMMETS_IJK_I";
+            som.geometry_ = dom.name_;
+            som.filename_ = filename;
+            som.size_=NIJK[0];
+            som.datatype_ = default_type_float(); // ??
+            som.nb_comp_=1;
+            add(timesteps_.size() - 1, som);
+          }
+          {
+            LataDBField som;
+            som.name_ = "SOMMETS_IJK_J";
+            som.geometry_ = dom.name_;
+            som.filename_ = filename;
+            som.size_=NIJK[1];
+            som.datatype_ = default_type_float(); // ??
+            som.nb_comp_=1;
+            add(timesteps_.size() - 1, som);
+          }
+          {
+            LataDBField som;
+            som.name_ = "SOMMETS_IJK_K";
+            som.geometry_ = dom.name_;
+            som.filename_ = filename;
+            som.size_=NIJK[2];
+            som.datatype_ = default_type_float(); // ??
+            som.nb_comp_=1;
+            add(timesteps_.size() - 1, som);
+          }
+
+        }
+
+      vector<string> fields;
+      fields= MEDCoupling::GetAllFieldNamesOnMesh(filename,dom.name_.getString());
+
+      for (int i=0; i<fields.size(); i++)
+        {
+          LataDBField som;
+          som.name_ = fields[i];
+          som.filename_ = filename;
+          som.datatype_ = default_type_float(); // ??
+          som.nature_ = LataDBField::SCALAR;
+
+          const Nom& meshname = dom.name_;
+          som.geometry_ = meshname;
+          Nom newname(fields[i].c_str());
+          Nom ajout("_");
+
+          // cerr<<"field " <<fields[i]<< " "<< meshname<<" ";
+          vector< MEDCoupling::TypeOfField > ltypes=MEDCoupling::GetTypesOfField(filename,meshname.getString(),fields[i].c_str());
+          //if (ltypes.size()!=1) throw;
+          for (int t=0; t < (int)ltypes.size(); t++)
+            {
+              switch (ltypes[t])
+                {
+                case MEDCoupling::ON_CELLS :
+                  //cerr<<"elem"<<endl;
+                  som.size_=ncells;
+                  som.localisation_="ELEM";
+                  break;
+                case  MEDCoupling::ON_NODES :
+                  //cerr<<"som"<<endl;
+                  som.size_=nnodes;
+                  som.localisation_="SOM";
+                  break;
+                default:
+                  cerr<<"type inconnu "<<endl;
+                  throw;
+                }
+
+              som.nb_comp_=1;
+              // pour recupere nb_comp !!!
+
+              som.nb_comp_ = (int)MEDCoupling::GetComponentsNamesOfField(filename,fields[i].c_str()).size();
+
+              if (spacedim==som.nb_comp_)
+                som.nature_ = LataDBField::VECTOR;
+              ajout+=som.localisation_;
+              ajout+="_";
+              ajout+=meshname;
+              newname=newname.prefix(ajout);
+
+              som.name_=newname;
+
+              //som.uname_= Field_UName(meshname, newname, som.localisation_);
+
+              table.fields_.add(som);
+
+              if (ltypes.size()>1)
+                {
+                  auto iters= MEDCoupling::GetFieldIterations(ltypes[t],filename,meshname.getString(),fields[i].c_str());
+                  for (int iter=0; iter< (int)iters.size(); iter++)
+                    {
+                      double t= MEDCoupling::GetTimeAttachedOnFieldIteration(filename,fields[i].c_str(),iters[iter].first,iters[iter].second);
+                      if (first)
+                        times.push_back(t);
+                      else
+                        {
+                          if (times[iter]!=t)
+                            cerr<<"field " <<fields[i]<<" M time "<< t << " diff "<<times[iter] << endl;
+                        }
+                    }
+
+                }
+              else
+                {
+                  auto vtimes=MEDCoupling::GetAllFieldIterations(filename,/*meshname,*/fields[i].c_str());
+                  for (int it=0; it<vtimes.size(); it++)
+                    {
+                      double t=vtimes[it].second;
+                      if (first)
+                        times.push_back(t);
+                      else
+                        {
+                          if (times[it]!=t)
+                            cerr<<"field " <<fields[i]<<" time "<< t << " diff "<<times[it] << endl;
+                        }
+                    }
+                }
+              first=false;
+            }
+        }
+    }
+
+  if (times.size()>0)
+    for (int i=0; i<(int)times.size(); i++)
+      {
+        //LataDBTimestep & t = timesteps_.add(table);
+        LataDBTimestep& t = timesteps_.add(LataDBTimestep());
+        t.time_=times[i];
+        for (int f=0; f<(int)table.fields_.size(); f++)
+          add(i+1,table.fields_[f]);
+      }
+
+  for (int i=0; i<(int)times.size()*0; i++)
+    cerr<<" time "<<times[i]<<endl;
+}
+
+
+template <class C_Tab>
+void LataDB::read_data2_med_(const LataDBField& fld, C_Tab * const data, // const pointer to non const data !
+                             Size_t debut, Size_t n) const
+{
+  using namespace MEDCoupling;
+  using value_t = typename C_Tab::Value_type_;    // type stored in TAB
+  assert(debut==0);
+
+  if (fld.name_=="SOMMETS")
+    {
+      // Type checking:
+      assert((std::is_same<value_t, double>::value));
+
+      //    cerr<<"load sommets "<<endl;
+      MCAuto<MEDCouplingUMesh> mesh = ReadUMeshFromFile(fld.filename_.getString(),fld.geometry_.getString());
+      const DataArrayDouble* coords=mesh->getCoords();
+      data->resize(fld.size_,fld.nb_comp_);
+      for (trustIdType i=0; i<fld.size_; i++)
+        for (int j=0; j<fld.nb_comp_; j++)
+          (*data)(i,j)=(value_t)coords->getIJ(i,j); // see type checking above
+
+    }
+  else if (fld.name_=="ELEMENTS")
+    {
+      // Type checking:
+      assert((std::is_same<value_t, mcIdType>::value));
+
+      // cerr<<"load elements "<<endl;
+      Nom type_elem=get_geometry(fld.timestep_,fld.geometry_).elem_type_;
+      LataDB::Element type =LataDB::element_type_from_string(type_elem);
+      ArrOfInt filter=renum_conn(type);
+      MCAuto<MEDCouplingUMesh> mesh = ReadUMeshFromFile(fld.filename_.getString(),fld.geometry_.getString());
+      const DataArrayIdType *elems = mesh->getNodalConnectivity(), *idx = mesh->getNodalConnectivityIndex();
+      const mcIdType *ptr_elems=elems->getConstPointer(), *ptr_idx = idx->getConstPointer();
+      data->resize(fld.size_,fld.nb_comp_);
+      trustIdType compt=0;
+      bool void_fild = (filter.size_array()<=0);
+      for (trustIdType i=0; i<fld.size_; i++)
+        {
+          compt++;
+          for (int j=0; j<fld.nb_comp_; j++)
+            {
+              bool reel = (trustIdType)j + ptr_idx[i] + 1 < ptr_idx[i + 1];
+              (*data)(i, void_fild ? j : filter[j]) = reel ? (value_t)ptr_elems[compt] + 1 : 0; // see type checking above
+              if (reel) compt++;
+            }
+        }
+    }
+  else if (fld.name_.debute_par("SOMMETS_IJK_"))
+    {
+      // Type checking:
+      assert((std::is_same<value_t, double>::value));
+
+      MEDCouplingMesh * mesh = ReadMeshFromFile(fld.filename_.getString(),fld.geometry_.getString());
+      data->resize(fld.size_,fld.nb_comp_);
+      MCAuto<MEDCouplingCMesh> cmesh = dynamic_cast<MEDCouplingCMesh*>(mesh);
+      if (cmesh == nullptr)
+        {
+          cerr << "Error: can not read CMesh ... " << endl;
+          throw;
+        }
+      int dir;
+      if (fld.name_=="SOMMETS_IJK_I")
+        dir=0;
+      else  if (fld.name_=="SOMMETS_IJK_J")
+        dir=1;
+      else if (fld.name_=="SOMMETS_IJK_K")
+        dir=2;
+      else
+        abort();
+      const DataArrayDouble* coords=cmesh->getCoordsAt(dir);
+      for (trustIdType i=0; i<fld.size_; i++)
+        for (int j=0; j<fld.nb_comp_; j++)
+          (*data)(i,j)=(value_t)coords->getIJ(i,j); // see type checking above
+    }
+
+  else
+    {
+      // Type checking:
+      assert((std::is_same<value_t, double>::value));
+
+      data->resize(fld.size_,fld.nb_comp_);
+
+      //  if (fld.timestep_==1) iter.first=1;
+      // double t;
+      Nom fieldname=fld.name_;
+      fieldname+="_";
+      fieldname+=fld.localisation_;
+      fieldname+="_";
+      fieldname+=fld.geometry_;
+
+      bool ok=false;
+
+      vector<string> fields = GetAllFieldNamesOnMesh(fld.filename_.getString(),fld.geometry_.getString());
+
+      for (int f=0; f<(int)fields.size(); f++)
+        if (fieldname==fields[f].c_str())
+          {
+            ok=true;
+            break;
+          }
+      if (!ok)
+        fieldname=fld.name_;
+      auto vtimes = GetAllFieldIterations(fld.filename_.getString(),fieldname.getString());
+
+      int it=fld.timestep_-1;
+      pair<True_int, True_int> iter(fld.timestep_-1,-1);
+      if (fld.timestep_==1) it=0;
+      //Cerr<<iter.first <<" 00 "<<vtimes.size()<<finl;
+
+      iter.first=vtimes[it].first.first;
+      iter.second=vtimes[it].first.second;
+      // Cerr<<"iiii"<<iter.first<<" "<< it<<finl;
+      double t = GetTimeAttachedOnFieldIteration(fld.filename_.getString(),fieldname.getString(),iter.first,iter.second);
+
+      MEDCoupling::TypeOfField type;
+      if (fld.localisation_=="ELEM")
+        type=MEDCoupling::ON_CELLS;
+      else
+        {
+          type=MEDCoupling::ON_NODES;
+          assert(fld.localisation_=="SOM");
+        }
+      MCAuto<MEDFileField1TS> field = MEDFileField1TS::New(fld.filename_.getString(),fieldname.getString(),iter.first,iter.second);
+      const DataArrayDouble *values=field->getUndergroundDataArray();
+
+      if (field->getNumberOfComponents()!=fld.nb_comp_)
+        {
+          cerr<<field->getNumberOfComponents()<<" test "<< endl;
+          Journal()<<fieldname<<" not loaded "<<endl;
+        }
+      else
+        {
+          assert(field->getNumberOfComponents()==fld.nb_comp_);
+          const double* ptr=values->getConstPointer();
+          for (trustIdType i=0; i<fld.size_; i++)
+            for (int j=0; j<fld.nb_comp_; j++)
+              (*data)(i,j)=(value_t)ptr[i*fld.nb_comp_+j]; // see type checking above
+        }
+    }
+}
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/LataFilter.cpp b/Utilities/VisItBridge/databases/readers/Lata/LataFilter.cpp
new file mode 100644
index 00000000..a847a059
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/LataFilter.cpp
@@ -0,0 +1,1138 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <iostream>
+#include <fstream>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <math.h>
+#include <assert.h>
+#include <LataFilter.h>
+#include <list>
+#include <Static_Int_Lists.h>
+#include <Connectivite_som_elem.h>
+#include <LataDB.h>
+#include <LataTools.h>
+#include <Operator.h>
+#include <errno.h>
+#include <UserFields.h>
+#include <string.h>
+
+static const int cache_info_level = 5;
+static const int filter_info_level = 4;
+
+int LataOptions::read_int_opt(const Nom& s)
+{
+  const char *ptr = strstr(s, "=");
+  if (!ptr)
+    ptr = s;
+  errno = 0;
+  char *errorptr = 0;
+  int x = (int) strtol(ptr + 1, &errorptr, 0 /* base 10 par defaut */);
+  if (errno || *errorptr != 0)
+    {
+      Journal() << "LataOptions error reading int parameter: " << s << endl;
+      throw;
+    }
+  return x;
+}
+
+double LataOptions::read_float_opt(const Nom& s)
+{
+  const char *ptr = strstr(s, "=");
+  if (!ptr)
+    ptr = s;
+  errno = 0;
+  char *errorptr = 0;
+  double x = strtod(ptr + 1, &errorptr);
+  if (errno || *errorptr != 0)
+    {
+      Journal() << "LataOptions error reading float parameter: " << s << endl;
+      throw;
+    }
+  return x;
+}
+
+Nom LataOptions::read_string_opt(const Nom& s)
+{
+  const char *ptr = strstr(s, "=");
+  if (!ptr)
+    return s;
+  else
+    return Nom(ptr + 1);
+}
+
+Noms extract_list(const Nom& n)
+{
+  Noms liste;
+  if (n == "")
+    return liste;
+  const char *ptr = n;
+  Nom tmp("");
+  while (*ptr)
+    {
+      if (*ptr == ',')
+        {
+          liste.add(tmp);
+          tmp = "";
+        }
+      else
+        {
+          tmp += Nom(*ptr);
+        }
+    }
+  liste.add(tmp);
+  return liste;
+}
+
+void LataOptions::describe()
+{
+  cerr << "Data processing options (provided by the LataFilter module)" << endl;
+  cerr << " reconnect=tolerance : Find duplicate positions, and redefine connections to use" << endl;
+  cerr << "           always the same positions. tolerance is the maximum distance between" << endl;
+  cerr << "           positions that are considered equal." << endl;
+  cerr << "           Useful for results of parallel runs, where the domain could" << endl;
+  cerr << "           appear fragmented in as many subdomains as procs used." << endl;
+  cerr << "           This operator modifies the loaded domain, does not create a new domain." << endl;
+  cerr << " regularize=tolerance : Try to transform the irregular domain in a ijk domain." << endl;
+  cerr << "            tolerance is the maximum dx, dy or dz between positions that are" << endl;
+  cerr << "            considered to have the same x, y or z." << endl;
+  cerr << "            !Attention! regularize recalculates positions, connections, and fields" << endl;
+  cerr << "            Except in particularly simple cases, you cannot use a regularized domain" << endl;
+  cerr << "            for a field that has not been regularized the same way." << endl;
+  cerr << "            Create a new domain DOM -> DOM_IJK" << endl;
+  cerr << " regularize_polyedre=N : tells how to convert polyedre elements to VTK:" << endl;
+  cerr << "                         N=0 (default): any shape, handled as general VTK_CONVEX_POINT_SET" << endl;
+  cerr << "                         N=1: all elements are extruded in the Z direction (faster and nicer)" << endl;
+  cerr << " ijk_mesh_nb_parts=N : When loading an IJK mesh, automatically split the mesh into" << endl;
+  cerr << "            N blocks (N must be <= number of elements in the K direction, usefull in visit)" << endl;
+  cerr << " invalidate : together with regularize, create \"invalid positions\" and \"invalid connections\"" << endl;
+  cerr << "            components. Otherwise only set the values of the field to zeroes." << endl;
+  cerr << " extend_domain=n : When regularizing, add n nodes in each directions to have a layer" << endl;
+  cerr << "           of invalid positions and connections." << endl;
+  cerr << " dualmesh: Build and export the dual mesh" << endl;
+  cerr << "           (control volume for the velocities in VEF)" << endl;
+  cerr << "           data at faces become data at elements on the dual mesh." << endl;
+  cerr << "           Create a new domain DOM -> DOM_dual" << endl;
+  cerr << " facesmesh: Build and export the faces mesh" << endl;
+  cerr << "           (control volume for the velocities in VEF)" << endl;
+  cerr << "           data at faces become data at elements on the faces mesh." << endl;
+  cerr << "           Create a new domain DOM -> DOM_faces" << endl;
+
+  //cerr << " ncmesh:   Build and export a non-conforming mesh" << endl;
+  //cerr << "           (each mesh element has its proprietary nodes, elements are not topologically connected)" << endl;
+  //cerr << "           face dependent data become position dependent data on the new mesh." << endl;
+  //cerr << "           Create a new domain DOM -> DOM_nc" << endl;
+  cerr << " boundarymesh: Build new domains containing the boundaries only" << endl;
+  cerr << "            Create a new domain DOM -> DOM_Boundary" << endl;
+  //cerr << " clipbox=xmin,ymin,zmin,xmax,ymax,zmax : remove from all meshes all nodes," << endl;
+  //cerr << "           connections and faces outside of this box" << endl;
+  cerr << " load_virtual_elements: Read the VIRTUAL_ELEMENTS data in the input database, if available" << endl
+       << "           and merge nodes, elements and faces to each requested subdomain (using reconnect)" << endl;
+  cerr << "           Does not create a new domain, but modifies the loaded domain" << endl;
+  cerr << " ijk_virt_layer=N: load N layers of virtual elements if domain is ijk in lata file" << endl;
+  cerr << " reconnect_tolerance=: specify tolerance for all reconnect operations" << endl;
+  cerr << "           (reconnection is applied with load_virtual_elements)" << endl;
+  cerr << " user_fields: activate the User_Fields module (WARN: this module is often application specific," << endl;
+  cerr << "           it will fail if some requiered domains/fields are missing in the input database)" << endl;
+  cerr << " export_fields_at_faces: tells to export fields located at faces" << endl;
+  cerr << endl;
+  user_fields_options_.print_help_option();
+}
+
+int LataOptions::parse_option(const Nom& s)
+{
+  if (s.debute_par("verbosity="))
+    {
+      int level = read_int_opt(s);
+      set_Journal_level(level);
+    }
+  else if (s.debute_par("regularize="))
+    {
+      regularize = 1;
+      regularize_tolerance = (float) read_float_opt(s);
+    }
+  else if (s.debute_par("regularize_polyedre="))
+    regularize_polyedre = read_int_opt(s);
+  else if (s.debute_par("extend_domain="))
+    extend_domain = read_int_opt(s);
+  else if (s == "invalidate")
+    invalidate = true;
+  else if (s.debute_par("reconnect="))
+    {
+      reconnect = true;
+      reconnect_tolerance = (float) read_float_opt(s);
+    }
+  else if (s.debute_par("reconnect_tolerance="))
+    reconnect_tolerance = (float) read_float_opt(s);
+  else if (s == "dualmesh")
+    dual_mesh = true;
+  else if (s == "nodualmesh")
+    dual_mesh = false;
+  else if (s == "ncmesh")
+    nc_mesh = true;
+  else if (s == "facesmesh")
+    faces_mesh = true;
+  else if (s == "nofacesmesh")
+    faces_mesh = false;
+  else if (s == "boundarymesh")
+    boundary_mesh = true;
+  else if (s.debute_par("clipbox="))
+    {
+      Noms list = extract_list(((const char*) s) + 8);
+      if (list.size() != 6)
+        {
+          Journal() << "Error : clipbox parameters expects 6 values" << endl;
+          throw;
+        }
+      for (int i = 0; i < 3; i++)
+        {
+          clipbox_min[i] = read_float_opt(list[i]);
+          clipbox_max[i] = read_float_opt(list[i + 3]);
+        }
+    }
+  else if (s == "load_virtual_elements")
+    load_virtual_elements = true;
+  else if (s == "user_fields")
+    {
+      user_fields_ = true;
+      Journal() << "Option: User_fields ON" << endl;
+    }
+  else if (s.debute_par("ijk_mesh_nb_parts"))
+    ijk_mesh_nb_parts_ = read_int_opt(s);
+  else if (s == "export_fields_at_faces")
+    export_fields_at_faces_ = 1;
+  else if (s.debute_par("ijk_virt_layer="))
+    ijk_virt_layer = read_int_opt(s);
+  else
+    return user_fields_options_.parse_option(s);;
+  return 1;
+}
+
+void LataFilterCache::set_cache_properties(bool clear_on_tstep_change, Size_t mem_limit)
+{
+  clear_cache_on_tstep_change_ = clear_on_tstep_change;
+  cache_memory_limit_ = mem_limit;
+}
+
+// Description: if an entry with "id" tag and timestep exists in the cache,
+//  returns the entry, otherwise returns a reference to an empty DERIV that
+//  is stored in the cache and stores the associated "id" and timestep.
+//  The entry is locked and given a new last_access_time_ to show that it has
+//  been used recently.
+//  The entry must be released by release_item() when we are finished working
+//  with it.
+LataDeriv<LataObject>& LataFilterCache::get_item_(const Nom& id, int tstep)
+{
+  int i;
+  const int n = data_.size();
+  for (i = 0; i < n; i++)
+    {
+      const DataCacheItem& item = data_[i];
+      if (item.id_ == id && item.tstep_ == tstep)
+        break;
+    }
+  if (i == n)
+    {
+      // Look for an empty slot:
+      for (i = 0; i < n; i++)
+        if (data_[i].id_ == "??")
+          break;
+      // No empty slot: create a new slot:
+      if (i == n)
+        data_.add();
+      DataCacheItem& item = data_[i];
+      item.id_ = id;
+      item.tstep_ = tstep;
+      item.lock_ = 0;
+      Journal(cache_info_level) << "LataFilterCache<C>::get " << id << " (new cache entry " << i << ")." << endl;
+    }
+  else
+    {
+      Journal(cache_info_level) << "LataFilterCache<C>::get " << id << " (existing cache entry " << i << ")." << endl;
+    }
+  // Mark item and lock it:
+  DataCacheItem& item = data_[i];
+  item.last_access_time_ = cache_data_access_count_++;
+  item.lock_++;
+  return item.item_;
+}
+
+// Description: tells that if needed the item can be deleted from cache
+//  (there is no reference to it anymore outside of the cache).
+//  We update the memory size of this item here.
+void LataFilterCache::release_item(const Nom& id)
+{
+  Journal(cache_info_level) << "LataFilterCache::release_item " << id << endl;
+  const int n = data_.size();
+  int i;
+  for (i = 0; i < n; i++)
+    {
+      const DataCacheItem& item = data_[i];
+      if (item.id_ == id)
+        break;
+    }
+  if (i == n)
+    {
+      Journal() << "LataFilterCache::release_item internal error: unknown item " << id << endl;
+      throw;
+    }
+  if (data_[i].lock_ <= 0)
+    {
+      Journal() << "LataFilterCache::release_item internal error: item is already unlocked" << id << endl;
+      throw;
+    }
+  data_[i].last_access_time_ = cache_data_access_count_++;
+  data_[i].lock_--;
+  if (data_[i].item_.non_nul())
+    data_[i].memory_size_ = data_[i].item_.valeur().compute_memory_size();
+  else
+    data_[i].memory_size_ = 0;
+}
+
+// Description: removes from the cache the oldest items until the total
+//  memory used by the cache is below max_mem_size (in bytes), and
+//  if tstep_to_keep > 0, also removes all timesteps except 0 and tstep_to_keep
+void LataFilterCache::cleanup_cache(int tstep_to_keep)
+{
+  if (clear_cache_on_tstep_change_ && tstep_to_keep > 0)
+    {
+      Journal(cache_info_level) << "LataFilterCache::clear_cache_tsteps except 0 and " << tstep_to_keep << endl;
+      const int n = data_.size();
+      for (int i = 0; i < n; i++)
+        {
+          DataCacheItem& item = data_[i];
+          if (item.id_ != "??")
+            {
+              if (item.tstep_ == 0 || item.tstep_ == tstep_to_keep)
+                Journal(cache_info_level + 1) << " item " << item.id_ << " timestep " << item.tstep_ << " kept" << endl;
+              else if (item.lock_)
+                Journal(cache_info_level + 1) << " item " << item.id_ << " locked" << endl;
+              else
+                {
+                  Journal(cache_info_level) << " deleting item " << item.id_ << " " << item.tstep_ << endl;
+                  item.item_.reset();
+                  item.id_ = "??";
+                  item.tstep_ = -1;
+                }
+            }
+        }
+    }
+  if (cache_memory_limit_ >= 0)
+    {
+      Journal(cache_info_level) << "LataFilterCache::clear_cache_memory " << cache_memory_limit_ << endl;
+      do
+        {
+          const int n = data_.size();
+          // Scan cached data, looking for the oldest item and summing up memory
+          Size_t total_memsize = 0;
+          int oldest = -1;
+          Size_t oldest_time = cache_data_access_count_;
+          for (int i = 0; i < n; i++)
+            {
+              const DataCacheItem& item = data_[i];
+              if (item.id_ != "??")
+                {
+                  total_memsize += item.memory_size_;
+                  if (!item.lock_ && item.last_access_time_ < oldest_time)
+                    {
+                      oldest_time = item.last_access_time_;
+                      oldest = i;
+                    }
+                }
+            }
+          if (oldest < 0 || total_memsize < cache_memory_limit_)
+            break;
+
+          DataCacheItem& item = data_[oldest];
+          Journal(cache_info_level) << " deleting item " << item.id_ << " " << item.tstep_ << endl;
+          item.item_.reset();
+          item.id_ = "??";
+          item.tstep_ = -1;
+        }
+      while (1);
+    }
+}
+
+// Description: Cleanup everything, associate the lata_db and fills metadata information.
+void LataFilter::initialize(const LataOptions& opt, const LataDB& lata_db)
+{
+  opt_ = opt;
+  data_cache_.reset();
+  lataDB__ = &lata_db;
+  if (opt_.user_fields_)
+    {
+      user_fields_.instancie(UserFields);
+      user_fields_.valeur().set_options(opt_.user_fields_options_);
+    }
+
+  get_all_metadata(geoms_metadata_, fields_metadata_);
+}
+
+void LataFilter::set_cache_properties(Size_t max_memory, bool keep_all_timesteps)
+{
+  data_cache_.set_cache_properties(!keep_all_timesteps, max_memory);
+}
+
+// Description: Return the number of timesteps in the database
+//   (=number of physical timesteps + one containing global definitions at timestep 0)
+int LataFilter::get_nb_timesteps() const
+{
+  return lataDB().nb_timesteps();
+}
+
+// Description: Return the physical time for this timestep.
+//  returns -1.0 for timestep 0 (global definitions)
+double LataFilter::get_timestep(int i) const
+{
+  if (i == 0)
+    return -1.0;
+  else
+    return lataDB().get_time(i);
+}
+
+static void add_fields_to_metadata_list(const LataDB& lataDB, const Nom& lata_geom, const Nom& dest_geom, const Nom& options, int dim,
+                                        LataVector<LataFieldMetaData>& fields_data, const Motcle& source, const Nom& source_domain)
+{
+  if (lataDB.nb_timesteps() < 2)
+    return;
+  // Query for existing fields in the latadb :
+  Field_UNames lata_fields = lataDB.field_unames(1, lata_geom, "*", LataDB::FIRST_AND_CURRENT);
+  const int nb_fields = lata_fields.size();
+  for (int i_field = 0; i_field < nb_fields; i_field++)
+    {
+      const LataDBField& lata_field = lataDB.get_field(1, lata_fields[i_field], LataDB::FIRST_AND_CURRENT);
+      LataField_base::Elem_som loc = LataField_base::localisation_from_string(lata_field.localisation_);
+
+      // Hidden special fields
+      if (Motcle(lata_field.name_) == "INVALID_CONNECTIONS")
+        continue;
+      if (Motcle(lata_field.name_) == "ELEMENTS")
+        continue;
+      if (Motcle(lata_field.name_) == "FACES")
+        continue;
+      if (Motcle(lata_field.name_) == "ELEM_FACES")
+        continue;
+      if (Motcle(lata_field.name_) == "FACE_VOISINS")
+        continue;
+      LataFieldMetaData data;
+      data.name_ = lata_field.name_;
+      data.geometry_name_ = dest_geom;
+      data.component_names_ = lata_field.component_names_;
+      data.nb_components_ = lata_field.nb_comp_;
+      data.source_localisation_ = lata_field.localisation_;
+
+      if (options.find("to_vector") >= 0)
+        {
+          data.is_vector_ = true;
+          data.nb_components_ = dim;
+        }
+      else
+        data.is_vector_ = (lata_field.nature_ == LataDBField::VECTOR);
+
+      if (options.find("to_elem") >= 0)
+        data.localisation_ = LataField_base::ELEM;
+      else if (options.find("to_som") >= 0)
+        data.localisation_ = LataField_base::SOM;
+      else if (options.find("to_faces") >= 0)
+        data.localisation_ = LataField_base::FACES;
+      else
+        data.localisation_ = loc;
+
+      data.source_ = source;
+      data.uname_ = Field_UName(data.geometry_name_, data.name_, LataField_base::localisation_to_string(data.localisation_));
+      data.source_field_ = Field_UName(source_domain, data.name_, lata_fields[i_field].get_localisation());
+
+      if ((loc == LataField_base::ELEM && options.find("from_elem") >= 0) || (loc == LataField_base::SOM && options.find("from_som") >= 0)
+          || (loc == LataField_base::FACES && options.find("from_faces") >= 0))
+        {
+          Journal(filter_info_level) << " register field metadata: " << data.uname_ << endl;
+          fields_data.add(data);
+        }
+    }
+}
+
+// Process the content of the source LataDB structure and builds the metadata for
+//  all geometries and fields that the filter can export (depending on options,
+//  for example, provide dual mesh geometry and fields only if dualmesh option is on).
+void LataFilter::get_all_metadata(LataVector<LataGeometryMetaData>& geoms_data, LataVector<LataFieldMetaData>& fields_data)
+{
+  geoms_data.reset();
+  fields_data.reset();
+  int current_tstep = 1;
+  // If no real timestep, just check timestep 0
+  if (lataDB().nb_timesteps() < 2)
+    current_tstep = 0;
+  Noms lata_geoms_names = lataDB().geometry_names(current_tstep, LataDB::FIRST_AND_CURRENT);
+  const int nb_geoms = lata_geoms_names.size();
+  for (int i_geom = 0; i_geom < nb_geoms; i_geom++)
+    {
+      // Name of the current geometry (from lataDB)
+      const Nom& lata_geom_name = lata_geoms_names[i_geom];
+      const LataDBGeometry& lata_geom = lataDB().get_geometry(current_tstep, lata_geom_name, LataDB::FIRST_AND_CURRENT);
+      // Query properties from LataDB:
+      // Is it a dynamic mesh ?
+      const bool dynamic = lata_geom.timestep_ > 0;
+      // Element type ?
+      Domain::Element element_type = Domain::element_type_from_string(lata_geom.elem_type_);
+      // Query for dimension
+      const bool domain_already_ijk = lataDB().field_exists(current_tstep, lata_geom_name, "SOMMETS_IJK_I", LataDB::FIRST_AND_CURRENT);
+
+      // Do we have faces ?
+      const bool have_faces = domain_already_ijk
+                            || (lataDB().field_exists(current_tstep, lata_geom_name, "FACES", LataDB::FIRST_AND_CURRENT)
+                               && lataDB().field_exists(current_tstep, lata_geom_name, "ELEM_FACES", LataDB::FIRST_AND_CURRENT));
+
+      int dim = 1;
+      // Query for number of blocks in the lata file:
+      int nblocks = 1;
+      if (domain_already_ijk)
+        {
+          if (lataDB().field_exists(current_tstep, lata_geom_name, "SOMMETS_IJK_K", LataDB::FIRST_AND_CURRENT))
+            dim = 3;
+          else
+            dim = 2;
+          nblocks = opt_.ijk_mesh_nb_parts_;
+          Nom nom_sommets;
+          if (dim == 2)
+            nom_sommets = "SOMMETS_IJK_J";
+          else
+            nom_sommets = "SOMMETS_IJK_K";
+          const LataDBField& coord = lataDB().get_field(current_tstep, lata_geom_name, nom_sommets, "", LataDB::FIRST_AND_CURRENT);
+          // Nombre d'elements dans la direction du decoupage parallele:
+          const int nelem = (int) (coord.size_ - 1);
+          // Si les tranches sont trop petites diminuer le nombre de blocs
+          if (nblocks > (nelem + 3) / 4)
+            nblocks = (nelem + 3) / 4;
+        }
+      else
+        {
+          dim = lataDB().get_field(current_tstep, lata_geom_name, "SOMMETS", "*", LataDB::FIRST_AND_CURRENT).nb_comp_;
+          if (lataDB().field_exists(current_tstep, lata_geom_name, "JOINTS_SOMMETS", LataDB::FIRST_AND_CURRENT))
+            nblocks = (int) lataDB().get_field(current_tstep, lata_geom_name, "JOINTS_SOMMETS", "*", LataDB::FIRST_AND_CURRENT).size_;
+        }
+
+      // Initialize data common to all domains:
+      LataGeometryMetaData data;
+      data.dynamic_ = dynamic;
+      data.dimension_ = dim;
+      data.element_type_ = element_type;
+      data.is_ijk_ = domain_already_ijk;
+
+      // If we reconnect all subdomains, always load all of them:
+      if (!opt_.reconnect)
+        data.nblocks_ = nblocks;
+      else
+        data.nblocks_ = 1;
+
+      data.internal_name_ = lata_geom_name;
+      data.displayed_name_ = lata_geom_name;
+
+      Nom separ("boundaries_");
+      int m = data.displayed_name_.find(separ);
+      if (m > 0)
+        {
+          const Nom& name = data.displayed_name_;
+          // on remplace boundaries_ par boundaries/
+          const char *jj = name;
+          Nom disp(name);
+          disp.prefix(jj + m - 1);
+          // GF le nom du domaine existe t il siuoi on a peut etre postraite sur un bord
+          if (lata_geoms_names.rang(disp) > -1)
+            {
+              Nom bord(jj + m + separ.longueur() - 1);
+              disp += Nom("_boundaries/");
+              disp += bord;
+              data.displayed_name_ = disp;
+            }
+        }
+      //   cerr<< data.displayed_name_<<endl;
+      data.source_ = "latadb";
+      Journal(filter_info_level) << " metadata: adding geometry " << lata_geom_name << " displayed name=" << data.displayed_name_ << endl;
+      geoms_data.add(data);
+      // Add fields at som and elem:
+      add_fields_to_metadata_list(lataDB(), lata_geom_name, data.internal_name_, "from_elem,from_som,from_faces", dim, fields_data, "latadb", "??");
+      // It is regularizable ?
+      bool regularizable = (((element_type == Domain::quadri) && (data.dimension_ == 2)) || ((element_type == Domain::hexa) && (data.dimension_ == 3))) && (lata_geom.elem_type_ != "HEXAEDRE_AXI")
+                             && (lata_geom.elem_type_ != "RECTANGLE_AXI") && (lata_geom.elem_type_ != "QUADRANGLE") && (lata_geom.elem_type_ != "QUADRANGLE_3D");
+      Journal(filter_info_level) << " metadata: geometry " << lata_geom_name << " element type says regularizable=" << regularizable << endl;
+      if (regularizable && ((opt_.regularize_tolerance < 0) || (!opt_.regularize)))
+        {
+          regularizable = false;
+          Journal(filter_info_level) << " regularize option not set: don't build ijk domain" << endl;
+        }
+      if (regularizable && domain_already_ijk)
+        {
+          regularizable = false;
+          Journal(filter_info_level) << " domain is already IJK: do not regularize" << endl;
+        }
+
+      // opt_.regularize == 2 means: provide ijk only if faces are present
+      if (regularizable && opt_.regularize == 2)
+        {
+          if (!have_faces)
+            {
+              Journal(filter_info_level) << " regularize option==2 and no faces => do not regularize" << endl;
+              regularizable = false;
+            }
+        }
+      if (regularizable)
+        {
+          data.internal_name_ = lata_geom_name;
+          data.internal_name_ += "_IJK";
+          data.is_ijk_ = true;
+          data.displayed_name_ = lata_geom_name;
+          data.source_ = "operator_ijk";
+          data.source_domain_ = lata_geom_name;
+          geoms_data.add(data);
+          Journal(filter_info_level) << " metadata: adding geometry " << data.internal_name_ << " displayed name=" << data.displayed_name_ << endl;
+          // Add fields at som and elem:
+          add_fields_to_metadata_list(lataDB(), lata_geom_name, data.internal_name_, "from_elem,from_som,from_faces", dim, fields_data, "operator_ijk", data.source_domain_);
+        }
+
+      // Provide dual mesh
+      if (opt_.dual_mesh && have_faces)
+        {
+          data.internal_name_ = lata_geom_name;
+
+          // If it's quadri or hexa, we need the regular mesh
+          data.source_domain_ = data.internal_name_;
+          if (regularizable)
+            {
+              data.internal_name_ += "_IJK";
+              data.source_domain_ += "_IJK";
+              data.is_ijk_ = true;
+            }
+          data.internal_name_ += "_dual";
+          data.displayed_name_ += "_dual";
+
+          data.source_ = "operator_dual";
+          geoms_data.add(data);
+          Journal(filter_info_level) << " metadata: adding geometry " << data.internal_name_ << " displayed name=" << data.displayed_name_ << endl;
+          // Add fields at faces, localisation will be at elements,
+          //  forced to vector type if vdf:
+          Nom options("from_faces,to_elem");
+          if (regularizable)
+            options += ",to_vector";
+          add_fields_to_metadata_list(lataDB(), lata_geom_name, data.internal_name_, options, dim, fields_data, "operator_dual", data.source_domain_);
+        }
+
+      // Provide nc mesh if possible
+      if (opt_.nc_mesh && have_faces && !regularizable /* doesn't work for vdf */)
+        {
+          data.internal_name_ = lata_geom_name;
+          data.internal_name_ += "_nc";
+          data.displayed_name_ = data.internal_name_;
+          data.source_ = "operator_nc";
+          data.source_domain_ = lata_geom_name;
+          geoms_data.add(data);
+          Journal(filter_info_level) << " metadata: adding geometry " << data.internal_name_ << " displayed name=" << data.displayed_name_ << endl;
+          // Add fields at faces, localisation will be at nodes
+          Nom options("from_faces,to_som");
+          add_fields_to_metadata_list(lataDB(), lata_geom_name, data.internal_name_, options, dim, fields_data, "operator_nc", data.source_domain_);
+        }
+      // Provide faces mesh if possible
+      if (opt_.faces_mesh && have_faces && !regularizable /* doesn't work for vdf */&& !(domain_already_ijk))
+        {
+
+          data.internal_name_ = lata_geom_name;
+          data.internal_name_ += "_centerfaces";
+          data.displayed_name_ = data.internal_name_;
+          data.source_ = "operator_faces";
+          data.source_domain_ = lata_geom_name;
+          if (data.element_type_ == Domain::triangle)
+            data.element_type_ = Domain::line;
+          else if (data.element_type_ == Domain::tetra)
+            data.element_type_ = Domain::triangle;
+
+          geoms_data.add(data);
+          Journal(filter_info_level) << " metadata: adding geometry " << data.internal_name_ << " displayed name=" << data.displayed_name_ << endl;
+          // Add fields at faces, localisation will be at nodes
+          Nom options("from_faces,to_elem");
+          add_fields_to_metadata_list(lataDB(), lata_geom_name, data.internal_name_, options, dim, fields_data, "operator_faces", data.source_domain_);
+        }
+      // Provide boundary mesh
+      if (opt_.boundary_mesh && (element_type == Domain::hexa || element_type == Domain::tetra))
+        {
+          data.internal_name_ = lata_geom_name;
+          data.internal_name_ += "_Boundary";
+          data.displayed_name_ = data.internal_name_;
+          data.source_ = "operator_boundary";
+          data.source_domain_ = lata_geom_name;
+          geoms_data.add(data);
+          Journal(filter_info_level) << " metadata: adding geometry " << data.internal_name_ << " displayed name=" << data.displayed_name_ << endl;
+          Nom options("from_elem,from_som");
+          add_fields_to_metadata_list(lataDB(), lata_geom_name, data.internal_name_, options, dim, fields_data, "operator_boundary", data.source_domain_);
+          options = "from_faces,to_elem";
+          add_fields_to_metadata_list(lataDB(), lata_geom_name, data.internal_name_, options, dim, fields_data, "operator_boundary", data.source_domain_);
+        }
+    }
+
+  if (user_fields_.non_nul())
+    user_fields_.valeur().new_fields_metadata(*this, fields_data);
+}
+
+// Description: Return a list of domain names available from get_geometry_metadata()
+//  and that we want to show to the user.
+//  This includes the domains loaded from the lata file plus new constructed domains
+//  (nc_mesh, dual_mesh, boundary_mesh, etc) if requested in options and if available
+//  (depending if requiered data (eg faces, ...)
+Noms LataFilter::get_exportable_geometry_names() const
+{
+  Noms names;
+  int i;
+  for (i = 0; i < geoms_metadata_.size(); i++)
+    names.add(geoms_metadata_[i].internal_name_);
+
+  // If an IJK domain is here, don't show the original domain:
+  Noms names2;
+  for (i = 0; i < names.size(); i++)
+    {
+      Nom n(names[i]);
+      n += "_IJK";
+      if (names.rang(n) < 0)
+        names2.add(names[i]);
+    }
+  return names2;
+}
+
+// Description: the same, with field names...
+//  If geometry=="*", returns all fields
+//  Currently, doesn't show fields located at faces...
+Field_UNames LataFilter::get_exportable_field_unames(const char *geometry) const
+{
+  Field_UNames unames;
+  for (int i = 0; i < fields_metadata_.size(); i++)
+    if (geometry == fields_metadata_[i].geometry_name_
+        || std::string(geometry) == std::string("*"))  // warning, do not write 'geometry == "*"' -> undefined behavior
+      {
+        // Do not show faces located fields to the user...
+        if (fields_metadata_[i].localisation_ != LataField_base::FACES || opt_.export_fields_at_faces_)
+          unames.add(fields_metadata_[i].uname_);
+        else
+          Journal(filter_info_level) << "LataFilter::get_exportable_field_unames - Ignored field " << fields_metadata_[i].uname_ << endl;
+      }
+  return unames;
+}
+
+// Description: fill "data" for the requested "geometry". "geometry" must be a name
+//  returned by get_exportable_geometry_names()
+const LataGeometryMetaData& LataFilter::get_geometry_metadata(const char *geometry) const
+{
+  Nom geom(geometry);
+  for (int i = 0; i < geoms_metadata_.size(); i++)
+    if (geom == geoms_metadata_[i].internal_name_)
+      return geoms_metadata_[i];
+
+  Journal() << "Error in LataFilter::get_geometry_metadata: unknown geometry " << geometry << endl;
+  throw LataError(LataError::INVALID_DOMAIN, "unknown geometry");
+}
+
+// Description: fill "data" for the requested "geometry/field". "geometry"  and "field" must be names
+//  returned by get_exportable_geometry_names() and get_exportable_field_names()
+const LataFieldMetaData& LataFilter::get_field_metadata(const Field_UName& uname) const
+{
+  for (int i = 0; i < fields_metadata_.size(); i++)
+    if (fields_metadata_[i].uname_ == uname)
+      return fields_metadata_[i];
+
+  Journal() << "Error in LataFilter::get_field_metadata: unknown field " << uname << endl;
+  throw LataError(LataError::INVALID_COMPONENT, "unknown field");
+}
+
+// Description:
+//  Returns a reference to the requested geometry.
+//  If the geometry is not found at the requested timestep, it
+//  is seached in the first timestep.
+//  If the geometry does not exist in the cache, all needed data is loaded
+//   and the geometry is allocated and built in the internal cache.
+//  The reference is valid until the user calls release_geometry()
+//  The user MUST call release_geometry() to allow the data to be
+//   removed from the data cache.
+const Domain& LataFilter::get_geometry(const Domain_Id& id)
+{
+  Journal(filter_info_level) << "LataFilter::get_geometry " << id.name_ << " time=" << id.timestep_ << " bloc=" << id.block_ << endl;
+  data_cache_.cleanup_cache(id.timestep_);
+
+  Domain_Id requested_id(id);
+  // Get the real timestep where this domain is stored:
+  const LataGeometryMetaData& geom_metadata = get_geometry_metadata(id.name_);
+  if (geom_metadata.dynamic_)
+    requested_id.timestep_ = id.timestep_;
+  else
+    requested_id.timestep_ = 0;
+
+  LataDeriv<Domain>& dom_ptr = get_cached_domain(requested_id);
+  if (!dom_ptr.non_nul())
+    {
+      if (geom_metadata.source_ == "latadb")
+        {
+          // Request for a native domain : load it from lataDB
+          // If reconnect and loading all subdomains, go ! Don't store the operator in cache since it's
+          //  not required to process fields.
+
+          // Is it a structured or unstructured mesh ?
+          if (lataDB().field_exists(requested_id.timestep_, requested_id.name_, "SOMMETS"))
+            {
+              DomainUnstructured& dom = dom_ptr.instancie(DomainUnstructured);
+
+              if (opt_.reconnect)
+                {
+                  // Bloc demande, peut etre le bloc 0 ou le bloc -1:
+                  const int req_block = requested_id.block_;
+                  if (requested_id.block_ > 0)
+                    {
+                      Cerr << "Error: requesting block " << requested_id.block_ << " with reconnect option" << endl;
+                      throw;
+                    }
+                  requested_id.block_ = -1; // load all blocks
+                  dom.fill_domain_from_lataDB(lataDB(), requested_id, 1 /* faces */, 0);
+                  Reconnect::reconnect_geometry(dom, opt_.reconnect_tolerance);
+                  dom.id_.block_ = req_block;
+                }
+              else
+                {
+                  dom.fill_domain_from_lataDB(lataDB(), requested_id, 1 /* faces */, opt_.load_virtual_elements ? 1 : 0);
+                  if (opt_.load_virtual_elements && dom.nb_virt_items(LataField_base::ELEM) > 0)
+                    {
+                      Reconnect::reconnect_geometry(dom, opt_.reconnect_tolerance, dom.nb_nodes() - dom.nb_virt_items(LataField_base::SOM));
+                    }
+                }
+            }
+          else
+            {
+              // Structured ijk:
+              DomainIJK& dom = dom_ptr.instancie(DomainIJK);
+              if (opt_.reconnect || requested_id.block_ < 0)
+                {
+                  dom.fill_domain_from_lataDB(lataDB(), requested_id, 1 /* parallel splitting */, 0 /* no virtual elements */);
+                }
+              else
+                {
+                  const int nparts = opt_.ijk_mesh_nb_parts_;
+                  const int virtual_size = opt_.load_virtual_elements ? opt_.ijk_virt_layer : 0;
+                  dom.fill_domain_from_lataDB(lataDB(), requested_id, nparts /* parallel splitting */, virtual_size /* with virtual elements */);
+                }
+            }
+        }
+      else if (geom_metadata.source_.debute_par("OPERATOR"))
+        {
+          const Domain& src_domain = get_geometry(Domain_Id(geom_metadata.source_domain_, requested_id.timestep_, requested_id.block_));
+          Operator& op = get_set_operator(requested_id);
+          op.build_geometry(src_domain, dom_ptr);
+          dom_ptr.valeur().id_ = requested_id;
+          release_cached_operator(requested_id);
+          release_geometry(src_domain);
+        }
+      else
+        {
+          Journal() << "Unknown source in geometry metadata " << geom_metadata.source_ << endl;
+          throw;
+        }
+    }
+
+  return dom_ptr.valeur();
+}
+
+Operator& LataFilter::get_set_operator(const Domain_Id& id)
+{
+  LataDeriv<Operator>& op_ptr = get_cached_operator(id);
+  if (!op_ptr.non_nul())
+    {
+      // Operator not in the cache ? Build it:
+      if (id.name_.finit_par("_IJK"))
+        {
+          OperatorRegularize& op = op_ptr.instancie(OperatorRegularize);
+          op.set_tolerance(opt_.regularize_tolerance);
+          op.set_extend_layer(opt_.extend_domain);
+        }
+      else if (id.name_.finit_par("_dual"))
+        op_ptr.instancie(OperatorDualMesh);
+      else if (id.name_.finit_par("_Boundary"))
+        op_ptr.instancie(OperatorBoundary);
+      else if (id.name_.finit_par("_centerfaces"))
+        op_ptr.instancie(OperatorFacesMesh);
+      else
+        {
+          Journal() << "Internal error in LataFilter::get_operator: forgot to implement operator choice for " << id.name_ << endl;
+          throw;
+        }
+    }
+  return op_ptr.valeur();
+}
+
+// Description: returns the requested field, computing it if it is not
+//  already in the cache. You MUST call release_field() on the returned field
+//  when you don't need it any more...
+//  See also class Field_Id
+const LataField_base& LataFilter::get_field(const Field_Id& id)
+{
+  Journal(filter_info_level) << "LataFilter::get_field " << id.uname_ << " time=" << id.timestep_ << " bloc=" << id.block_ << endl;
+
+  data_cache_.cleanup_cache(id.timestep_);
+
+  const LataFieldMetaData& field_metadata = get_field_metadata(id.uname_);
+
+  LataDeriv<LataField_base>& field_ptr = get_cached_field(id);
+  if (!field_ptr.non_nul())
+    {
+      if (field_metadata.source_ == "latadb")
+        {
+          // Request for a native field : load it from lataDB
+          const Domain& dom = get_geometry(id);
+          dom.fill_field_from_lataDB(lataDB(), id, field_ptr);
+          release_geometry(dom);
+        }
+      else if (field_metadata.source_.debute_par("OPERATOR"))
+        {
+          const Field_Id src_id(field_metadata.source_field_, id.timestep_, id.block_);
+          const Domain& src_domain = get_geometry(src_id);
+          const LataField_base& src_field = get_field(src_id);
+          const Domain& dest_domain = get_geometry(id);
+          Operator& op = get_set_operator(dest_domain.id_);
+          op.build_field(src_domain, src_field, dest_domain, field_ptr);
+          field_ptr.valeur().id_ = Field_Id(field_metadata.uname_, src_field.id_.timestep_, src_field.id_.block_);
+          release_field(src_field);
+          release_geometry(src_domain);
+          release_geometry(dest_domain);
+          release_cached_operator(dest_domain.id_);
+        }
+      else if (field_metadata.source_ == "user_fields")
+        {
+          Field<BigFloatTab>& f = field_ptr.instancie(Field<BigFloatTab> );
+          f = user_fields_.valeur().get_field(id);
+          // Force field id to correct value:
+          f.id_ = id;
+          f.component_names_ = field_metadata.component_names_;
+          f.nature_ = field_metadata.is_vector_ ? LataDBField::VECTOR : LataDBField::SCALAR;
+          f.localisation_ = field_metadata.localisation_;
+        }
+    }
+
+  return field_ptr.valeur();
+}
+
+// Description: returns the requested float field, computing it if it is not
+//  already in the cache. You MUST call release_field() on the returned field
+//  when you don't need it any more...
+//  See also class Field_Id
+const FieldFloat& LataFilter::get_float_field(const Field_Id& id)
+{
+  const LataField_base& field = get_field(id);
+  const FieldFloat *float_field_ptr = dynamic_cast<const FieldFloat*>(&field);
+  if (!float_field_ptr)
+    {
+      /*assert(! float_field_ptr);*/
+      throw LataError(LataError::NOT_A_FLOAT_FIELD, "not a float field");
+    }
+  const FieldFloat& fld = *float_field_ptr;
+  return fld;
+}
+void LataFilter::release_geometry(const Domain& dom)
+{
+  Journal(filter_info_level) << "LataFilter::release_geometry " << dom.id_.name_ << " time=" << dom.id_.timestep_ << " bloc=" << dom.id_.block_ << endl;
+  release_cached_domain(dom.id_);
+}
+
+void LataFilter::release_field(const LataField_base& field)
+{
+  Journal(filter_info_level) << "LataFilter::release_field " << field.id_.uname_ << " time=" << field.id_.timestep_ << " bloc=" << field.id_.block_ << endl;
+  release_cached_field(field.id_);
+}
+
+void build_mangeld_domain_name(const Domain_Id& id, Nom& name)
+{
+  name = id.name_;
+  name += "_";
+  name += Nom(id.timestep_);
+  name += "_";
+  name += Nom(id.block_);
+  name.majuscule();
+}
+
+void build_mangeld_field_name(const Field_Id& id, Nom& name)
+{
+  name = id.uname_.build_string();
+  name += "_";
+  name += Nom(id.timestep_);
+  name += "_";
+  name += Nom(id.block_);
+  name.majuscule();
+}
+
+LataDeriv<LataField_base>& LataFilter::get_cached_field(const Field_Id& id)
+{
+  Nom n;
+  build_mangeld_field_name(id, n);
+  return data_cache_.get_item<LataDeriv<LataField_base> >(n, id.timestep_);
+}
+
+LataDeriv<Domain>& LataFilter::get_cached_domain(const Domain_Id& id)
+{
+  Nom n;
+  build_mangeld_domain_name(id, n);
+  return data_cache_.get_item<LataDeriv<Domain> >(n, id.timestep_);
+}
+
+LataDeriv<Operator>& LataFilter::get_cached_operator(const Domain_Id& id)
+{
+  Nom n;
+  build_mangeld_domain_name(id, n);
+  n += "_OP";
+  return data_cache_.get_item<LataDeriv<Operator> >(n, id.timestep_);
+}
+
+void LataFilter::release_cached_domain(const Domain_Id& id)
+{
+  Nom n;
+  build_mangeld_domain_name(id, n);
+  data_cache_.release_item(n);
+}
+
+void LataFilter::release_cached_field(const Field_Id& id)
+{
+  Nom n;
+  build_mangeld_field_name(id, n);
+  data_cache_.release_item(n);
+}
+
+void LataFilter::release_cached_operator(const Domain_Id& id)
+{
+  Nom n;
+  build_mangeld_domain_name(id, n);
+  n += "_OP";
+  data_cache_.release_item(n);
+}
+
+// [ABN] ouch!! there must be some std::something to do this...:
+void LataOptions::extract_path_basename(const char *s, Nom& path_prefix, Nom& basename)
+{
+  int i;
+  for (i = (int) strlen(s) - 1; i >= 0; i--)
+    if ((s[i] == PATH_SEPARATOR) || (s[i] == '\\'))
+      break;
+  path_prefix = "";
+  int j;
+  for (j = 0; j <= i; j++)
+    path_prefix += Nom(s[j]);
+
+  // Parse basename : if extension given, remove it
+  int n = (int) strlen(s);
+  if (n > 5 && strcmp(s + n - 5, ".lata") == 0)
+    n -= 5;
+  basename = "";
+  for (j = i + 1; j < n; j++)
+    basename += Nom(s[j]);
+  //  Journal(9)<<" prefix "<<path_prefix<< " "<<i<<endl;
+}
+
+LataOptions::LataOptions()
+{
+  dual_mesh = false;
+  faces_mesh = false;
+  nc_mesh = false;
+  boundary_mesh = false;
+  reconnect = false;
+  reconnect_tolerance = 1e-6f;
+  regularize = 0;
+  extend_domain = 0;
+  regularize_tolerance = 1e-6f;
+  invalidate = false;
+  load_virtual_elements = false;
+  user_fields_ = false;
+  ijk_mesh_nb_parts_ = 1;
+  ijk_virt_layer = 1;
+  export_fields_at_faces_ = 0;
+  regularize_polyedre = 0;
+}
+
+void build_geometry_(Operator& op, const Domain& src, LataDeriv<Domain>& dest)
+{
+  Journal() << "Error in an operator: build_geometry not coded for this Operator/Domain" << endl;
+  throw;
+}
+
+void build_field_(Operator& op, const Domain& src, const Domain& dest, const LataField_base& srcf, LataField_base& destf)
+{
+  Journal() << "Error in an operator: build_field not coded for this Operator/Domain/Field" << endl;
+  throw;
+}
+
+void LataDB_apply_input_filter(const LataDB& lata_db, LataDB& filtered_db, const ArrOfInt& input_timesteps_filter, const Noms& input_domains_filter, const Noms& input_components_filter)
+{
+  ArrOfInt timesteps_filter(input_timesteps_filter);
+  Noms domains_filter(input_domains_filter);
+  Noms components_filter(input_components_filter);
+
+  // Build a list of all available geometries and components
+  Noms list_all_domains = lata_db.geometry_names(lata_db.nb_timesteps() - 1, LataDB::FIRST_AND_CURRENT);
+  Noms list_all_fields;
+  {
+    Field_UNames fields = lata_db.field_unames(lata_db.nb_timesteps() - 1, "*", "*", LataDB::FIRST_AND_CURRENT);
+    for (int i = 0; i < fields.size(); i++)
+      {
+        const Nom& n = fields[i].get_field_name();
+        if (list_all_fields.rang(n) < 0)
+          list_all_fields.add(n);
+      }
+  }
+
+  if (timesteps_filter.size_array() == 0)
+    {
+      // Add all timesteps, timestep 0 is implicitely added.
+      int n = lata_db.nb_timesteps();
+      timesteps_filter.resize_array(n - 1);
+      for (int i = 1; i < n; i++)
+        timesteps_filter[i - 1] = i;
+      Journal(3) << " Exporting all " << n - 1 << " timesteps" << endl;
+    }
+  else if (timesteps_filter[0] < 0)
+    {
+      timesteps_filter.resize_array(0);
+      Journal(3) << " Request timestep -1: Exporting only global time independent data" << endl;
+    }
+  if (domains_filter.size() == 0)
+    {
+      // Add all geometries
+      domains_filter = list_all_domains;
+      Journal(3) << " Exporting all geometries" << endl;
+    }
+  if (components_filter.size() == 0)
+    {
+      // Add all fields of the selected geometries
+      components_filter = list_all_fields;
+      Journal(3) << " Exporting all fields:" << endl;
+    }
+  else
+    {
+      // Add all known geometry data fields
+      components_filter.add("SOMMETS");
+      components_filter.add("ELEMENTS");
+      components_filter.add("FACES");
+      components_filter.add("ELEM_FACES");
+      components_filter.add("FACE_VOISINS");
+      components_filter.add("JOINTS_SOMMETS");
+      components_filter.add("JOINTS_ELEMENTS");
+      components_filter.add("JOINTS_FACES");
+      components_filter.add("VIRTUAL_ELEMENTS");
+      // these are for ijk meshs:
+      components_filter.add("SOMMETS_IJK_I");
+      components_filter.add("SOMMETS_IJK_J");
+      components_filter.add("SOMMETS_IJK_K");
+      components_filter.add("INVALID_CONNECTIONS");
+    }
+  filtered_db.filter_db(lata_db, domains_filter, noms_to_motcles(components_filter), timesteps_filter);
+}
diff --git a/Utilities/VisItBridge/databases/readers/Lata/LataFilter.h b/Utilities/VisItBridge/databases/readers/Lata/LataFilter.h
new file mode 100644
index 00000000..da181d3d
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/LataFilter.h
@@ -0,0 +1,253 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef LATA_H_INCLUDE
+#define LATA_H_INCLUDE
+
+#include <LataDB.h>
+#include <LataStructures.h>
+#include <UserFields.h>
+
+using FieldFloat = Field<BigFloatTab>;
+
+// This file provides the LataFilter class: it is a dynamic mesh
+//  and field generator which is able to load data from a lata file,
+//  apply operators. Once computed, the data is kept in a data cache
+//  to speed up further access to the same data.
+
+// This class holds the LataFilter configuration (determines which
+//   combination of operators should be applied to the data)
+class LataOptions
+{
+public:
+  static void extract_path_basename(const char *s, Nom& path_prefix, Nom& basename);
+  static int read_int_opt(const Nom& s);
+  static double read_float_opt(const Nom& s);
+  static Nom read_string_opt(const Nom& s);
+
+  Nom basename; // Name of the case.
+  Nom path_prefix; // Path for the case.
+
+  // Generate de the following meshes and associated data, if the flag is set.
+  bool dual_mesh;
+  bool nc_mesh;
+  bool faces_mesh;
+  bool boundary_mesh;
+
+  bool reconnect;  // Do we want to reconnect multiblock meshes
+  float reconnect_tolerance;
+  int regularize_polyedre; // if 1 Treate polyedre as poyledre extruder
+  int regularize;    // Do we want to force regularize the domain ie convert the mesh to a structured ijk (not necessary except for dual-mesh vdf)
+  // special value 2 means "regularize if faces present and vdf"
+  int extend_domain; // Extend the regularized domaine by n layers of cells
+  float regularize_tolerance;
+  bool invalidate; // invalidate unused positions and connections;
+  bool load_virtual_elements; // Do we want to extend the loaded mesh subblocks with a layer of virtual elements
+  bool export_fields_at_faces_; // Should we show these fields in exportable fields
+
+  // When loading ijk regular meshes, virtually create this number of blocks in the K direction:
+  int ijk_mesh_nb_parts_;
+  // When loading ijk regular meshes, merge N layers of virtual elements (default=1)
+  int ijk_virt_layer;
+
+  bool user_fields_; //activate user fields ?
+
+  ArrOfDouble clipbox_min;
+  ArrOfDouble clipbox_max;
+
+  UserFields_options user_fields_options_;
+
+  LataOptions();
+  virtual int parse_option(const Nom&);
+  virtual void describe();
+  virtual ~LataOptions() { }
+};
+
+class Operator: public LataObject
+{
+public:
+  virtual void build_field(const Domain& src_domain, const LataField_base& src_field, const Domain& dest_domain, LataDeriv<LataField_base>& dest) = 0;
+  virtual void build_geometry(const Domain& src_domain, LataDeriv<Domain>& dest) = 0;
+protected:
+};
+
+struct LataGeometryMetaData
+{
+  Nom internal_name_; // Internal full name (eg DOM_IJK)
+  Nom displayed_name_; // Short name showed to the user (DOM for DOM_IJK, ?? if the geometry should not be exported)
+  bool dynamic_; // Is the geometry changing at each timestep ?
+  int dimension_; // spatial dimension of coordinates
+  Domain::Element element_type_;
+  int nblocks_; // Number of sub_blocks in the geometry (parallel computation)
+  Motcle source_; // How to build this domain ("latadb", "operator_ijk", "operator_dual", "operator_boundary", "user_fields")
+  Nom source_domain_;
+  bool is_ijk_;
+};
+
+struct LataFieldMetaData
+{
+  Field_UName uname_;
+  Nom name_;
+  Nom geometry_name_;
+  Noms component_names_;
+  int nb_components_;
+  bool is_vector_; // Yes => nb_components is equal to spatial dimension
+  LataField_base::Elem_som localisation_;
+  Nom source_localisation_; // Localisation of source field (for displayed name in visit)
+  Motcle source_; // How to build this field ("latadb", "operator_ijk", "operator_dual", "operator_boundary", "user_fields")
+  Field_UName source_field_;
+};
+
+class DataCacheItem
+{
+public:
+  DataCacheItem() : tstep_(-1), last_access_time_(0), lock_(0), memory_size_(0) { }
+  LataDeriv<LataObject> item_; // The cached item
+  Nom id_; // The id for this item
+  int tstep_; // The timestep of the cached data (for cache cleanup)
+  Size_t last_access_time_; // Last time this item has been accessed (for cache cleanup)
+  // Is the item locked ? => cannot be deleted by clear_cache()
+  // This is a counter: get_item increases, release_item dereases.
+  // (this is when we simultaneously need several items, we must lock them to be sure)
+  int lock_;
+  // The memory size is computed when the item is released
+  Size_t memory_size_;
+};
+
+class LataFilterCache
+{
+public:
+  LataFilterCache() : cache_data_access_count_(0), clear_cache_on_tstep_change_(1), cache_memory_limit_(-1) { }
+  void reset()
+  {
+    data_.reset();
+    cache_data_access_count_ = 0;
+  }
+  void set_cache_properties(bool clear_on_tstep_change, Size_t mem_limit);
+  template<class C> C& get_item(const Nom& id, int tstep)
+  {
+    LataDeriv<LataObject>& obj = get_item_(id, tstep);
+    if (obj.non_nul())
+      return obj.refcast(C);
+    else
+      return obj.instancie(C);
+  }
+  void release_item(const Nom& id);
+  void remove_item(const Nom& id);
+  void cleanup_cache(int tstep_to_keep);
+
+protected:
+  LataDeriv<LataObject>& get_item_(const Nom& id, int tstep);
+  // Stored data (depends on caching strategy)
+  // data_ grows when needed.
+  LataVector<DataCacheItem> data_;
+  Size_t cache_data_access_count_;
+  // If nonzero, whenever we ask a timestep,
+  //  remove all cached data from other timesteps
+  bool clear_cache_on_tstep_change_;
+  // If before getting a new geometry or field, the data cache
+  //  uses more than the limit, remove old data until we are below.
+  // -1 means "no limit"
+  Size_t cache_memory_limit_; // Limit in bytes
+};
+
+// Description: This is the MAIN class for the lata filter tool:
+//  It reads data from a lata database on disk (initialize),
+//   and proposes several geometries and fields (get_exportable...) to the user.
+//  The user can get them with get_geometry and get_field.
+//  He must then call release_geometry and release_field to free the memory.
+//  The user can also get metadata information (available without loading all
+//   the data from disk) for geometries and fields and also timestep informations.
+//  Timestep 0 contains global geometry and field definitions, timestep 1..n
+//  are associated with each "TEMPS" entry in the lata file.
+//
+// LataFilter uses a data cache internally: it keeps fields and geometries after
+// the user calls release_xxx(). The cache is controlled by set_cache_properties()
+class LataFilter
+{
+public:
+  LataFilter() : lataDB__(0) { }
+  void initialize(const LataOptions& opt, const LataDB& db);
+  void set_cache_properties(Size_t max_memory, bool keep_all_timesteps);
+  Noms get_exportable_geometry_names() const;
+  const LataGeometryMetaData& get_geometry_metadata(const char *geometry) const;
+  LataVector<Field_UName> get_exportable_field_unames(const char *geometry) const;
+  const LataFieldMetaData& get_field_metadata(const Field_UName& uname) const;
+  int get_nb_timesteps() const;
+  double get_timestep(int i) const;
+
+  const Domain& get_geometry(const Domain_Id&);
+
+  void release_geometry(const Domain&);
+  const LataField_base& get_field(const Field_Id&);
+  const FieldFloat& get_float_field(const Field_Id&);
+
+  void release_field(const LataField_base&);
+
+  const LataDB& get_lataDB() const { return lataDB(); }
+
+  const LataOptions& get_options() const { return opt_; }
+
+protected:
+  Operator& get_set_operator(const Domain_Id& id);
+  LataDeriv<LataField_base>& get_cached_field(const Field_Id&);
+  LataDeriv<Domain>& get_cached_domain(const Domain_Id&);
+  LataDeriv<Operator>& get_cached_operator(const Domain_Id&);
+  void release_cached_domain(const Domain_Id&);
+  void release_cached_field(const Field_Id&);
+  void release_cached_operator(const Domain_Id&);
+  const Domain& get_geom_field_(const Field_Id& id, LataRef<const LataField_base>& field_result);
+  void get_all_metadata(LataVector<LataGeometryMetaData>& geoms_data, LataVector<LataFieldMetaData>& fields_data);
+  // LataDB       & lataDB() { return lataDB__; }
+  const LataDB& lataDB() const
+  {
+    assert(lataDB__);
+    return *lataDB__;
+  }
+
+  // We store in the cache objects of type:
+  //  LataDeriv<Domain>
+  //  derived types of Operator
+  //  LataDeriv<LataField_base>
+  LataFilterCache data_cache_;
+
+  // LataV2 masterfile database
+  const LataDB *lataDB__;
+  LataOptions opt_;
+  // Metadata information for all fields and geometries (built in initialize)
+  LataVector<LataGeometryMetaData> geoms_metadata_;
+  LataVector<LataFieldMetaData> fields_metadata_;
+
+  LataDeriv<UserFields> user_fields_;
+};
+
+struct LataError
+{
+  enum ErrorCode { NEED_REGULAR, NO_FACES, WRONG_ELT_TYPE, INVALID_TSTEP, INVALID_COMPONENT, INVALID_DOMAIN, NOT_A_FLOAT_FIELD, OTHER };
+  LataError(ErrorCode code, const char *msg) : code_(code), msg_(msg) { }
+  ErrorCode code_;
+  const char *msg_;
+};
+
+struct InternalError
+{
+  InternalError(const char *msg) : msg_(msg) { }
+  const char *msg_;
+};
+
+void LataDB_apply_input_filter(const LataDB& lata_db, LataDB& filtered_db, const ArrOfInt& input_timesteps_filter, const Noms& input_domains_filter, const Noms& input_components_filter);
+
+#endif
+
diff --git a/Utilities/VisItBridge/databases/readers/Lata/LataJournal.h b/Utilities/VisItBridge/databases/readers/Lata/LataJournal.h
new file mode 100644
index 00000000..cebef878
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/LataJournal.h
@@ -0,0 +1,25 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef LataJournal_H
+#define LataJournal_H
+
+#include <iostream>
+#include <arch.h>
+
+std::ostream& Journal(int level=0);
+void set_Journal_level(int level);
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/LataStructures.cpp b/Utilities/VisItBridge/databases/readers/Lata/LataStructures.cpp
new file mode 100644
index 00000000..01ff4b71
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/LataStructures.cpp
@@ -0,0 +1,866 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+#include <LataStructures.h>
+#include <LataDB.h>
+#include <stdlib.h>
+static const int info_level = 4;
+
+// Description: returns the number of items of the given type
+trustIdType Domain::nb_items(const LataField_base::Elem_som loc) const
+{
+  trustIdType n = -1;
+  switch (loc)
+    {
+    case LataField_base::SOM:
+      n = nb_nodes();
+      break;
+    case LataField_base::ELEM:
+      n = nb_elements();
+      break;
+    case LataField_base::FACES:
+      n = nb_faces();
+      break;
+    default:
+      Journal() << "Invalid localisation " << (int) loc << " in Domain::nb_items" << endl;
+      throw;
+    }
+  return n;
+}
+
+// Description: returns the offset in the lata block on disk of the first
+//  item for this Domain.id_.block_ (parallel computation).
+//  (this value must be set with set_lata_block_offset)
+trustIdType Domain::lata_block_offset(const LataField_base::Elem_som loc) const
+{
+  trustIdType n = -1;
+  switch (loc)
+    {
+    case LataField_base::SOM:
+      n = decal_nodes_lata_;
+      break;
+    case LataField_base::ELEM:
+      n = decal_elements_lata_;
+      break;
+    case LataField_base::FACES:
+      n = decal_faces_lata_;
+      break;
+    default:
+      Journal() << "Invalid localisation " << (int) loc << " in Domain::lata_block_offset" << endl;
+      throw;
+    }
+  if (n < 0)
+    {
+      Journal() << "Error: lata_block_offset not set for localisation " << (int) loc << endl;
+      throw;
+    }
+  return n;
+}
+
+// Description: set the lata_block_offset (see lata_block_offset)
+void Domain::set_lata_block_offset(const LataField_base::Elem_som loc, trustIdType n)
+{
+  switch (loc)
+    {
+    case LataField_base::SOM:
+      decal_nodes_lata_ = n;
+      break;
+    case LataField_base::ELEM:
+      decal_elements_lata_ = n;
+      break;
+    case LataField_base::FACES:
+      decal_faces_lata_ = n;
+      break;
+    default:
+      Journal() << "Invalid localisation " << (int) loc << " in Domain::set_lata_block_offset" << endl;
+      throw;
+    }
+}
+
+template<class TabType>
+void DomainUnstructured::compute_cell_center_coordinates(TabType& coord, trustIdType index_begin) const
+{
+  using TYPE = typename TabType::Value_type_;    // type stored in TabType
+  const int dim = (int)nodes_.dimension(1);
+  const trustIdType nb_elem = elements_.dimension(0);
+  const int nb_som_elem = (int)elements_.dimension(1);
+  const TYPE facteur = (TYPE)(1.0 / (double)nb_som_elem);
+  TYPE tmp[3];
+  for (trustIdType i = 0; i < nb_elem; i++)
+    {
+      int j, k;
+      tmp[0] = tmp[1] = tmp[2] = 0.;
+      for (j = 0; j < nb_som_elem; j++)
+        {
+          trustIdType som = elements_(i, j);
+          for (k = 0; k < loop_max(dim, 3); k++)
+            {
+              tmp[k] += nodes_(som, k);
+              break_loop(k, dim);
+            }
+        }
+      for (k = 0; k < loop_max(dim, 3); k++)
+        {
+          coord(index_begin + i, k) = tmp[k] * facteur;
+          break_loop(k, dim);
+        }
+    }
+}
+
+template void DomainUnstructured::compute_cell_center_coordinates(BigFloatTab& coord, trustIdType index_begin) const;
+template void DomainUnstructured::compute_cell_center_coordinates(BigDoubleTab& coord, trustIdType index_begin) const;
+
+LataField_base::Elem_som LataField_base::localisation_from_string(const Motcle& loc)
+{
+  if (loc.debute_par("SOM"))
+    return SOM;
+  else if (loc.debute_par("ELEM"))
+    return ELEM;
+  else if (loc.debute_par("FACE"))
+    return FACES;
+  else
+    return UNKNOWN;
+}
+
+Nom LataField_base::localisation_to_string(const Elem_som loc)
+{
+  Nom n;
+  switch(loc)
+    {
+    case SOM:
+      n = "SOM";
+      break;
+    case ELEM:
+      n = "ELEM";
+      break;
+    case FACES:
+      n = "FACES";
+      break;
+    case UNKNOWN:
+      n = "";
+    }
+  return n;
+}
+
+Motcle Domain::lata_element_name(Domain::Element type)
+{
+  switch(type)
+    {
+    case point:
+      return "POINT";
+    case line:
+      return "SEGMENT";
+    case triangle:
+      return "TRIANGLE";
+    case quadri:
+      return "QUADRANGLE";
+    case tetra:
+      return "TETRAEDRE";
+    case hexa:
+      return "HEXAEDRE";
+    case prism6:
+      return "PRISM6";
+    case polyedre:
+      return "POLYEDRE";
+    case polygone:
+      return "POLYGONE";
+    default:
+      return "UNSPECIFIED";
+    }
+}
+
+Domain::Element Domain::element_type_from_string(const Motcle& type_elem)
+{
+  Element type;
+  if (type_elem == "HEXAEDRE")
+    type=hexa;
+  else if (type_elem == "HEXAEDRE_AXI")
+    type=hexa;
+  else if (type_elem == "HEXAEDRE_VEF")
+    type=hexa;
+  else if (type_elem == "QUADRANGLE")
+    type=quadri;
+  else if (type_elem == "QUADRANGLE_3D")
+    type=quadri;
+  else if (type_elem == "RECTANGLE")
+    type=quadri;
+  else if (type_elem == "RECTANGLE_2D_AXI")
+    type=quadri;
+  else if (type_elem == "RECTANGLE_AXI")
+    type=quadri;
+  else if (type_elem == "SEGMENT")
+    type=line;
+  else if (type_elem == "SEGMENT_2D")
+    type=line;
+  else if (type_elem == "TETRAEDRE")
+    type=tetra;
+  else if (type_elem == "TRIANGLE")
+    type=triangle;
+  else if (type_elem == "TRIANGLE_3D")
+    type=triangle;
+  else if (type_elem == "POINT")
+    type=point;
+  else if ((type_elem == "PRISM6")||(type_elem == "PRISME"))
+    type=prism6;
+  else if (type_elem.debute_par("POLYEDRE"))
+    type=polyedre;
+  else if (type_elem.debute_par("POLYGONE"))
+    type=polygone;
+  else
+    {
+      Journal() << "Error in elem_type_from_string: unknown element type " << type_elem << endl;
+      throw;
+    }
+  return type;
+}
+
+Nom Domain::element_type_to_string(Element type)
+{
+  Nom n;
+  switch(type)
+    {
+    case point:
+      n = "POINT";
+      break;
+    case line:
+      n = "SEGMENT";
+      break;
+    case triangle:
+      n = "TRIANGLE";
+      break;
+    case quadri:
+      n = "QUADRANGLE";
+      break;
+    case tetra:
+      n = "TETRAEDRE";
+      break;
+    case hexa:
+      n = "HEXAEDRE";
+      break;
+    case prism6:
+      n = "PRISM6";
+      break;
+    case polyedre:
+      n = "POLYEDRE_0";
+      break;
+    case polygone:
+      n = "POLYGONE";
+      break;
+    case unspecified:
+      n = "UNKNOWN";
+      break;
+    }
+  return n;
+}
+
+// Description: read the specified geometry from the lataDB_ structure and put it in "dom".
+//  load_faces: flag, tells if we should read faces definitions in the lata file
+//  merge_virtual_elements: flag, if a "VIRTUAL_ELEMENTS" array is present in the lata file,
+//   merges these elements to the requested block.
+void DomainUnstructured::fill_domain_from_lataDB(const LataDB& lataDB,
+                                                 const Domain_Id& id,
+                                                 bool load_faces,
+                                                 bool merge_virtual_elements)
+{
+  operator=(DomainUnstructured()); // Reset all data.
+
+  id_ = id;
+  const LataDBGeometry& geom = lataDB.get_geometry(id.timestep_, id.name_);
+
+  // ********************************
+  // 1) Look for the sub-block items to read (parallel computation)
+  trustIdType decal_nodes = 0;
+  trustIdType decal_elements = 0;
+  trustIdType decal_faces = 0;
+  trustIdType nb_sommets = -1;
+  trustIdType nbelements = -1;
+  trustIdType nbfaces = -1;
+
+  bool domain_has_faces = load_faces && lataDB.field_exists(id.timestep_, id.name_, "FACES") && lataDB.field_exists(id.timestep_, id.name_, "ELEM_FACES");
+
+  // Tableau de 3 joints (SOM, ELEM et FACES)
+  LataVector<BigTIDTab> joints;
+  int nproc = 1;
+  for (int i_item = 0; i_item < 3; i_item++)
+    {
+      //    LataField_base::Elem_som loc = LataField_base::SOM;
+      Nom nom("JOINTS_SOMMETS");
+      Nom nom2("SOMMETS");
+      if (i_item == 1)
+        {
+          //loc = LataField_base::ELEM;
+          nom = "JOINTS_ELEMENTS";
+          nom2 = "ELEMENTS";
+        }
+      else if (i_item == 2)
+        {
+          // loc = LataField_base::FACES;
+          nom = "JOINTS_FACES";
+          nom2 = "FACES";
+        }
+
+      BigTIDTab& joint = joints.add();
+      if (lataDB.field_exists(id.timestep_, id.name_, nom))
+        {
+          trustIdType nbitems = lataDB.get_field(id.timestep_, id.name_, nom2, "*").size_;
+          BigTIDTab tmp;
+          lataDB.read_data(lataDB.get_field(id.timestep_, id.name_, nom, "*"), tmp);
+          nproc = (int)tmp.dimension(0);
+          // Recalcule la deuxieme colonne en fonction de la premiere
+          joint.resize(nproc, 2);
+          for (int i = 0; i < nproc; i++)
+            {
+              joint(i, 0) = tmp(i, 0);
+              if (i < nproc-1)
+                joint(i, 1) = tmp(i+1, 0) - tmp(i, 0);
+              else
+                joint(i, 1) = nbitems - tmp(i, 0);
+            }
+        }
+    }
+
+  if (id_.block_ < 0 || nproc == 1)
+    {
+      // read all blocks at once default values are ok
+      set_joints(LataField_base::SOM) = joints[0];
+      set_joints(LataField_base::ELEM) = joints[1];
+      set_joints(LataField_base::FACES) = joints[2];
+    }
+  else
+    {
+      if (id_.block_ >= nproc)
+        {
+          Journal() << "LataFilter::get_geometry : request non existant block " << id.block_
+                    << " in geometry " << id.name_ << endl;
+          throw;
+        }
+      const int n = id_.block_;
+      decal_nodes = joints[0](n, 0);
+      nb_sommets = joints[0](n, 1);
+      decal_elements = joints[1](n, 0);
+      nbelements = joints[1](n, 1);
+      if (domain_has_faces)
+        {
+          decal_faces = joints[2](n, 0);
+          nbfaces = joints[2](n, 1);
+        }
+    }
+
+  // ******************************
+  // 2) Read nodes, elements and faces data
+  elt_type_ = Domain::element_type_from_string(geom.elem_type_);
+
+  if (geom.elem_type_.debute_par("RECTANGLE")) is_rectangle_ = true;
+
+  lataDB.read_data(lataDB.get_field(id.timestep_, id.name_, "SOMMETS", "*"), nodes_, decal_nodes, nb_sommets);
+  lataDB.read_data(lataDB.get_field(id.timestep_, id.name_, "ELEMENTS", "*"), elements_, decal_elements, nbelements);
+  set_lata_block_offset(LataField_base::SOM, decal_nodes);
+  set_lata_block_offset(LataField_base::ELEM, decal_elements);
+  if (decal_nodes > 0)
+    for (int i = 0; i < elements_.dimension(0); i++)
+      for (int j = 0; j < elements_.dimension(1); j++)
+        if (elements_(i, j) >= 0)
+          elements_(i, j) -= decal_nodes;
+  if (domain_has_faces)
+    {
+      //cerr << "Domain has faces..." << endl;
+      set_lata_block_offset(LataField_base::FACES, decal_faces);
+      lataDB.read_data(lataDB.get_field(id.timestep_, id.name_, "FACES", "*"), faces_, decal_faces, nbfaces);
+      if (decal_nodes > 0)
+        for (int i = 0; i < faces_.dimension(0); i++)
+          for (int j = 0; j < faces_.dimension(1); j++)
+            if (faces_(i, j) >= 0)
+              faces_(i, j) -= decal_nodes;
+      lataDB.read_data(lataDB.get_field(id.timestep_, id.name_, "ELEM_FACES", "*"), elem_faces_, decal_elements, nbelements);
+      if (decal_faces > 0)
+        for (int i = 0; i < elem_faces_.dimension(0); i++)
+          for (int j = 0; j < elem_faces_.dimension(1); j++)
+            if (elem_faces_(i, j) >= 0)
+              elem_faces_(i, j) -= decal_faces;
+      if (lataDB.field_exists(id.timestep_, id.name_, "FACE_VOISINS")) //TRUST a ecrit face_voisins
+        {
+          lataDB.read_data(lataDB.get_field(id.timestep_, id.name_, "FACE_VOISINS", "*"), face_voisins_, decal_faces, nbfaces);          
+          if (decal_elements > 0)
+            for (int i = 0; i < face_voisins_.dimension(0); i++)
+              for (int j = 0; j < face_voisins_.dimension(1); j++)
+                if (face_voisins_(i, j) >= 0)
+                  face_voisins_(i, j) -= decal_elements;
+        }
+      else  //sinon : construction manuelle
+        {
+          face_voisins_.resize(faces_.dimension(0), 2);
+          for (int f = 0; f < face_voisins_.dimension(0); f++)
+            for (int i = 0; i < 2; i++)
+              face_voisins_(f, i) = -1;
+          for (int e = 0; e < elem_faces_.dimension(0); e++)
+            {
+              trustIdType f;
+              for (int i = 0; i < elem_faces_.dimension(1) && (f = elem_faces_(e, i)) >= 0; i++)
+                face_voisins_(f, face_voisins_(f, 0) >= 0) = e;
+            }
+        }
+    }
+
+  // *************************
+  // 3) Merge virtual elements if requested
+  if (merge_virtual_elements && lataDB.field_exists(id.timestep_, id.name_, "VIRTUAL_ELEMENTS") && id.block_ >= 0)
+    {
+      Journal(info_level) << " Merging virtual elements" << endl;
+      // joints_virt_elems(sub_block, 0) = index of first virtual element in the VIRTUAL_ELEMENTS array
+      BigTIDTab joints_virt_elems;
+      // Load the virtual elements (nodes are in global numbering)
+      //  First: find the index and number of virtual elements for block number id.block_:
+      lataDB.read_data(lataDB.get_field(id.timestep_, id.name_, "JOINTS_VIRTUAL_ELEMENTS", "*"), joints_virt_elems);
+      trustIdType nb_virt_elems;
+      if (id.block_ < nproc-1)
+        nb_virt_elems = joints_virt_elems(id.block_+1, 0) - joints_virt_elems(id.block_, 0);
+      else
+        nb_virt_elems = (int)lataDB.get_field(id.timestep_, id.name_, "VIRTUAL_ELEMENTS", "*").size_ - joints_virt_elems(id.block_, 0);
+      Journal(info_level+1) << " Number of virtual elements for block " << id.block_ << "=" << nb_virt_elems << endl;
+      //  Second: load the indexes of the virtual elements to load:
+      BigTIDTab virt_elems;
+      lataDB.read_data(lataDB.get_field(id.timestep_, id.name_, "VIRTUAL_ELEMENTS", "*"), virt_elems, joints_virt_elems(id.block_,0), nb_virt_elems);
+      set_virt_items(LataField_base::ELEM, virt_elems);
+
+      {
+        //  Third: load the virtual elements (virt_elems contains the global indexes of the elements to
+        //  load and virt_elem_som will contain global nodes indexes of the virtual elements)
+        BigTIDTab virt_elem_som;
+        lataDB.read_data(lataDB.get_field(id.timestep_, id.name_, "ELEMENTS", "*"), virt_elem_som, virt_elems);
+        // Find which virtual nodes are required and load them: virtual nodes to load are
+        // all nodes of the virtual elements (they have duplicates).
+        BigArrOfTID index;
+        BigTIDTab& virt_elem_som_array = virt_elem_som;  // Array seen as monodimensionnal
+        array_sort_indirect(virt_elem_som_array, index);
+        // Global nodes indexes of needed virtual nodes
+        BigArrOfTID nodes_to_read;
+        {
+          const trustIdType n = index.size_array();
+          // Global index of the last loaded node:
+          trustIdType last_node = -1;
+          // Local index of the new loaded node:
+          trustIdType new_node_index = nodes_.dimension(0)-1;
+          for (trustIdType i = 0; i < n; i++)
+            {
+              // Take nodes to load in ascending order of their global numbers:
+              const trustIdType idx = index[i];
+              const trustIdType node = virt_elem_som_array[idx];
+              if (node != last_node)
+                {
+                  // Node not yet encountered
+                  nodes_to_read.append_array(node);
+                  new_node_index++;
+                  last_node = node;
+                }
+              virt_elem_som_array[idx] = new_node_index;
+            }
+        }
+        set_virt_items(LataField_base::SOM, nodes_to_read);
+        // Copy virtual elements to elements_
+        trustIdType debut = elements_.size_array();
+        elements_.resize(elements_.dimension(0) + virt_elem_som.dimension(0),
+                         (int)elements_.dimension(1));
+        elements_.inject_array(virt_elem_som, virt_elem_som.size_array(), debut);
+        // Load virtual nodes
+        BigFloatTab tmp_nodes;
+        lataDB.read_data(lataDB.get_field(id.timestep_, id.name_, "SOMMETS", "*"), tmp_nodes, nodes_to_read);
+        // Copy to nodes_
+        debut = nodes_.size_array();
+        nodes_.resize(nodes_.dimension(0) + tmp_nodes.dimension(0),
+                      (int)nodes_.dimension(1));
+        nodes_.inject_array(tmp_nodes, tmp_nodes.size_array(), debut);
+      }
+
+      if (domain_has_faces)
+        {
+          // Find which virtual faces are required and load them
+          // For each virtual element, index of its faces (like virt_elem_som)
+          BigTIDTab virt_elem_faces;
+          lataDB.read_data(lataDB.get_field(id.timestep_, id.name_, "ELEM_FACES", "*"), virt_elem_faces, virt_elems);
+          // Build the list of missing faces:
+          BigArrOfTID index;
+          BigArrOfTID& virt_elem_faces_array = virt_elem_faces;  // Array seen as monodimensionnal
+          array_sort_indirect(virt_elem_faces_array, index);
+          BigArrOfTID faces_to_read;
+          {
+            const trustIdType n = index.size_array();
+            // Global index of the last loaded face:
+            trustIdType last_face = -1;
+            // Local index of the new loaded node:
+            trustIdType new_face_index = faces_.dimension(0)-1;
+            for (trustIdType i = 0; i < n; i++)
+              {
+                // Take nodes to load in ascending order of their global numbers:
+                const trustIdType idx = index[i];
+                const trustIdType face = virt_elem_faces_array[idx];
+                if (face != last_face)
+                  {
+                    // Node not yet encountered
+                    faces_to_read.append_array(face);
+                    new_face_index++;
+                    last_face = face;
+                  }
+                virt_elem_faces_array[idx] = new_face_index;
+              }
+          }
+          set_virt_items(LataField_base::FACES, faces_to_read);
+          // Copy virtual elem_faces to elem_faces
+          trustIdType debut = elem_faces_.size_array();
+          elem_faces_.resize(elem_faces_.dimension(0) + virt_elem_faces.dimension(0),
+                             (int)elem_faces_.dimension(1));
+          elem_faces_.inject_array(virt_elem_faces, virt_elem_faces.size_array(), debut);
+
+          // Load virtual faces
+          BigTIDTab tmp_faces_nodes;
+          lataDB.read_data(lataDB.get_field(id.timestep_, id.name_, "FACES", "*"), tmp_faces_nodes, faces_to_read);
+          // Convert global nodes indexes to local loaded nodes indexes in tmp_faces_nodes
+          {
+            // sort tmp_faces in ascending order so that the search requires linear time
+            BigArrOfTID& array_tmp_faces_nodes = tmp_faces_nodes;
+            index.reset();
+            array_sort_indirect(array_tmp_faces_nodes, index);
+            const trustIdType n = array_tmp_faces_nodes.size_array();
+            // Take nodes in tmp_faces_nodes in ascending order and find the corresponding node in nodes_to_read
+            // (which is also in sorted)
+            trustIdType i1; // index in array_tmp_faces_nodes (the current node to convert)
+            trustIdType i2 = 0; // index in nodes_to_read
+            const trustIdType index_of_first_virtual_node = nodes_.dimension(0) - nb_virt_items(LataField_base::SOM);
+            const BigArrOfTID& nodes_to_read = get_virt_items(LataField_base::SOM);
+            const trustIdType max_i2 = nodes_to_read.size_array();
+            for (i1 = 0; i1 < n; i1++)
+              {
+                const trustIdType j = index[i1];
+                const trustIdType global_node_index_to_find = array_tmp_faces_nodes[j];
+                // find the matching node in nodes_to_read (nodes_to_read is in ascending order)
+                while (nodes_to_read[i2] != global_node_index_to_find)
+                  {
+                    i2++;
+                    if (i2 >= max_i2)
+                      {
+                        cerr << "Internal error in DomainUnstructured::fill_domain_from_lataDB:\n"
+                             << " node " << global_node_index_to_find << " of a virtual face does not belong to a virtual element" << endl;
+                        throw;
+                      }
+                  }
+                array_tmp_faces_nodes[j] = index_of_first_virtual_node + i2; // index of this node in the local nodes_ array
+              }
+          }
+          // Copy to faces_ array
+          debut = faces_.size_array();
+          faces_.resize(faces_.dimension(0) + tmp_faces_nodes.dimension(0),
+                        (int)faces_.dimension(1));
+          faces_.inject_array(tmp_faces_nodes, tmp_faces_nodes.size_array(), debut);
+        }
+    }
+}
+
+void Domain::fill_field_from_lataDB(const LataDB& lataDB,
+                                    const Field_Id& id,
+                                    LataDeriv<LataField_base>& field) const
+{
+  Journal() << "Error : fill_field_from_lataDB not coded for this domain type" << endl;
+  throw;
+}
+
+// Reads the requested field to "field" structure.
+// id.block_ is not used, the data block read is the same as the domain.
+void DomainUnstructured::fill_field_from_lataDB(const LataDB& lataDB,
+                                                const Field_Id& id,
+                                                LataDeriv<LataField_base>& field) const
+{
+  const LataDBField& lata_field = lataDB.get_field(id.timestep_, id.uname_);
+  LataField_base::Elem_som loc = LataField_base::localisation_from_string(lata_field.localisation_);
+  const trustIdType decal = lata_block_offset(loc);
+
+  const BigArrOfTID& virt_items = get_virt_items(loc);
+  const trustIdType virt_size = virt_items.size_array();
+  const trustIdType size = nb_items(loc) - virt_size;
+
+  const LataDBDataType& type = lata_field.datatype_;
+  switch(type.type_)
+    {
+    case LataDBDataType::REAL32:
+      {
+        BigFloatTab& data = field.instancie(Field<BigFloatTab> ).data_;
+        lataDB.read_data(lata_field, data, decal, size);
+        if (virt_size > 0)
+          {
+            BigFloatTab tmp;
+            lataDB.read_data(lata_field, tmp, virt_items);
+            const trustIdType debut = data.size_array();
+            data.resize(data.dimension(0)+virt_size, (int)data.dimension(1));
+            data.inject_array(tmp, virt_size, debut);
+          }
+        break;
+      }
+    case LataDBDataType::REAL64:
+      {
+        BigDoubleTab& data = field.instancie(Field<BigDoubleTab> ).data_;
+        lataDB.read_data(lata_field, data, decal, size);
+        if (virt_size > 0)
+          {
+            BigDoubleTab tmp;
+            lataDB.read_data(lata_field, tmp, virt_items);
+            const trustIdType debut = data.size_array();
+            data.resize(data.dimension(0)+virt_size, (int)data.dimension(1));
+            data.inject_array(tmp, virt_size, debut);
+          }
+        break;
+      }
+    case LataDBDataType::INT32:
+    case LataDBDataType::INT64:
+      {
+        BigTIDTab& data = field.instancie(Field<BigTIDTab> ).data_;
+        lataDB.read_data(lata_field, data, decal, size);
+        if (virt_size > 0)
+          {
+            BigTIDTab tmp;
+            lataDB.read_data(lata_field, tmp, virt_items);
+            const trustIdType debut = data.size_array();
+            data.resize(data.dimension(0)+virt_size, (int)data.dimension(1));
+            data.inject_array(tmp, virt_size, debut);
+          }
+        break;
+      }
+    default:
+      Journal() << "LataFilter::get_field_from_lataDB " << id.uname_ << ": data type not implemented" << endl;
+      throw;
+    }
+  field.valeur().id_ = id;
+  field.valeur().component_names_ = lata_field.component_names_;
+  field.valeur().localisation_ = loc;
+  field.valeur().nature_ = lata_field.nature_;
+}
+
+DomainIJK::DomainIJK()
+{
+  part_begin_ = 0;
+  part_end_ = 0;
+  virtual_layer_begin_ = 0;
+  virtual_layer_end_ = 0;
+}
+
+void DomainIJK::fill_domain_from_lataDB(const LataDB& lataDB,
+                                        const Domain_Id& id,
+                                        int split_in_N_parts,
+                                        const int virt_layer_size)
+{
+  if (virt_layer_size < 0)
+    {
+      Journal() << "Error in DomainIJK::fill_domain_from_lataDB: virt_layer_size < 0" << endl;
+      throw;
+    }
+  id_ = id;
+
+  Journal(info_level) << "Filling ijk domain " << id.name_ << " tstep " << id.timestep_ << " block " << id.block_ << endl;
+  coord_.reset();
+  int dim3 = lataDB.field_exists(id.timestep_, id.name_, "SOMMETS_IJK_K", LataDB::FIRST_AND_CURRENT /* timestep */);
+  {
+    const LataDBField& coord = lataDB.get_field(id.timestep_,
+                                                Field_UName(id.name_, "SOMMETS_IJK_I", ""),
+                                                LataDB::FIRST_AND_CURRENT /* timestep */);
+    BigFloatTab tmp;
+    lataDB.read_data(coord, tmp);
+    coord_.add();
+    FloatTab tmp2;
+    tmp.ref_as_small(tmp2);
+    coord_[0] = tmp2;
+  }
+  {
+    const LataDBField& coord = lataDB.get_field(id.timestep_,
+                                                Field_UName(id.name_, "SOMMETS_IJK_J", ""),
+                                                LataDB::FIRST_AND_CURRENT /* timestep */);
+    BigFloatTab tmp;
+    lataDB.read_data(coord, tmp);
+    coord_.add();
+    FloatTab tmp2;
+    tmp.ref_as_small(tmp2);
+    coord_[1] = tmp2;
+  }
+  if (dim3)
+    {
+      const LataDBField& coord = lataDB.get_field(id.timestep_,
+                                                  Field_UName(id.name_, "SOMMETS_IJK_K", ""),
+                                                  LataDB::FIRST_AND_CURRENT /* timestep */);
+      BigFloatTab tmp;
+      lataDB.read_data(coord, tmp);
+      coord_.add();
+      FloatTab tmp2;
+      tmp.ref_as_small(tmp2);
+      coord_[2] = tmp2;
+    }
+
+  elt_type_ = dim3 ? hexa : quadri;
+
+  int block = (id.block_) < 0 ? 0 : id.block_;
+
+  if (id.block_ >= split_in_N_parts)
+    {
+      Journal() << "Error in DomainIJK::fill_domain_from_lataDB: invalid block " << id.block_ << endl;
+      throw;
+    }
+
+  // Load the N-th part
+  //  The ijk domain is virtually split in the Z direction (or Y en 2D)
+  int maxdim = coord_.size() - 1;
+  // Number of elements in the Z direction:
+  const int nelem = coord_[maxdim].size_array() - 1;
+  int part_size = nelem / split_in_N_parts;
+  if (part_size * split_in_N_parts < nelem)
+    part_size++;
+
+  // Begin and end of the requested part:
+  part_begin_ = part_size * block - virt_layer_size;
+  if (part_begin_ < 0)
+    part_begin_ = 0;
+  part_end_ = part_size * block + part_size + virt_layer_size;
+  if (part_end_ > nelem)
+    part_end_ = nelem;
+  if (part_begin_ > part_end_)
+    // empty block
+    part_begin_ = part_end_ = 0;
+
+  if (block > 0 && part_end_ > part_begin_)
+    // There is a virtual layer at the begin
+    virtual_layer_begin_ = virt_layer_size;
+  if (block < split_in_N_parts-1 && part_end_ > part_begin_)
+    virtual_layer_end_ = virt_layer_size;
+
+  // Extract coordinates:
+  ArrOfFloat tmp(coord_[maxdim]);
+  const int n = part_end_ - part_begin_ + 1;
+  coord_[maxdim].resize_array(n);
+  for (int i = 0; i < n; i++)
+    coord_[maxdim][i] = tmp[i + part_begin_];
+
+  Journal(info_level) << "Domain " << id.name_ << " has number of nodes: [ ";
+  for (int dim = 0; dim < coord_.size(); dim++)
+    Journal(info_level) << coord_[dim].size_array() << " ";
+  Journal(info_level) << "]" << endl;
+
+  if (part_end_ > part_begin_ // part might be empty if too many processors
+      && lataDB.field_exists(id.timestep_, id.name_, "INVALID_CONNECTIONS", LataDB::FIRST_AND_CURRENT /* timestep */))
+    {
+      Journal(info_level) << " loading invalid_connections" << endl;
+      BigIntTab Itmp;
+      trustIdType ij = 0, offset = 0, sz = 0;
+      // Product of number of elements in directions I and J
+      ij = coord_[0].size_array() - 1;
+      if (coord_.size() > 2)
+        ij *= coord_[1].size_array() - 1;
+      // Select a range of elements in direction K
+      offset = ij * part_begin_;
+      sz = nb_elements();
+      const LataDBField& lata_field = lataDB.get_field(id.timestep_,  id.name_, "INVALID_CONNECTIONS", "ELEM",
+                                                       LataDB::FIRST_AND_CURRENT);
+
+      lataDB.read_data(lata_field, Itmp, offset, sz);
+
+      invalid_connections_.resize_array(nb_elements());
+      invalid_connections_ = 0; // everything valid by default
+
+      for (int i = 0; i < sz; i++)
+        {
+          if (Itmp(i, 0) != 0)
+            invalid_connections_.setbit(i);
+        }
+    }
+}
+
+void DomainIJK::fill_field_from_lataDB(const LataDB& lataDB,
+                                       const Field_Id& id,
+                                       LataDeriv<LataField_base>& field) const
+{
+  const LataDBField& lata_field = lataDB.get_field(id.timestep_, id.uname_);
+  LataField_base::Elem_som loc = LataField_base::localisation_from_string(lata_field.localisation_);
+
+  int ij = 0, offset = 0, sz = 0;
+  switch(loc)
+    {
+    case LataField_base::ELEM:
+      // Product of number of elements in directions I and J
+      ij = coord_[0].size_array() - 1;
+      if (coord_.size() > 2)
+        ij *= coord_[1].size_array() - 1;
+      // Select a range of elements in direction K
+      offset = ij * part_begin_;
+      sz = ij * (part_end_ - part_begin_);
+      break;
+    case LataField_base::SOM:
+    case LataField_base::FACES:
+      // Product of number of nodes in directions I and J
+      ij = coord_[0].size_array();
+      if (coord_.size() > 2)
+        ij *= coord_[1].size_array();
+      offset = ij * part_begin_;
+      sz = ij * (part_end_ + 1 - part_begin_);
+      break;
+    default:
+      Journal() << "Error in DomainIJK::fill_field_from_lataDB: unknown localisation" << endl;
+      throw;
+    }
+
+  const LataDBDataType& type = lata_field.datatype_;
+  switch(type.type_)
+    {
+    case LataDBDataType::REAL32:
+      {
+        BigFloatTab& data = field.instancie(Field<BigFloatTab> ).data_;
+        lataDB.read_data(lata_field, data, offset, sz);
+        break;
+      }
+    case LataDBDataType::REAL64:
+      {
+        BigDoubleTab& data = field.instancie(Field<BigDoubleTab> ).data_;
+        lataDB.read_data(lata_field, data, offset, sz);
+        break;
+      }
+    case LataDBDataType::INT32:
+    case LataDBDataType::INT64:
+      {
+        BigTIDTab& data = field.instancie(Field<BigTIDTab> ).data_;
+        lataDB.read_data(lata_field, data, offset, sz);
+        break;
+      }
+    default:
+      Journal() << "LataFilter::get_field_from_lataDB " << id.uname_ << ": data type not implemented" << endl;
+      throw;
+    }
+  field.valeur().id_ = id;
+  field.valeur().component_names_ = lata_field.component_names_;
+  field.valeur().localisation_ = loc;
+  field.valeur().nature_ = lata_field.nature_;
+}
+
+
+Domain::DomainType Domain::get_domain_type() const
+{
+  const DomainUnstructured* geom_ptr = dynamic_cast<const DomainUnstructured*>(this);
+  if (geom_ptr!=0)
+    return UNSTRUCTURED;
+  const DomainIJK* ijk_ptr = dynamic_cast<const DomainIJK*>(this);
+  if (ijk_ptr!=0)
+    return IJK;
+  throw ("Not implemeneted");
+}
+
+const DomainUnstructured& Domain::cast_DomainUnstructured() const
+{
+  return dynamic_cast<const DomainUnstructured&>(*this);
+}
+
+const DomainIJK&   Domain::cast_DomainIJK() const
+{
+  return dynamic_cast<const DomainIJK&>(*this);
+}
diff --git a/Utilities/VisItBridge/databases/readers/Lata/LataStructures.h b/Utilities/VisItBridge/databases/readers/Lata/LataStructures.h
new file mode 100644
index 00000000..0b830b44
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/LataStructures.h
@@ -0,0 +1,384 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef LataStructures_H
+#define LataStructures_H
+
+#include <ArrOfBit.h>
+#include <LataTools.h>
+#include <LataDB.h>
+
+// This file contains definitions of data structures containind meshes and fields
+//  used by LataFilter.
+
+// Description: Domain_Id is what you need to identify the content
+//  of a Domain object (at this time, the domain name, the timestep and the
+//  parallel sub_block number)
+class Domain_Id
+{
+public:
+  Domain_Id(const char *name = "??", int t = 0, int block = -1) : name_(name), timestep_(t), block_(block) { }
+  // Domain name
+  Nom name_;
+  // At which timestep (needed for dynamic domains)
+  int timestep_;
+  // Which block of the parallel computation ? -1 => all blocks
+  int block_;
+};
+
+// Description: Field_Id is what you need to identify the content of a
+//  LataField_base structure (at this time, the field uname,
+//  the timestep and the parallel sub_block number)
+class Field_Id
+{
+public:
+  Field_Id() : timestep_(0), block_(-1) { }
+  Field_Id(const Field_UName& uname, int timestep, int block) : timestep_(timestep), block_(block), uname_(uname) { }
+
+  int timestep_;
+  int block_;
+  Field_UName uname_;
+
+  operator Domain_Id() const { return Domain_Id(uname_.get_geometry(), timestep_, block_); }
+};
+
+// Description: This structure contains a discrete data array for a specific
+//  field, at one timestep, for one sub_block of the geometry, with
+//  one localisation (but many components)
+class LataField_base: public LataObject
+{
+public:
+  LataField_base()
+  {
+    localisation_ = UNKNOWN;
+    nature_ = LataDBField::UNKNOWN;
+  }
+  Field_Id id_;
+  Noms component_names_;
+  enum Elem_som { ELEM, SOM, FACES, UNKNOWN };
+  Elem_som localisation_;
+  LataDBField::Nature nature_;
+
+  static Elem_som localisation_from_string(const Motcle&);
+  static Nom localisation_to_string(const Elem_som);
+};
+class DomainUnstructured;
+class DomainIJK;
+
+// This class stores the geometry of a domain
+class Domain: public LataObject
+{
+public:
+  Domain_Id id_;
+  enum Element { point, line, triangle, quadri, tetra, hexa, prism6, polyedre, polygone, unspecified };
+  enum DomainType { IJK, UNSTRUCTURED };
+  static Element element_type_from_string(const Motcle& type_elem);
+  static Nom element_type_to_string(Element type);
+  Element elt_type_;
+
+  Domain() :
+    elt_type_(unspecified), decal_nodes_lata_(-1), // -1 indicates: value not set. see lata_block_offset
+    decal_elements_lata_(-1), decal_faces_lata_(-1) { } ;
+  DomainType get_domain_type() const;
+  const DomainUnstructured& cast_DomainUnstructured() const;
+  const DomainIJK& cast_DomainIJK() const;
+  virtual int dimension() const = 0;
+  virtual trustIdType nb_nodes() const = 0;
+  virtual trustIdType nb_elements() const = 0;
+  virtual trustIdType nb_faces() const = 0;
+  virtual trustIdType nb_items(const LataField_base::Elem_som) const;
+  virtual trustIdType lata_block_offset(const LataField_base::Elem_som) const;
+  virtual void set_lata_block_offset(const LataField_base::Elem_som, trustIdType n);
+
+  virtual void fill_field_from_lataDB(const LataDB& lataDB, const Field_Id& id, LataDeriv<LataField_base>& field) const = 0;
+
+  static Motcle lata_element_name(Domain::Element type);
+
+  const bool& is_rectangle() const { return is_rectangle_;}
+
+protected:
+  // If the Domain has been loaded from a lata file and it's not the
+  // first block this is the offset in the lata file:
+  trustIdType decal_nodes_lata_;
+  trustIdType decal_elements_lata_;
+  trustIdType decal_faces_lata_;
+  bool is_rectangle_ = false;
+};
+
+class DomainUnstructured: public Domain
+{
+public:
+  DomainUnstructured()
+  {
+    nb_virt_nodes_ = 0;
+    nb_virt_elements_ = 0;
+    nb_virt_faces_ = 0;
+  }
+
+  BigFloatTab nodes_;
+  // For each element, indexes of the nodes (first node is at index 0)
+  // Nodes ordering in an element is the same as in TRUST
+  BigTIDTab elements_;
+  // For each face, indexes of the nodes (if present in lata file)
+  BigTIDTab faces_;
+  // For each elements, indexes of the faces (first face at index 0, if present in lata file)
+  // Faces ordering in an element is the same as in TRUST
+  BigTIDTab elem_faces_;
+  // For each face, indices of its neighbors (-1 if none)
+  BigTIDTab face_voisins_;
+
+  int dimension() const override { return (int)nodes_.dimension(1); }
+  trustIdType nb_nodes() const override { return nodes_.dimension(0); }
+  trustIdType nb_elements() const override { return elements_.dimension(0); }
+  trustIdType nb_faces() const override { return faces_.dimension(0); }
+  // Tests if the geometry contains faces description
+  bool faces_ok() const { return elem_faces_.dimension(0) == elements_.dimension(0); }
+
+  template<typename TabType>
+  void compute_cell_center_coordinates(TabType& coord, trustIdType index_begin) const;
+
+  Size_t compute_memory_size() const override { return memory_size(nodes_) + memory_size(elements_) + memory_size(faces_) + memory_size(elem_faces_); }
+
+  const BigTIDTab& get_joints(LataField_base::Elem_som loc) const
+  {
+    const BigTIDTab *ptr = 0;
+    switch(loc)
+      {
+      case LataField_base::SOM:
+        ptr = &joints_sommets_;
+        break;
+      case LataField_base::ELEM:
+        ptr = &joints_elements_;
+        break;
+      case LataField_base::FACES:
+        ptr = &joints_faces_;
+        break;
+      default:
+        throw;
+      }
+    if (ptr->dimension(1) == 0)
+      throw;
+    return *ptr;
+  }
+
+  BigTIDTab& set_joints(LataField_base::Elem_som loc)
+  {
+    BigTIDTab *ptr = 0;
+    switch(loc)
+      {
+      case LataField_base::SOM:
+        ptr = &joints_sommets_;
+        break;
+      case LataField_base::ELEM:
+        ptr = &joints_elements_;
+        break;
+      case LataField_base::FACES:
+        ptr = &joints_faces_;
+        break;
+      default:
+        throw;
+      }
+    return *ptr;
+  }
+
+  const BigArrOfTID& get_virt_items(LataField_base::Elem_som loc) const
+  {
+    switch(loc)
+      {
+      case LataField_base::SOM:
+        return virt_nodes_;
+      case LataField_base::ELEM:
+        return virt_elements_;
+      case LataField_base::FACES:
+        return virt_faces_;
+      default:
+        throw;
+      }
+  }
+
+  void set_virt_items(LataField_base::Elem_som loc, const BigArrOfTID& list)
+  {
+    switch(loc)
+      {
+      case LataField_base::SOM:
+        virt_nodes_ = list;
+        nb_virt_nodes_ = list.size_array();
+        break;
+      case LataField_base::ELEM:
+        virt_elements_ = list;
+        nb_virt_elements_ = list.size_array();
+        break;
+      case LataField_base::FACES:
+        virt_faces_ = list;
+        nb_virt_faces_ = list.size_array();
+        break;
+      default:
+        throw;
+      }
+  }
+
+  void set_nb_virt_items(LataField_base::Elem_som loc, trustIdType n)
+  {
+    switch(loc)
+      {
+      case LataField_base::SOM:
+        nb_virt_nodes_ = n;
+        break;
+      case LataField_base::ELEM:
+        nb_virt_elements_ = n;
+        break;
+      case LataField_base::FACES:
+        nb_virt_faces_ = n;
+        break;
+      default:
+        throw;
+      }
+  }
+
+  trustIdType nb_virt_items(LataField_base::Elem_som loc) const
+  {
+    switch(loc)
+      {
+      case LataField_base::SOM:
+        return nb_virt_nodes_;
+      case LataField_base::ELEM:
+        return nb_virt_elements_;
+      case LataField_base::FACES:
+        return nb_virt_faces_;
+      default:
+        throw;
+      }
+  }
+
+  virtual void fill_domain_from_lataDB(const LataDB& lataDB, const Domain_Id& id, bool load_faces=true, bool merge_virtual_elements=false);
+  virtual void fill_field_from_lataDB(const LataDB& lataDB, const Field_Id& id, LataDeriv<LataField_base>& field) const override;
+
+protected:
+  // data not always filled:
+  BigTIDTab joints_sommets_;
+  BigTIDTab joints_elements_;
+  BigTIDTab joints_faces_;
+  BigArrOfTID virt_nodes_; // Global indexes of virtual nodes to load
+  BigArrOfTID virt_elements_; // Global indexes of virtual elements to load
+  BigArrOfTID virt_faces_; // Global indexes of virtual faces to load
+  trustIdType nb_virt_nodes_;
+  trustIdType nb_virt_elements_;
+  trustIdType nb_virt_faces_;
+};
+
+// This is a structured grid, grid axes aligned on X, Y and Z.
+// The grid can have "invalid_positions_" and "invalid_connections_".
+// Nodes are numbered like this:
+//  node_index(i,j,k) = (k * nb_nodes_y + j) * nb_nodes_x + i
+// Elements are numbered like this:
+//  element_index(i,j,k) = (k * nb_elements_y + j) * nb_elements_x + i
+// Faces are numbered like this: faces of each direction have a numbering starting at zero.
+//  The number of a particular face is the smallest number of its nodes.
+//  Hence some numbers are not used (le last face of each "row" depending on the
+//  direction)
+//
+//  For IJK we make a strong assumption: the total number of elements, or faces, or nodes can be big (greater than 32bits)
+//  **but** in each direction, the number of steps (or points) always fits within 32 bits.
+class DomainIJK: public Domain
+{
+public:
+  DomainIJK();
+  // In each spatial direction, ordered list of coordinates of the IJK grid
+  LataVector<ArrOfFloat> coord_;
+
+  // For each node and each element, flag indicates if it is valid or not
+  // (eg, has usable field values)
+  // If array is empty, all data is valid.
+  BigArrOfBit invalid_positions_;
+  BigArrOfBit invalid_connections_;
+
+  int dimension() const override { return coord_.size(); }
+  trustIdType nb_nodes() const override
+  {
+    trustIdType n = 1;
+    int d = coord_.size();
+    for (int i = 0; i < d; i++)
+      n *= coord_[i].size_array();
+    return n;
+  }
+
+  trustIdType nb_elements() const override
+  {
+    trustIdType n = 1;
+    int d = coord_.size();
+    for (int i = 0; i < d; i++)
+      n *= coord_[i].size_array() - 1;
+    return n;
+  }
+
+  // Dimension(0) des tableaux de valeurs aux faces
+  //  (voir convention sur la numerotation des faces)
+  //  les champs associes aux faces des differentes directions sont
+  //  stockes dans les composantes du champ.
+  trustIdType nb_faces() const override { return nb_nodes(); }
+
+  Size_t compute_memory_size() const override
+  {
+    Size_t x = 0;
+    const int n = coord_.size();
+    for (int i = 0; i < n; i++)
+      x += memory_size(coord_[i]);
+    return x + memory_size(invalid_positions_) + memory_size(invalid_connections_);
+  }
+
+  // renvoie le nombre de sommets dans la direction dir
+  //  (renvoie 1 si dir >= dimension())
+  int nb_som_dir(int dir) const
+  {
+    if (dir >= dimension())
+      return 1;
+    else
+      return coord_[dir].size_array();
+  }
+
+  // renvoie le nombre d'elements dans la direction dir
+  //  (renvoie 1 si dir >= dimension())
+  int nb_elem_dir(int dir) const
+  {
+    if (dir >= dimension())
+      return 1;
+    else
+      return coord_[dir].size_array() - 1;
+  }
+
+  virtual void fill_domain_from_lataDB(const LataDB& lataDB, const Domain_Id& id, const int split_in_nparts=1, const int virt_layer_size=1);
+  void fill_field_from_lataDB(const LataDB& lataDB, const Field_Id& id, LataDeriv<LataField_base>& field) const override;
+
+  // when loading fields, we will load elements (i,j,k) with
+  //   part_begin_ <= k < part_end_
+  // (or j in 2D), part_begin_ and part_end_ include the virtual layer
+  int part_begin_;
+  int part_end_;
+  // number of layers of virtual elements at each side:
+  int virtual_layer_begin_;
+  int virtual_layer_end_;
+};
+
+template<class TabType>
+class Field: public LataField_base
+{
+public:
+  TabType data_;
+  Size_t compute_memory_size() const override
+  {
+    return memory_size(data_);
+  }
+};
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/LataTools.cpp b/Utilities/VisItBridge/databases/readers/Lata/LataTools.cpp
new file mode 100644
index 00000000..f3e60da2
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/LataTools.cpp
@@ -0,0 +1,108 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <LataTools.h>
+#include <sstream>
+#include <string.h>
+#include <stdlib.h>
+
+static int journal_level = 0;
+
+void set_Journal_level(int level)
+{
+  if (journal_level==level) return;
+  journal_level = level;
+  Journal() << "Changed lata journal level: " << journal_level << endl;
+}
+
+static std::ostringstream junk_journal;
+
+std::ostream& Journal(int level)
+{
+  if (level <= journal_level)
+    {
+      if (level != 0) cerr << "[" << level << "] ";
+      return cerr;
+    }
+  else
+    {
+      junk_journal.seekp(0);
+      return junk_journal;
+    }
+}
+
+// Description: this method must return the total memory consumption
+//  of the object (used to compute the size of the data cache)
+Size_t LataObject::compute_memory_size() const
+{
+  Journal() << "Error in LataObject::compute_memory_size(): function not implemented" << endl;
+  throw;
+}
+
+template<typename _TYPE_, typename _SIZE_>
+Size_t memory_size(const TRUSTArray<_TYPE_,_SIZE_>& tab)
+{
+  return ((Size_t)sizeof(tab)) + ((Size_t)tab.size_array()) * sizeof(_TYPE_);
+}
+
+template Size_t memory_size<int,trustIdType>(const TRUSTArray<int,trustIdType>& tab);
+template Size_t memory_size<float,int>(const TRUSTArray<float,int>& tab);
+template Size_t memory_size<double,int>(const TRUSTArray<double,int>& tab);
+
+#if INT_is_64_ == 2
+template Size_t memory_size<trustIdType,trustIdType>(const TRUSTArray<trustIdType,trustIdType>& tab);
+template Size_t memory_size<float,trustIdType>(const TRUSTArray<float,trustIdType>& tab);
+template Size_t memory_size<double,trustIdType>(const TRUSTArray<double,trustIdType>& tab);
+#endif
+
+
+Size_t memory_size(const BigArrOfBit& tab)
+{
+  return ((Size_t)sizeof(tab)) + ((Size_t)tab.size_array()) * sizeof(int) / 32;
+}
+
+void split_path_filename(const char *s, Nom& path, Nom& filename)
+{
+  int i;
+  for (i=(int)strlen(s)-1; i>=0; i--)
+    if ((s[i]==PATH_SEPARATOR) || (s[i]=='\\'))
+      break;
+  path = "";
+  int j;
+  for (j = 0; j <= i; j++)
+    path += Nom(s[j]);
+
+  // Parse basename : if extension given, remove it
+  filename = s+i+1;
+}
+
+static const BigArrOfTID * array_to_sort_ptr = 0;
+int compare_indirect(const void *ptr1, const void *ptr2)
+{
+  trustIdType i1 = *(const int*)ptr1;
+  trustIdType i2 = *(const int*)ptr2;
+  trustIdType diff = (*array_to_sort_ptr)[i1] - (*array_to_sort_ptr)[i2];
+  return (diff>0) ? 1 : ((diff==0) ? 0 : -1);
+}
+
+void array_sort_indirect(const BigArrOfTID& array_to_sort, BigArrOfTID& index)
+{
+  const trustIdType n = array_to_sort.size_array();
+  index.resize_array(n);
+  for (trustIdType i = 0; i < n; i++)
+    index[i] = i;
+  array_to_sort_ptr = &array_to_sort;
+  qsort(index.addr(), n, sizeof(int), compare_indirect);
+}
diff --git a/Utilities/VisItBridge/databases/readers/Lata/LataTools.h b/Utilities/VisItBridge/databases/readers/Lata/LataTools.h
new file mode 100644
index 00000000..16f7166e
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/LataTools.h
@@ -0,0 +1,177 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef LataTools_include_
+#define LataTools_include_
+#include <assert.h>
+#include <arch.h>
+
+
+#ifdef WIN32
+#define __BIG_ENDIAN    111
+#define __LITTLE_ENDIAN 121
+#define __BYTE_ORDER __LITTLE_ENDIAN
+
+#define strtoll _strtoi64
+// This must be able to contain a total memory size, a file offset,
+// or a very big operation counter.
+typedef __int64 Size_t;
+
+#else
+#ifdef __APPLE__
+// Assume we only have x86, x86_64 based Macs.
+#define __BIG_ENDIAN    111
+#define __LITTLE_ENDIAN 121
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#endif
+
+// This must be able to contain a total memory size, a file offset,
+// or a very big operation counter.
+typedef std::int64_t Size_t;
+#endif
+
+#ifndef __BYTE_ORDER
+#include <endian.h>
+#endif
+
+#include <LataVector.h>
+
+
+#define PATH_SEPARATOR '/'
+
+#ifndef __BYTE_ORDER
+#error "Byte order not defined."
+#endif
+#if (__BYTE_ORDER == __BIG_ENDIAN)
+const bool mymachine_msb =  true;
+#elif (__BYTE_ORDER == __LITTLE_ENDIAN)
+const bool mymachine_msb =  false;
+#else
+#error "Byte order is neither __BIG_ENDIAN nor __LITTLE_ENDIAN : "
+#endif
+
+#include <TRUSTArray.h>
+#include <ArrOfBit.h>
+
+template<typename _TYPE_, typename _SIZE_>
+Size_t memory_size(const TRUSTArray<_TYPE_,_SIZE_>& tab);
+
+Size_t memory_size(const BigArrOfBit&);
+
+class LataObject
+{
+public:
+  virtual ~LataObject() {};
+  virtual Size_t compute_memory_size() const;
+};
+
+// A 'LataDeriv<X> ptr' object can hold an object of class Y which is any derived type of X.
+// The contained object can be accessed via "valeur()" (you get an object of type X)
+//   or "refcast()" (get an object of any derived type Z between X and Y)
+//   (refcast() throws an exception if you try to cast with a wrong type)
+// It can also be null (hold no object). valeur() will then throw an exception.
+// Example:
+//  LataDeriv<X> deriv_x;
+//  Y & y = deriv_x.instancie(Y); // Creates an instance of type Y within deriv_x
+//  X & x = deriv_x.valeur(); // Get a reference to the contained object
+//  Y & y2 = deriv_x.refcast(Y); // Same, but you get a reference of type Y
+//  Z & z = deriv_x.refcast(Z); // Throw an exception if Z is not a derived class of X and a base class of Y
+//  x.reset(); // Destroys the contained object (also destroyed when deriv_x is destroyed)
+#define instancie(x) instancie_(new x)
+#define refcast(x) refcast_((x*) 0)
+
+template <class C>
+class LataDeriv : public LataObject
+{
+public:
+  enum DERIV_ERROR { ERROR_TYPE, ERROR_NULL };
+  LataDeriv() : ptr_(0) { };
+  ~LataDeriv() { delete ptr_; ptr_ = 0; }
+  void reset() { delete ptr_; ptr_ = 0; }
+  bool non_nul() const { return ptr_ != 0; }
+  // operator C &() { return valeur(); }
+  // operator const C &() const { return valeur(); }
+  C& valeur() { if (!ptr_) throw ERROR_NULL; return *ptr_; }
+  const C& valeur() const { if (!ptr_) throw ERROR_NULL; return *ptr_; }
+  template<class DER_C> DER_C& instancie_(DER_C *ptr)
+  {
+    reset();
+    ptr_ = ptr;
+    if (!dynamic_cast<C*>(ptr_))
+      {
+        delete ptr_;
+        throw ERROR_TYPE; // DER_C is not a derived type of C
+      }
+    return (DER_C&) (*ptr_);
+  }
+  template<class DER_C> DER_C& refcast_(DER_C *cast_type)
+  {
+    if (!ptr_)
+      throw ERROR_NULL;
+    DER_C * x = dynamic_cast<DER_C *>(ptr_);
+    if (!x)
+      throw ERROR_TYPE;
+    return *x;
+  }
+  Size_t compute_memory_size() const override { if (ptr_) return ptr_->compute_memory_size(); else return 0; }
+protected:
+  LataDeriv(const LataDeriv<C>& c) { ptr_ = 0; operator=(c); }
+  LataDeriv(const C& c) { ptr_ = 0; operator=(c); }
+  LataDeriv<C>& operator=(const LataDeriv<C>&);
+  LataDeriv<C>& operator=(const C&);
+  C *ptr_;
+};
+
+// This is a reference to an object of type C, but the reference can be null
+template<class C>
+class LataRef
+{
+public:
+  enum REF_ERROR { ERROR_NULL };
+  LataRef() : ptr_(0) { }
+  ~LataRef() { ptr_ = 0; }
+  LataRef(const LataRef<C>& x) : ptr_(x.ptr_) { }
+  LataRef(C& x) : ptr_(&x) { }
+  LataRef<C>& operator=(LataRef<C>& x) { ptr_ = x.ptr_; return *this; }
+  LataRef<C>& operator=(C& x) { ptr_ = &x; return *this; }
+  void reset() { ptr_ = 0; }
+  operator C& () { if (!ptr_) throw ERROR_NULL; return *ptr_; }
+  C& valeur() { if (!ptr_) throw ERROR_NULL; return *ptr_; }
+  bool non_nul() const { return ptr_ != 0; }
+protected:
+  C *ptr_;
+};
+
+void array_sort_indirect(const BigArrOfTID& array_to_sort, BigArrOfTID& index);
+
+class Nom;
+void split_path_filename(const char *full_name, Nom& path, Nom& filename);
+
+// To optimize small loops: replace for(i=0;i<n;i++) with n<=3 by
+//  for (i=0; i<loop_max(n,3); i++) {
+//    loop_instructions();...
+//    break_loop(i,n);
+//  }
+#define loop_max(nloops,max) max
+#define break_loop(index,nloops) if (index >= nloops-1) break
+
+#include <LataJournal.h>
+#include <TRUSTTab.h>
+#include <Motcle.h>
+#include <Noms.h>
+
+Motcles noms_to_motcles(const Noms& noms);
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/LataV1_field_definitions.cpp b/Utilities/VisItBridge/databases/readers/Lata/LataV1_field_definitions.cpp
new file mode 100644
index 00000000..90bcb7ce
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/LataV1_field_definitions.cpp
@@ -0,0 +1,72 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <LataV1_field_definitions.h>
+#include <Motcle.h>
+
+typedef struct
+{
+  const char * name;
+  int shape; // Vector size (-1 => dimension of the problem)
+} StdComponents;
+
+// COMPOSANTES EN MAJUSCULES !!!!!
+// Components are checked in the same order than this array.
+// We assume that the component has been found if component
+// name begins with the string in this array. For example
+// if the lata file contains INDICATRICE_INTERF, we will
+// find that it is an "INDICATRICE" component.
+// Therefore, long names must be placed before short names:
+// If we have a component "K" and a component "K_EPS", then
+// "K_EPS" must be placed before "K", otherwise "K_EPS" will
+// never be found.
+const StdComponents std_components[] =
+{
+  { "VITESSE",             -1 },
+  { "primal",              -1 },
+  { "VORTICITE",           -2 },
+  { "MOYENNE_VITESSE",     -1 },
+  { "ECART_TYPE_VITESSE",  -1 },
+  { "MOYENNE_VORTICITE",   -2 },
+  { "ECART_TYPE_VORTICITE", -2 },
+  { "GRADIENT_PRESSION",            -1 },
+  { "DERIVEE_U_ETOILE",             -1 },
+  { "TERME_DIFFUSION_VITESSE",      -1 },
+  { "TERME_CONVECTION_VITESSE",     -1 },
+  { "TERME_SOURCE_VITESSE",         -1 },
+  { "GRAD",         -1 },
+  { "NORMALE_INTERFACE",            -1 },
+  { "K_EPS",                             2 },
+  { "ACCELERATION",        -1 },
+  { "CHAMP_VECTORIEL",     -1},
+  { "2_",     2},
+  { "3_",     3},
+  { "6_",     6},
+  { "9_",     9},
+  { "",                  1 }
+  // Empty label means end of the table
+};
+
+int latav1_component_shape(const Motcle& compo)
+{
+  int i = 0;
+  while (std_components[i].name[0] != 0)
+    {
+      if (compo.debute_par(std_components[i].name))
+        return std_components[i].shape;
+      i++;
+    }
+  return 1;
+}
diff --git a/Utilities/VisItBridge/databases/readers/Lata/LataV1_field_definitions.h b/Utilities/VisItBridge/databases/readers/Lata/LataV1_field_definitions.h
new file mode 100644
index 00000000..db4288da
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/LataV1_field_definitions.h
@@ -0,0 +1,21 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+// This file is included in LataDB.cpp (and only there)
+// It contains fields definitions for the old LataV1 format
+// (separated from LataDB.cpp so that changes in this file are
+//  easily identified)
+class Motcle;
+int latav1_component_shape(const Motcle& compo);
diff --git a/Utilities/VisItBridge/databases/readers/Lata/LataVector.h b/Utilities/VisItBridge/databases/readers/Lata/LataVector.h
new file mode 100644
index 00000000..c9b40429
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/LataVector.h
@@ -0,0 +1,57 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef LataVector_H
+#define LataVector_H
+#include <assert.h>
+#include <arch.h>
+
+// This vector class uses an array of pointers so that objects stored are never
+// moved in memory when the array is resized.
+template <class C>
+class LataVector
+{
+public:
+  LataVector() : n_(0), data_(0) { }
+  LataVector(const LataVector<C>& x) : n_(0), data_(0) { operator=(x); }
+  LataVector(int n) : n_(0), data_(0) { for (int i=0; i<n; i++) add(); }
+  ~LataVector() { reset(); }
+  void reset() { for (int i=0; i<n_; i++) { delete data_[i]; }; delete[] data_; n_ = 0; data_ = 0; }
+  const C& operator[](int i) const { assert(i>=0 && i<n_); return *(data_[i]); }
+  C& operator[](int i) { assert(i>=0 && i<n_); return *(data_[i]); }
+  C& add(const C& item) { return add_item(new C(item)); }
+  C& add() { return add_item(new C); }
+  int size() const { return n_; }
+  int rang(const C& c) const
+  {
+    for (int i = 0; i < n_; i++)
+      if (*(data_[i]) == c) return i;
+    return -1;
+  }
+  LataVector<C>& operator=(const LataVector<C>& x) { reset(); for (int i=0; i<x.n_; i++) add(x[i]); return *this; }
+private:
+  C& add_item(C* added_item)
+  {
+    C** old = data_;
+    data_ = new C*[n_+1];
+    for (int i=0; i<n_; i++) data_[i] = old[i];
+    delete[] old;
+    data_[n_++] = added_item;
+    return *added_item;
+  }
+  int n_;
+  C** data_;
+};
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/LataWriter.cpp b/Utilities/VisItBridge/databases/readers/Lata/LataWriter.cpp
new file mode 100644
index 00000000..d1f3238b
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/LataWriter.cpp
@@ -0,0 +1,423 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <LataWriter.h>
+#include <LataStructures.h>
+
+// Path, if not empty, must include a trailing '/'
+// basename must not include the .lata extension
+void LataWriter::init_file(const Nom& path, const Nom& basename, const LataDBDataType& default_int_format, LataDBDataType::Type default_float_type)
+{
+  db_.reset();
+  db_.set_path_prefix(path);
+
+  base_name_ = basename;
+
+  db_.default_type_int_ = default_int_format;
+  db_.default_float_type_ = default_float_type;
+  db_.header_ = "Lata V2";
+  db_.case_ = "lata_analyzer";
+  db_.software_id_ = "TRUST";
+
+  // Global geometries and fields:
+  db_.add_timestep(0.);
+}
+
+// Add a new timestep to the lata database (new TEMPS entry)
+// Geometries and fields are always written in the last added timestep (the timestep stored within the domain or field is ignored)
+// Those written before the first call to write_time() go into global fields and geometry definitions.
+void LataWriter::write_time(double t)
+{
+  db_.add_timestep(t);
+}
+
+void LataWriter::write_geometry(const Domain& dom)
+{
+  // Index of the last timestep:
+  const int tstep = db_.nb_timesteps() - 1;
+
+  // Build a geometry database entry and add it to database
+  LataDBGeometry geom;
+  geom.name_ = dom.id_.name_;
+
+  Nom type_elem = dom.element_type_to_string(dom.elt_type_);
+  if (write_faces_fields_ && dom.is_rectangle()) type_elem = "RECTANGLE"; // sinon pas de maillage dual dans lata plugin !
+
+  geom.elem_type_ = type_elem;
+  geom.timestep_ = tstep;
+  db_.add_geometry(geom);
+
+  // Write geometry data
+  const DomainUnstructured *dom1_ptr = dynamic_cast<const DomainUnstructured*>(&dom);
+  const DomainIJK *dom2_ptr = dynamic_cast<const DomainIJK*>(&dom);
+
+  if (dom1_ptr)
+    {
+      // For unstructured meshes, we write the following fields:
+      //  SOMMETS
+      //  ELEMENTS
+      //  [ FACES ]
+      //  [ ELEM_FACES ]
+      const DomainUnstructured& domain = *dom1_ptr;
+      LataDBField field;
+
+      if (lata_option_ == SINGLE_LATA_FILE) // unique file
+        {
+          field.filename_ = base_name_;
+          field.filename_ += ".lata_single";
+        }
+
+      // Write nodes
+      Nom fieldname = "SOMMETS";
+      field.uname_ = Field_UName(geom.name_, fieldname, "" /* localisation */);
+      field.name_ = fieldname;
+      field.timestep_ = tstep;
+
+      if (lata_option_ != SINGLE_LATA_FILE)
+        {
+          field.filename_ = base_name_;
+          field.filename_ += ".lata.";
+          field.filename_ += fieldname;
+          field.filename_ += ".";
+          field.filename_ += geom.name_;
+          if (tstep > 0)
+            {
+              field.filename_ += ".";
+              field.filename_ += Nom(tstep);
+            }
+        }
+
+      field.nb_comp_ = domain.dimension();
+      field.geometry_ = geom.name_;
+      field.datatype_ = db_.default_type_float();
+      field.localisation_ = "";
+      field.reference_ = "";
+      field.size_ = domain.nb_nodes();
+
+      if (lata_option_ == SINGLE_LATA_FILE) // unique file
+        field.datatype_.file_offset_ = offset_;
+
+      db_.add_field(field);
+      offset_ += db_.write_data(tstep, field.uname_, domain.nodes_);
+
+      // Write elements
+      fieldname = "ELEMENTS";
+      field.uname_ = Field_UName(geom.name_, fieldname, "" /* localisation */);
+      field.name_ = fieldname;
+      field.timestep_ = tstep;
+
+      if (lata_option_ != SINGLE_LATA_FILE)
+        {
+          field.filename_ = base_name_;
+          field.filename_ += ".lata.";
+          field.filename_ += fieldname;
+          field.filename_ += ".";
+          field.filename_ += geom.name_;
+          if (tstep > 0)
+            {
+              field.filename_ += ".";
+              field.filename_ += Nom(tstep);
+            }
+        }
+
+      field.nb_comp_ = (int)domain.elements_.dimension(1);
+      field.geometry_ = geom.name_;
+      field.datatype_ = db_.default_type_int_;
+      field.localisation_ = "";
+      field.reference_ = "SOMMETS";
+      field.size_ = domain.nb_elements();
+
+      if (lata_option_ == SINGLE_LATA_FILE) // unique file
+        field.datatype_.file_offset_ = offset_;
+
+      db_.add_field(field);
+      offset_ += db_.write_data(tstep, field.uname_, domain.elements_);
+
+      // Write faces
+      if (domain.faces_ok())
+        {
+          fieldname = "FACES";
+          field.uname_ = Field_UName(geom.name_, fieldname, "" /* localisation */);
+          field.name_ = fieldname;
+          field.timestep_ = tstep;
+
+          if (lata_option_ != SINGLE_LATA_FILE)
+            {
+              field.filename_ = base_name_;
+              field.filename_ += ".lata.";
+              field.filename_ += fieldname;
+              field.filename_ += ".";
+              field.filename_ += geom.name_;
+              if (tstep > 0)
+                {
+                  field.filename_ += ".";
+                  field.filename_ += Nom(tstep);
+                }
+            }
+
+          field.nb_comp_ = (int)domain.faces_.dimension(1);
+          field.geometry_ = geom.name_;
+          field.datatype_ = db_.default_type_int_;
+          field.localisation_ = "";
+          field.reference_ = "SOMMETS";
+          field.size_ = domain.nb_faces();
+
+          if (lata_option_ == SINGLE_LATA_FILE) // unique file
+            field.datatype_.file_offset_ = offset_;
+
+          db_.add_field(field);
+          offset_ += db_.write_data(tstep, field.uname_, domain.faces_);
+
+          fieldname = "ELEM_FACES";
+          field.uname_ = Field_UName(geom.name_, fieldname, "" /* localisation */);
+          field.name_ = fieldname;
+          field.timestep_ = tstep;
+
+          if (lata_option_ != SINGLE_LATA_FILE)
+            {
+              field.filename_ = base_name_;
+              field.filename_ += ".lata.";
+              field.filename_ += fieldname;
+              field.filename_ += ".";
+              field.filename_ += geom.name_;
+              if (tstep > 0)
+                {
+                  field.filename_ += ".";
+                  field.filename_ += Nom(tstep);
+                }
+            }
+
+          field.nb_comp_ = (int)domain.elem_faces_.dimension(1);
+          field.geometry_ = geom.name_;
+          field.datatype_ = db_.default_type_int_;
+          field.localisation_ = "";
+          field.reference_ = "FACES";
+          field.size_ = domain.nb_elements();
+
+          if (lata_option_ == SINGLE_LATA_FILE) // unique file
+            field.datatype_.file_offset_ = offset_;
+
+          db_.add_field(field);
+          offset_ += db_.write_data(tstep, field.uname_, domain.elem_faces_);
+        }
+    }
+  else if (dom2_ptr)
+    {
+      // For IJK we write 2 or 3 fields containing 1-dimensionnal arrays with
+      //  the nodes coordinates in each direction:
+      //  SOMMETS_IJK_I, SOMMETS_IJK_J, SOMMETS_IJK_K.
+
+      const DomainIJK& domain = *dom2_ptr;
+      // Write coordinates
+      const int dim = domain.coord_.size();
+      if (dim > 3)
+        {
+          Journal() << "Error in LataWriter::write_geometry: dimension > 3" << endl;
+          throw InternalError;
+        }
+      Noms dir_names(3);
+      dir_names[0] = "I";
+      dir_names[1] = "J";
+      dir_names[2] = "K";
+      for (int i_dim = 0; i_dim < dim; i_dim++)
+        {
+          BigFloatTab coord;  // Big just because write method is not coded for FloatTab
+          {
+            const ArrOfFloat& x = domain.coord_[i_dim];
+            const int n = x.size_array();
+            coord.resize(n, 1);
+            for (int i = 0; i < n; i++)
+              coord(i, 0) = x[i];
+          }
+
+          Nom fieldname = "SOMMETS_IJK_";
+          fieldname += dir_names[i_dim];
+          LataDBField field;
+          field.uname_ = Field_UName(geom.name_, fieldname, "" /* localisation */);
+          field.name_ = fieldname;
+          field.timestep_ = tstep;
+
+          if (lata_option_ == SINGLE_LATA_FILE) // unique file
+            {
+              field.filename_ = base_name_;
+              field.filename_ += ".lata_single";
+            }
+          else
+            {
+              field.filename_ = base_name_;
+              field.filename_ += ".lata.";
+              field.filename_ += fieldname;
+              field.filename_ += ".";
+              field.filename_ += geom.name_;
+              if (tstep > 0)
+                {
+                  field.filename_ += ".";
+                  field.filename_ += Nom(tstep);
+                }
+            }
+
+          field.nb_comp_ = 1;
+          field.geometry_ = geom.name_;
+          field.datatype_ = db_.default_type_float();
+          field.localisation_ = "";
+          field.reference_ = "";
+          field.size_ = coord.dimension(0);
+
+          if (lata_option_ == SINGLE_LATA_FILE) // unique file
+            field.datatype_.file_offset_ = offset_;
+
+          db_.add_field(field);
+          offset_ += db_.write_data(tstep, field.uname_, coord);
+        }
+
+      if (domain.invalid_connections_.size_array() > 0)
+        {
+          const trustIdType n = domain.invalid_connections_.size_array();
+          BigTIDTab tmp(n, 1);
+          for (trustIdType i = 0; i < n; i++)
+            tmp(i, 0) = domain.invalid_connections_[i];
+
+          Nom fieldname = "INVALID_CONNECTIONS";
+          LataDBField field;
+          field.uname_ = Field_UName(geom.name_, fieldname, "ELEM" /* localisation */);
+          field.name_ = fieldname;
+          field.timestep_ = tstep;
+
+          if (lata_option_ == SINGLE_LATA_FILE) // unique file
+            {
+              field.filename_ = base_name_;
+              field.filename_ += ".lata_single";
+            }
+          else
+            {
+              field.filename_ = base_name_;
+              field.filename_ += ".lata.";
+              field.filename_ += fieldname;
+              field.filename_ += ".";
+              field.filename_ += geom.name_;
+              if (tstep > 0)
+                {
+                  field.filename_ += ".";
+                  field.filename_ += Nom(tstep);
+                }
+            }
+
+          field.nb_comp_ = 1;
+          field.geometry_ = geom.name_;
+          field.datatype_ = db_.default_type_int_;
+          field.datatype_.array_index_ = LataDBDataType::NOT_AN_INDEX;
+          field.localisation_ = "ELEM";
+          field.reference_ = "";
+          field.size_ = n;
+
+          if (lata_option_ == SINGLE_LATA_FILE) // unique file
+            field.datatype_.file_offset_ = offset_;
+
+          db_.add_field(field);
+          offset_ += db_.write_data(tstep, field.uname_, tmp);
+        }
+    }
+  else
+    {
+      Journal() << "Error LataWriter::write_geometry domain type not supported" << endl;
+      throw InternalError;
+    }
+}
+
+void LataWriter::write_component(const LataField_base& field)
+{
+  // Index of the last timestep:
+  const int tstep = db_.nb_timesteps() - 1;
+
+  LataDBField lata_field;
+
+  lata_field.uname_ = field.id_.uname_;
+  lata_field.name_ = field.id_.uname_.get_field_name();
+  lata_field.timestep_ = tstep;
+
+  if (lata_option_ == SINGLE_LATA_FILE) // unique file
+    {
+      lata_field.filename_ = base_name_;
+      lata_field.filename_ += ".lata_single";
+    }
+  else
+    {
+      lata_field.filename_ = base_name_;
+      lata_field.filename_ += ".lata.";
+      lata_field.filename_ += lata_field.uname_.build_string();
+      if (tstep > 0)
+        {
+          lata_field.filename_ += ".";
+          lata_field.filename_ += Nom(tstep);
+        }
+    }
+
+  lata_field.geometry_ = field.id_.uname_.get_geometry();
+  lata_field.component_names_ = field.component_names_;
+  // Unites a remplir
+  // Size = -1 => valeur par defaut cherchee dans la geometrie
+  lata_field.localisation_ = LataField_base::localisation_to_string(field.localisation_);
+  lata_field.nature_ = field.nature_;
+
+  const Field<BigFloatTab> *float_f = dynamic_cast<const Field<BigFloatTab>*>(&field);
+  const Field<BigIntTab> *int_f = dynamic_cast<const Field<BigIntTab>*>(&field);
+  const Field<BigTIDTab> *long_f = dynamic_cast<const Field<BigTIDTab>*>(&field);
+  if (int_f)
+    {
+      lata_field.nb_comp_ = (int)int_f->data_.dimension(1);
+      lata_field.size_ = int_f->data_.dimension(0);
+      lata_field.datatype_ = db_.default_type_int_;
+      lata_field.datatype_.array_index_ = LataDBDataType::NOT_AN_INDEX;
+
+      if (lata_option_ == SINGLE_LATA_FILE) // unique file
+        lata_field.datatype_.file_offset_ = offset_;
+
+      db_.add_field(lata_field);
+      offset_ += db_.write_data(tstep, lata_field.uname_, int_f->data_);
+    }
+  else if (long_f)
+    {
+      lata_field.nb_comp_ = (int)long_f->data_.dimension(1);
+      lata_field.size_ = long_f->data_.dimension(0);
+      lata_field.datatype_ = db_.default_type_int_;
+      lata_field.datatype_.array_index_ = LataDBDataType::NOT_AN_INDEX;
+
+      if (lata_option_ == SINGLE_LATA_FILE) // unique file
+        lata_field.datatype_.file_offset_ = offset_;
+
+      db_.add_field(lata_field);
+      offset_ += db_.write_data(tstep, lata_field.uname_, long_f->data_);
+    }
+  else if (float_f)
+    {
+      lata_field.nb_comp_ = (int)float_f->data_.dimension(1);
+      lata_field.size_ = float_f->data_.dimension(0);
+      lata_field.datatype_ = db_.default_type_float();
+
+      if (lata_option_ == SINGLE_LATA_FILE) // unique file
+        lata_field.datatype_.file_offset_ = offset_;
+
+      db_.add_field(lata_field);
+      offset_ += db_.write_data(tstep, lata_field.uname_, float_f->data_);
+    }
+}
+
+void LataWriter::finish()
+{
+  Nom n(db_.path_prefix());
+  n += base_name_;
+  n += ".lata";
+  db_.write_master_file(n);
+}
diff --git a/Utilities/VisItBridge/databases/readers/Lata/LataWriter.h b/Utilities/VisItBridge/databases/readers/Lata/LataWriter.h
new file mode 100644
index 00000000..320e91ba
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/LataWriter.h
@@ -0,0 +1,49 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef LataWriter_H
+#define LataWriter_H
+#include <LataDB.h>
+
+class Domain;
+class LataField_base;
+
+// This class provides general services to write lata files
+//  from the "high level" objects Domain and Field (the LataDB class provides
+//  only low level services to write arrays)
+class LataWriter
+{
+public:
+  enum FileSplittingOption { MULTIPLE_LATA_FILES, SINGLE_LATA_FILE };
+  enum ERRORS { InternalError };
+
+  void init_file(const Nom& path, const Nom& basename, const LataDBDataType& default_int_format, LataDBDataType::Type default_float_type);
+  void write_faces_fields() { write_faces_fields_ = true; }
+  void write_component(const LataField_base& field);
+  void write_geometry(const Domain& dom);
+  void write_time(double t);
+  void finish();
+
+  void set_file_splitting_option(const FileSplittingOption op) { lata_option_ = op; }
+
+protected:
+  FileSplittingOption lata_option_ = MULTIPLE_LATA_FILES;
+  LataDB db_; // This is the database where we put all data...
+  Nom base_name_; // Basename for files and lata master file:
+  Size_t offset_ = 0;
+  bool write_faces_fields_ = false;
+};
+
+#endif /* LataWriter_H */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/LmlReader.cpp b/Utilities/VisItBridge/databases/readers/Lata/LmlReader.cpp
new file mode 100644
index 00000000..9138efaa
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/LmlReader.cpp
@@ -0,0 +1,483 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#define BUFSZ 1000
+#include <iostream>
+#include <EFichier.h>
+#include <LataDB.h>
+#include <LataFilter.h>
+#include <stdlib.h>
+#include <string.h>
+
+// lml files contain double precision values that can overflow or underflow
+//  if converted to float. Check for overflow, ignore underflow
+static inline float double_to_float(double x)
+{
+  // Written like this, the code will also stop on NAN values:
+  if (!(x < 1.e38 && x > -1.e38))
+    {
+      Journal() << "lml reader: Error converting double value " << x << " to float" << endl;
+      throw LataDBError(LataDBError::READ_ERROR);
+    }
+  return (float) x;
+}
+
+// Reads the lml file, fills the lata_db and writes the data (coordinates, elements and
+//  fields data) to a unique file data_filename.
+// The default format used to write data in the data_filename is lata_db.default_type_*
+// data_filename must not contain the path but only a filename with extension.
+// The path to the data file must be set by lata_db.set_path_prefix() before.
+// If data_filename is a null pointer, data files are not written and file offsets in lata_db will
+//  be wrong (useful for just getting metadata)
+void lml_reader(const char *lmlfilename, const char *data_filename, LataDB& lata_db)
+{
+  Nom filename_in_master_file;
+  if (!data_filename)
+    filename_in_master_file = "DATA_NOT_WRITTEN";
+  else
+    filename_in_master_file = data_filename;
+
+  const int lmllevel = 4;
+  EFichier is;
+  Journal(lmllevel) << "lml_reader: " << endl;
+  is.ouvrir(lmlfilename);
+  if (!is.good())
+    {
+      Journal() << "Error: cannot open lml file " << lmlfilename << endl;
+      throw;
+    }
+  char s[BUFSZ + 1];
+  is.get_istream().getline(s, BUFSZ);
+  if (!is.good())
+    {
+      Journal() << "Lml file " << lmlfilename << " is empty" << endl;
+      // Just put an empty initial timestep:
+      lata_db.add_timestep(-1.);
+      return;
+    }
+  lata_db.header_ = s;
+  Journal(lmllevel) << "Header: " << s << endl;
+  is.get_istream().getline(s, BUFSZ);
+  lata_db.case_ = s;
+  Journal(lmllevel) << "Case: " << s << endl;
+  is.get_istream().getline(s, BUFSZ);
+  lata_db.software_id_ = s;
+  Journal(lmllevel) << "Software_id: " << s << endl;
+
+  Noms liste_noms_geoms;
+  Noms liste_noms_topo;
+  // Create first timestep (global definitions)
+  lata_db.add_timestep(-1.);
+  // file_offset_blurb:
+  // the file offset will be computed by LataDB::write_data(),
+  // but we must tell write_data() if it must put the data at the beginning
+  //  (file_offset==0) or append the data at the end of the file (file_offset!=0)
+  // file_offset is 0 for the first data block and it is incremented for each block.
+  Size_t file_offset = 0;
+  LataDBField sommets;
+  BigFloatTab nodes;
+  trustIdType tmp; // tmp variable
+  while (1)
+    {
+      const int tstep = lata_db.nb_timesteps() - 1;
+      Motcle motlu;
+      is >> motlu;
+      if (!is.good())
+        break;
+      if (motlu == "GRILLE")
+        {
+          LataDBGeometry geom;
+          sommets.name_ = "SOMMETS";
+          geom.timestep_ = sommets.timestep_ = tstep;
+          sommets.filename_ = filename_in_master_file;
+          Nom mottmp;
+          is >> mottmp;
+          geom.name_ = ((const char*) mottmp) + 7; // retire GRILLE_ du nom
+          Journal(lmllevel) << "lml_reader: GRILLE " << geom.name_ << endl;
+          is >> sommets.nb_comp_;
+          is >> tmp;
+          sommets.size_ = tmp;
+
+          if (!is.good())
+            throw LataDBError(LataDBError::READ_ERROR);
+          sommets.geometry_ = geom.name_;
+          sommets.uname_ = Field_UName(sommets.geometry_, sommets.name_, "");
+          sommets.datatype_ = lata_db.default_type_float();
+          sommets.datatype_.file_offset_ = file_offset++; // see file_offset_blurb
+          nodes.resize(sommets.size_, sommets.nb_comp_);
+          for (trustIdType i = 0; i < sommets.size_; i++)
+            for (int j = 0; j < sommets.nb_comp_; j++)
+              {
+                double x;
+                is >> x;
+                if (!is.good())
+                  throw LataDBError(LataDBError::READ_ERROR);
+                nodes(i, j) = double_to_float(x);
+              }
+          Journal(lmllevel + 1) << "Finished reading nodes" << endl;
+
+          lata_db.add_geometry(geom);
+          // Write nodes to disk later: in 2D they will be cropped
+        }
+      else if (motlu == "TOPOLOGIE")
+        {
+          LataDBField elements;
+          elements.name_ = "ELEMENTS";
+          elements.timestep_ = tstep;
+          elements.filename_ = filename_in_master_file;
+          elements.datatype_ = lata_db.default_type_int_;
+          elements.datatype_.file_offset_ = file_offset++; // see file_offset_blurb
+          Nom ident;
+          is >> ident; // Topologie_MAILLAGE_VOLUMIQUE_XXX
+          Nom mottmp;
+          is >> mottmp;
+          if (!is.good())
+            throw LataDBError(LataDBError::READ_ERROR);
+          elements.geometry_ = ((const char*) mottmp) + 7; // retire GRILLE_ du nom
+          elements.uname_ = Field_UName(elements.geometry_, elements.name_, "");
+          liste_noms_geoms.add(elements.geometry_);
+          liste_noms_topo.add(ident);
+          is >> motlu;
+          if (motlu != "MAILLE")
+            {
+              Journal() << "Error reading TOPOLOGIE: expected MAILLE" << endl;
+              throw;
+            }
+          is >> tmp; // size_ est long long...
+          elements.size_ = tmp;
+          is >> motlu;
+          int borne_index_min = 0;
+          if (motlu == "TETRA4")
+            {
+              lata_db.set_elemtype(tstep, elements.geometry_, "TETRAEDRE");
+              elements.nb_comp_ = 4;
+            }
+          else if (motlu == "TRIANGLE_3D")
+            {
+              elements.nb_comp_ = 3;
+              lata_db.set_elemtype(tstep, elements.geometry_, "TRIANGLE_3D");
+            }
+          else if (motlu == "QUADRANGLE_3D")
+            {
+              elements.nb_comp_ = 4;
+              lata_db.set_elemtype(tstep, elements.geometry_, "QUADRANGLE_3D");
+            }
+          else if (motlu == "VOXEL8")
+            {
+              elements.nb_comp_ = 8;
+              lata_db.set_elemtype(tstep, elements.geometry_, "HEXAEDRE");
+            }
+          else if (motlu == "SEGMENT")
+            {
+              elements.nb_comp_ = 2;
+              lata_db.set_elemtype(tstep, elements.geometry_, "SEGMENT");
+            }
+          else if (motlu == "POINT")
+            {
+              elements.nb_comp_ = 1;
+              lata_db.set_elemtype(tstep, elements.geometry_, "POINT");
+            }
+          else if (motlu == "PRISM6")
+            {
+              lata_db.set_elemtype(tstep, elements.geometry_, "PRISM6");
+              elements.nb_comp_ = 6;
+            }
+          else if (motlu.debute_par("POLYEDRE_"))
+            {
+              lata_db.set_elemtype(tstep, elements.geometry_, motlu);
+              elements.nb_comp_ = atoi(((const char*) motlu) + strlen("polyedre_"));
+              borne_index_min = -1;
+            }
+          else if (motlu.debute_par("POLYGONE_"))
+            {
+              lata_db.set_elemtype(tstep, elements.geometry_, motlu);
+              elements.nb_comp_ = atoi(((const char*) motlu) + strlen("polygone_"));
+              borne_index_min = -1;
+            }
+          else
+            {
+              Journal() << "Error reading TOPOLOGIE: unknown element type" << endl;
+              throw;
+            }
+
+          Journal(lmllevel + 1) << " " << elements.size_ << " elements " << motlu << endl;
+          BigTIDTab elems;
+          elems.resize(elements.size_, elements.nb_comp_);
+          for (trustIdType i = 0; i < elements.size_; i++)
+            {
+              if (i != 0)
+                {
+                  is >> motlu; // element type
+                  if (!is.good())
+                    throw LataDBError(LataDBError::READ_ERROR);
+                }
+              int j;
+              for (j = 0; j < elements.nb_comp_; j++)
+                {
+                  is >> elems(i, j);
+                  if (!is.good())
+                    throw LataDBError(LataDBError::READ_ERROR);
+                  elems(i, j)--;
+                  if
+                  (                  elems(i,j) < borne_index_min || elems(i,j) >= sommets.size_ )
+                    {
+                      Journal() << "Error reading TOPOLOGIE: bad node number elem(" << i << "," << j << ")=" << elems(i,j) << endl;
+                      throw;
+                    }
+                }
+            }
+          Journal(lmllevel + 1) << " finished reading elements" << endl;
+          lata_db.add_field(sommets);
+          if (data_filename)
+            lata_db.write_data(tstep, sommets.uname_, nodes);
+          lata_db.add_field(elements);
+          if (data_filename)
+            lata_db.write_data(tstep, elements.uname_, elems);
+        }
+      else if (motlu == "FACE")
+        {
+          trustIdType n;
+          is >> n;
+          if (!is.good())
+            throw LataDBError(LataDBError::READ_ERROR);
+          Journal(lmllevel + 1) << " faces " << n << endl;
+        }
+      else if (motlu == "TEMPS")
+        {
+          double t;
+          is >> t;
+          if (!is.good())
+            throw LataDBError(LataDBError::READ_ERROR);
+          lata_db.add_timestep(t);
+          Journal(lmllevel + 1) << " new time: " << t << endl;
+        }
+      else if (motlu == "CHAMPMAILLE" || motlu == "CHAMPPOINT")
+        {
+          LataDBField field;
+          is >> field.name_;
+          if (!is.good())
+            throw LataDBError(LataDBError::READ_ERROR);
+          Journal(lmllevel + 1) << " new field: " << field.name_ << endl;
+          field.timestep_ = tstep;
+          field.filename_ = filename_in_master_file;
+          if (motlu == "CHAMPMAILLE")
+            field.localisation_ = "ELEM";
+          else
+            field.localisation_ = "SOM";
+          Nom nom_topo;
+          is >> nom_topo;
+          if (!is.good())
+            throw LataDBError(LataDBError::READ_ERROR);
+
+          const int rang_topo = liste_noms_topo.rang(nom_topo);
+          if (rang_topo < 0)
+            {
+              Journal() << "Error reading lml file : unknown topology name " << nom_topo << endl;
+              throw;
+            }
+          field.geometry_ = liste_noms_geoms[rang_topo];
+          Motcle mottmp(field.name_);
+          Motcle tmp2("_");
+          tmp2 += field.localisation_;
+          tmp2 += "_";
+          tmp2 += field.geometry_;
+          mottmp.prefix(tmp2); // Retire _SOM_dom du nom
+          field.name_ = mottmp;
+          field.uname_ = Field_UName(field.geometry_, field.name_, field.localisation_);
+          double t;
+          is >> t; // Unused time value
+          if (!is.good())
+            throw LataDBError(LataDBError::READ_ERROR);
+          is >> motlu; // Repeat fieldname
+          if (!is.good())
+            throw LataDBError(LataDBError::READ_ERROR);
+          is >> field.nb_comp_;
+          if (!is.good())
+            throw LataDBError(LataDBError::READ_ERROR);
+          Nom unit;
+          is >> unit;
+          if (!is.good())
+            throw LataDBError(LataDBError::READ_ERROR);
+          field.unites_.add(unit);
+          is >> motlu; // type0
+          if (!is.good())
+            throw LataDBError(LataDBError::READ_ERROR);
+          is >> tmp;
+          field.size_ = tmp; // long long convert
+          if (!is.good())
+            throw LataDBError(LataDBError::READ_ERROR);
+          // By default, 3 components fields are vectors:
+          if (field.nb_comp_ == 3)
+            {
+              Journal(lmllevel + 1) << " 3 components=> say it's a vector" << endl;
+              field.nature_ = LataDBField::VECTOR;
+            }
+          else
+            {
+              field.nature_ = LataDBField::SCALAR;
+            }
+          field.datatype_ = lata_db.default_type_float();
+          field.datatype_.file_offset_ = file_offset++; // see file_offset_blurb
+          BigFloatTab tab;
+          tab.resize(field.size_, field.nb_comp_);
+          for (trustIdType i = 0; i < field.size_; i++)
+            {
+              trustIdType n;
+              is >> n;
+              if (!is.good())
+                throw LataDBError(LataDBError::READ_ERROR);
+              for (int j = 0; j < field.nb_comp_; j++)
+                {
+                  double x;
+                  is >> x;
+                  if (!is.good())
+                    throw LataDBError(LataDBError::READ_ERROR);
+                  tab(i, j) = double_to_float(x);
+                }
+            }
+          Journal(lmllevel + 1) << " finished reading field " << field.name_ << endl;
+          lata_db.add_field(field);
+          if (data_filename)
+            lata_db.write_data(tstep, field.uname_, tab);
+        }
+      else if (motlu == "FIN")
+        {
+          break;
+        }
+      else
+        {
+          Journal() << "Error reading lml file, unknown keyword " << motlu << endl;
+          throw;
+        }
+    }
+}
+
+void lml_to_lata(const char *lmlname, const char *latafilename, bool ascii, bool fortran_blocs, bool fortran_ordering, bool fortran_indexing)
+{
+  const int lmllevel = 4;
+  Journal(lmllevel) << "lml_to_lata " << lmlname << " -> " << latafilename << endl;
+  LataDB lata_db;
+  Nom dest_prefix, dest_name;
+  LataOptions::extract_path_basename(latafilename, dest_prefix, dest_name);
+  // Nom du fichier .data a ecrire (sans le chemin)
+  Nom datafile(dest_name);
+  datafile += ".lata_single";
+  lata_db.set_path_prefix(dest_prefix);
+  // Nom complet du fichier lml a lire
+  LataDBDataType type;
+  if (ascii)
+    type.msb_ = LataDBDataType::ASCII;
+  else
+    type.msb_ = LataDBDataType::machine_msb_;
+  type.type_ = LataDBDataType::INT32;
+  type.array_index_ = fortran_indexing ? LataDBDataType::F_INDEXING : LataDBDataType::C_INDEXING;
+  type.data_ordering_ = fortran_ordering ? LataDBDataType::F_ORDERING : LataDBDataType::C_ORDERING;
+  type.fortran_bloc_markers_ = fortran_blocs ? LataDBDataType::BLOC_MARKERS_SINGLE_WRITE : LataDBDataType::NO_BLOC_MARKER;
+  type.bloc_marker_type_ = LataDBDataType::INT32;
+  type.file_offset_ = 0;
+  lata_db.default_type_int_ = type;
+  lata_db.default_float_type_ = LataDBDataType::REAL32;
+
+  lml_reader(lmlname, datafile, lata_db);
+  Journal(lmllevel) << "lml_to_lata writing lata master file" << endl;
+  lata_db.write_master_file(latafilename);
+}
+
+// Reads lml or lata file into lata_db. lml data is loaded in an internal memory buffer
+//  file: full name with path
+//  path_prefix: the path (used to access lata data files)
+// If dest_file_if_lml is not null, puts lml data into this file...
+// In this case, you must set lata_db.default_type* to tell which format to use.
+void read_any_format(const char *file, const Nom& path_prefix, LataDB& lata_db)
+{
+  // Is it an lml ?
+  Motcle motcle_nom_fic(file);
+  if (motcle_nom_fic.finit_par(".lml"))
+    {
+      Journal(1) << "Detected lml file : " << file << endl;
+      // Nom complet du fichier lml a lire
+      Journal(1) << "Reading lml file to memory buffer" << endl;
+      // data will be put in an internal memory buffer.
+      // choose appropriate data format:
+      LataDBDataType type;
+      type.msb_ = LataDBDataType::machine_msb_;
+      type.type_ = LataDBDataType::INT32;
+      type.array_index_ = LataDBDataType::C_INDEXING;
+      type.data_ordering_ = LataDBDataType::C_ORDERING;
+      type.fortran_bloc_markers_ = LataDBDataType::NO_BLOC_MARKER;
+      type.bloc_marker_type_ = LataDBDataType::INT32;
+      type.file_offset_ = 0;
+      lata_db.default_type_int_ = type;
+      lata_db.default_float_type_ = LataDBDataType::REAL32;
+      lml_reader(file, LataDBField::memory_buffer_file(), lata_db);
+    }
+  else
+    {
+      Journal(1) << "Detected lata file : " << file << endl;
+      lata_db.read_master_file(path_prefix, file);
+    }
+}
+
+// Description: if the file is a lata file, read the third line and interprets it as options
+//  if lml format, do nothing
+//  otherwise, error.
+void read_any_format_options(const char *file, LataOptions& opt)
+{
+  Motcle nom_fic(file);
+  if (nom_fic.finit_par(".lml"))
+    {
+      // do nothing
+    }
+  else if (nom_fic.finit_par(".med"))
+    {
+      // do nothing
+    }
+  else if (nom_fic.finit_par(".lata"))
+    {
+      Journal(1) << "Lata file: Interpreting LataFilter options on third line" << endl;
+      Nom ligne = LataDB::read_master_file_options(file);
+      const char *s = ligne;
+      while (*s)
+        {
+          Nom toto("");
+          while ((*s) != ' ' && (*s) != 0)
+            {
+              toto += Nom(*s);
+              s++;
+            }
+          if ((toto != "Trio_U") && (toto != "TRUST"))
+            {
+              if (!opt.parse_option(toto))
+                {
+                  Journal(0) << "Interpreting option: " << toto << "  Failed." << endl;
+                  throw LataDBError::BAD_HEADER;
+                }
+              else
+                Journal(1) << "Interpreting option: " << toto << "  Success." << endl;
+            }
+          while ((*s) == ' ')
+            s++;
+        }
+    }
+  else if (nom_fic.find("FORT21")>=0)
+    {
+      // do nothing
+    }
+  else
+    {
+      Journal(0) << "read_any_format_options: file " << nom_fic << " has unsupported extension" << endl;
+      throw LataDBError::BAD_HEADER;
+    }
+}
diff --git a/Utilities/VisItBridge/databases/readers/Lata/LmlReader.h b/Utilities/VisItBridge/databases/readers/Lata/LmlReader.h
new file mode 100644
index 00000000..7efc88be
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/LmlReader.h
@@ -0,0 +1,27 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef LMLREADER_H
+#define LMLREADER_H
+
+class LataOptions;
+
+void lml_reader(const char *lmlfilename, const char *data_filename, LataDB& lata_db);
+void lml_to_lata(const char *lmlfilename, const char *latafilename, bool ascii=false, bool fortran_blocs=true, bool fortran_ordering=false, bool fortran_indexing=true);
+void read_any_format(const char *file, const Nom& path_prefix, LataDB& lata_db);
+void read_any_format_options(const char *file, LataOptions& opt);
+
+#endif /* LMLREADER_H */
+
diff --git a/Utilities/VisItBridge/databases/readers/Lata/MD_Vector.h b/Utilities/VisItBridge/databases/readers/Lata/MD_Vector.h
new file mode 100644
index 00000000..b1c7701e
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/MD_Vector.h
@@ -0,0 +1,119 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+#ifndef MD_Vector_included
+#define MD_Vector_included
+
+#include <MD_Vector_base.h>
+#include <memory>
+
+// Options for arithmetic operations on vectors (mp_min_vect_local, apply_operator, etc...)
+//  VECT_SEQUENTIAL_ITEMS: compute requested operation only on sequential items (real items that are not received from another processor)
+//   (this is generally slower than VECT_REAL_ITEMS)
+//  VECT_REAL_ITEMS: compute requested operation on real items if size_reelle_ok(), otherwise on all items
+//  VECT_ALL_ITEMS: compute requested operation on all items (this is equivalent to a call to the Array class operator)
+enum Mp_vect_options { VECT_SEQUENTIAL_ITEMS, VECT_REAL_ITEMS, VECT_ALL_ITEMS };
+
+/*! @brief : Cette classe est un OWN_PTR mais l'objet pointe est partage entre plusieurs
+ *
+ *   instances de cette classe. L'objet pointe ne peut etre accede qu'en "const"
+ *    et n'est accessible que par des instances de MD_Vector. Donc
+ *    il n'existe pas de moyen d'y acceder en "non const" autrement qu'avec un cast.
+ *   La methode attach() et le constructeur par copie rattachent le pointeur a une
+ *    instance existante deja attachee a un pointeur.
+ *   La methode attach_detach() s'approprie l'objet pointe par le OWN_PTR et detache
+ *    l'objet du OWN_PTR. C'est la seule facon de "construire" les objets MD_Vector
+ *    (evite une copie, et permet d'assurer que le MD_Vect ne peut plus etre modifie
+ *     une fois que qu'il a ete attache a un MD_Vector)
+ *   ATTENTION: la securite de la methode repose
+ *    sur le fait que l'instance pointee par MD_Vector n'est accessible nulle part
+ *    ailleurs que par des objets MD_Vector. NE PAS AJOUTER de methode
+ *     attach(const MD_Vector_base &), cela casse la securite de la classe !!! (B.Mathieu)
+ *   inline d'un maximum de methodes pour ne pas penaliser les tableaux non distribues,
+ *    tout en evitant d'inclure MD_Vector_base.h
+ *
+ */
+class MD_Vector
+{
+public:
+  MD_Vector() {}
+  inline MD_Vector(const MD_Vector&);
+  inline MD_Vector& operator=(const MD_Vector&);
+  inline void attach(const MD_Vector&);
+  inline void detach();
+
+  int non_nul() const
+  {
+#ifndef LATATOOLS
+    return (ptr_ != 0);
+#else
+    return 0;
+#endif
+  }
+
+#ifndef LATATOOLS
+  void copy(const MD_Vector_base&);
+
+  const MD_Vector_base& valeur() const
+  {
+    assert(ptr_);
+    return *ptr_;
+  }
+
+  inline const MD_Vector_base* operator ->() const { assert(ptr_); return ptr_.get(); }
+
+  int operator==(const MD_Vector&) const;
+  int operator!=(const MD_Vector&) const;
+
+private:
+  std::shared_ptr<MD_Vector_base> ptr_;
+#endif
+};
+
+/*! @brief constructeur par copie, associe le pointeur au meme objet que la source
+ */
+inline MD_Vector::MD_Vector(const MD_Vector& src)
+{
+  attach(src);
+}
+
+/*! @brief Detache le pointeur de l'objet pointe
+ */
+inline void MD_Vector::detach()
+{
+#ifndef LATATOOLS
+  ptr_ = nullptr;
+#endif
+}
+
+/*! @brief Detache le pointeur et attache au meme objet que src.
+ */
+inline void MD_Vector::attach(const MD_Vector& src)
+{
+#ifndef LATATOOLS
+  if (this == &src)
+    return; // sinon ligne suivante detruit le pointeur ?
+  ptr_ = src.ptr_;
+#endif
+}
+
+/*! @brief idem que attach(src)
+ */
+inline MD_Vector& MD_Vector::operator=(const MD_Vector& src)
+{
+  attach(src);
+  return *this;
+}
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/MD_Vector_base.h b/Utilities/VisItBridge/databases/readers/Lata/MD_Vector_base.h
new file mode 100644
index 00000000..18a6418a
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/MD_Vector_base.h
@@ -0,0 +1,109 @@
+/****************************************************************************
+* Copyright (c) 2025, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef MD_Vector_base_included
+#define MD_Vector_base_included
+
+#include <TRUSTArray.h>
+#include <ArrOfBit.h>
+
+class Schema_Comm_Vecteurs;
+class Echange_EV_Options;
+class MD_Vector;
+class MD_Vector_seq;
+class MD_Vector_composite;
+class MD_Vector_std;
+
+/*! @brief Base class for distributed vectors parallel descriptors.
+ *
+ * See also the MD_Vector class (which is a kind of DERIV() of this class), and see derived classes
+ * MD_Vector_std, MD_Vector_composite and MD_Vector_seq.
+ */
+class MD_Vector_base : public Objet_U
+{
+  Declare_base(MD_Vector_base);
+
+public:
+
+  virtual int get_nb_items_reels() const { return nb_items_reels_; }
+  virtual int get_nb_items_tot() const { return nb_items_tot_; }
+  virtual trustIdType nb_items_seq_tot() const { return nb_items_seq_tot_; }
+  virtual int nb_items_seq_local() const { return nb_items_seq_local_; }
+
+  virtual const ArrOfInt& get_items_to_compute() const = 0;
+  virtual const ArrOfInt& get_items_to_sum() const = 0;
+
+  int get_sequential_items_flags(ArrOfBit& flags, int line_size=1) const;
+  int get_sequential_items_flags(ArrOfInt& flags, int line_size=1) const;
+
+  virtual bool validate(trustIdType sz_array, int line_size) const;
+
+  virtual void initialize_comm(const Echange_EV_Options& opt, Schema_Comm_Vecteurs&, DoubleVect&) const = 0;
+  virtual void prepare_send_data(const Echange_EV_Options& opt, Schema_Comm_Vecteurs&, DoubleVect&) const = 0;
+  virtual void process_recv_data(const Echange_EV_Options& opt, Schema_Comm_Vecteurs&, DoubleVect&) const = 0;
+
+  virtual void initialize_comm(const Echange_EV_Options& opt, Schema_Comm_Vecteurs&, FloatVect&) const = 0;
+  virtual void prepare_send_data(const Echange_EV_Options& opt, Schema_Comm_Vecteurs&, FloatVect&) const = 0;
+  virtual void process_recv_data(const Echange_EV_Options& opt, Schema_Comm_Vecteurs&, FloatVect&) const = 0;
+
+  virtual void initialize_comm(const Echange_EV_Options& opt, Schema_Comm_Vecteurs&, IntVect&) const = 0;
+  virtual void prepare_send_data(const Echange_EV_Options& opt, Schema_Comm_Vecteurs&, IntVect&) const = 0;
+  virtual void process_recv_data(const Echange_EV_Options& opt, Schema_Comm_Vecteurs&, IntVect&) const = 0;
+
+#if INT_is_64_ == 2
+  virtual void initialize_comm(const Echange_EV_Options& opt, Schema_Comm_Vecteurs&, TIDVect&) const = 0;
+  virtual void prepare_send_data(const Echange_EV_Options& opt, Schema_Comm_Vecteurs&, TIDVect&) const = 0;
+  virtual void process_recv_data(const Echange_EV_Options& opt, Schema_Comm_Vecteurs&, TIDVect&) const = 0;
+#endif
+
+  // Used in MD_Vector_tools:
+  virtual void fill_md_vect_renum(const IntVect& renum, MD_Vector& md_vect) const = 0;
+
+  // Tool method:
+  static void append_item_to_blocs(ArrOfInt& blocs, int item);
+
+  /*! Whether algorithms in TRUSTVect_tools should use the blocks stored in members MD_Vector_mono::blocs_items_to_*
+   */
+  virtual bool use_blocks() const = 0;
+
+protected:
+  // Actual implementation of the sequential flags retrieval - overriden in MD_Vector_seq:
+  virtual int get_seq_flags_impl(ArrOfBit& flags, int line_size) const;
+
+  // Tool methods:
+  static void append_blocs(ArrOfInt& dest, const ArrOfInt& src, int offset=0, int multiplier=1);
+  static void append_items(ArrOfInt& dest, const ArrOfInt& src, int offset=0, int multiplier=1);
+
+  // Nombre total d'items (reels+virtuels), utilise pour connaitre la taille des tableaux a creer
+  int nb_items_tot_ = -1;
+  // Nombre d'items "reels" (propriete dimension(0) du tableau ou size() pour le vecteur)
+  // En principe les items reels sont tous ceux appartenant aux elements reels, ils sont regroupes au
+  // debut du tableau aux indices 0 <= i < nb_items_reels_.
+  // Si ce nombre vaut -1, il n'y a pas de separation entre items reels et items virtuels
+  //  (cas des tableaux P1Bulle multilocalisation pour lesquels les items reels et virtuels sont melanges)
+  int nb_items_reels_ = -1;
+
+  // Nombre total (sur tous les procs) d'items sequentiels (c'est mp_sum(nb_items_seq_local_)) - cela peut depasser 32 bits.
+  trustIdType nb_items_seq_tot_ = -1;
+  // Nombre d'items sequentiels sur ce processeur (c'est le nombre d'items dans les blocs de blocs_items_to_sum_)
+  int nb_items_seq_local_ = -1;
+
+private:
+  // This class may modify ref_count_:
+  friend class MD_Vector;
+
+};
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/MD_Vector_mono.h b/Utilities/VisItBridge/databases/readers/Lata/MD_Vector_mono.h
new file mode 100644
index 00000000..a0149881
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/MD_Vector_mono.h
@@ -0,0 +1,65 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef MD_Vector_mono_included
+#define MD_Vector_mono_included
+
+#include <MD_Vector_base.h>
+
+/*! @brief Generic class for all mono-block MD_Vectors (i.e. non compoosite)
+ *
+ * The two main members of this class are blocs_items_to_sum_ and blocs_items_to_compute_.
+ * Note that those two members are hence **not** present in a MD_Vector_composite. For this case
+ * the redirection is made to the inner MD_Vector_mono member which aggregates the information.
+ *
+ * See also class MD_Vector_composite
+ */
+class MD_Vector_mono : public MD_Vector_base
+{
+
+  Declare_base(MD_Vector_mono);
+
+public:
+  const ArrOfInt& get_items_to_sum() const override { return blocs_items_to_sum_; }
+  const ArrOfInt& get_items_to_compute() const override { return blocs_items_to_compute_; }
+
+protected:
+  // MD_Vector_composite needs to see inside MD_Vector_mono because of its global_md_ member:
+  friend class MD_Vector_composite;
+
+  // Methods to extend/complete a MD_Vector_mono with another MD_Vector_mono - not all combinations are possible.
+  // See derived classes MD_Vector_seq and MD_Vector_std.
+  // For example extending a MD_Vector_std with a MD_Vector_seq is not possible.
+  virtual void append_from_other_std(const MD_Vector_std& src, int offset, int multiplier) { throw; }
+  virtual void append_from_other_seq(const MD_Vector_seq& src, int offset, int multiplier) { throw; }
+
+  // ***** Les membres suivants sont utilises pour calculer des sommes, produits scalaires, normes ******
+  // Indices de tous les items dont je suis proprietaire (ce sont les "items sequentiels", definis comme
+  //  etant tous ceux dont la valeur n'est pas recue d'un autre processeur lors d'un echange_espace_virtuel).
+  //  Pour faire une somme sur tous les items, il faut sommer les valeurs de tous les items
+  //  de ces blocs. Le tableau contient debut_bloc1, fin_bloc1, debut_bloc2, fin_bloc2, etc...
+  //  (fin_bloc est l'indice du dernier element + 1)
+  //  (structure utilisee pour les sauvegardes sequentielles (xyz ou debog), les calculs de normes de vecteurs, etc)
+  ArrOfInt blocs_items_to_sum_;
+  // Indices de tous les items pour lesquels il faut calculer une valeur
+  //  (utilise par DoubleTab::operator+=(const DoubleTab &) par exemple)
+  // En theorie, il suffirait de prendre blocs_items_to_sum_, mais ce dernier est
+  //  plein de trous et peut etre inefficace. En pratique, on calcule toutes les valeurs
+  //  reeles.
+  ArrOfInt blocs_items_to_compute_;
+
+
+};
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/MD_Vector_std_tools.tpp b/Utilities/VisItBridge/databases/readers/Lata/MD_Vector_std_tools.tpp
new file mode 100644
index 00000000..a6d447a4
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/MD_Vector_std_tools.tpp
@@ -0,0 +1,118 @@
+/****************************************************************************
+* Copyright (c) 2023, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef MD_Vector_std_tools_TPP_included
+#define MD_Vector_std_tools_TPP_included
+
+enum class VECT_ITEMS_TYPE { READ , WRITE , ADD , MAX };
+enum class VECT_BLOCS_TYPE { READ , WRITE , ADD };
+
+
+template<typename _TYPE_, VECT_ITEMS_TYPE _ITEM_TYPE_>
+extern void vect_items_generic(const int line_size, const ArrOfInt& voisins, const Static_Int_Lists& list, TRUSTArray<_TYPE_>& vect, Schema_Comm_Vecteurs& buffers);
+
+template<typename _TYPE_>
+inline void read_from_vect_items(const int line_size, const ArrOfInt& voisins, const Static_Int_Lists& list, TRUSTArray<_TYPE_>& vect, Schema_Comm_Vecteurs& buffers)
+{
+  vect_items_generic<_TYPE_,VECT_ITEMS_TYPE::READ>(line_size,voisins,list,vect,buffers);
+}
+
+template<typename _TYPE_>
+inline void write_to_vect_items(const int line_size, const ArrOfInt& voisins, const Static_Int_Lists& list, TRUSTArray<_TYPE_>& vect, Schema_Comm_Vecteurs& buffers)
+{
+  vect_items_generic<_TYPE_,VECT_ITEMS_TYPE::WRITE>(line_size,voisins,list,vect,buffers);
+}
+
+template<typename _TYPE_>
+inline void add_to_vect_items(const int line_size, const ArrOfInt& voisins, const Static_Int_Lists& list, TRUSTArray<_TYPE_>& vect, Schema_Comm_Vecteurs& buffers)
+{
+  vect_items_generic<_TYPE_,VECT_ITEMS_TYPE::ADD>(line_size,voisins,list,vect,buffers);
+}
+
+template<typename _TYPE_>
+inline void max_to_vect_items(const int line_size, const ArrOfInt& voisins, const Static_Int_Lists& list, TRUSTArray<_TYPE_>& vect, Schema_Comm_Vecteurs& buffers)
+{
+  vect_items_generic<_TYPE_,VECT_ITEMS_TYPE::MAX>(line_size,voisins,list,vect,buffers);
+}
+
+template<typename _TYPE_>
+inline void mincol1_to_vect_items(const int line_size, const ArrOfInt& voisins, const Static_Int_Lists& list, TRUSTArray<_TYPE_>& vect, Schema_Comm_Vecteurs& buffers)
+{
+  assert(line_size > 0);
+  _TYPE_ *data = vect.addr();
+  const int *items_to_process = list.get_data().addr();
+  int idx = 0; // Index in list.get_data()
+  const ArrOfInt& index = list.get_index();
+  const int nb_voisins = list.get_nb_lists();
+  for (int i_voisin = 0; i_voisin < nb_voisins; i_voisin++)
+    {
+      // Indice dans list.get_data() de la fin de la liste d'items/blocs pour ce voisin:
+      const int idx_end_of_list = index[i_voisin + 1];
+      // Nombre d'elements de tableau a envoyer/recevoir de ce voisin
+      const int nb_elems = (idx_end_of_list - idx) * line_size;
+      TRUSTArray<_TYPE_>& buffer = buffers.get_next_area_template < _TYPE_ >(voisins[i_voisin], nb_elems);
+      _TYPE_ *bufptr = buffer.addr();
+      assert(idx_end_of_list <= list.get_data().size_array());
+      while (idx < idx_end_of_list)
+        {
+          // Indice de l'item geometrique a copier (ou du premier item du bloc)
+          int premier_item_bloc = items_to_process[idx++];
+          const int bloc_size = 1;
+          // Adresse des elements a copier dans le vecteur
+          assert(premier_item_bloc >= 0 && bloc_size > 0 && (premier_item_bloc + bloc_size) * line_size <= vect.size_array());
+          _TYPE_ *vectptr = data + premier_item_bloc * line_size;
+          // Copy whole line if first line is greater than destination
+          assert(bufptr + line_size * bloc_size - buffer.addr() <= buffer.size_array());
+          for (int j = 0; j < bloc_size; j++)
+            {
+              _TYPE_ dest = *vectptr;
+              _TYPE_ src = *bufptr;
+              if (src < dest)
+                {
+                  for (int k = line_size; k; k--)
+                    *(vectptr++) = *(bufptr++);
+                }
+              else
+                {
+                  vectptr += line_size;
+                  bufptr += line_size;
+                }
+            }
+        }
+    }
+}
+
+template<typename _TYPE_, VECT_BLOCS_TYPE _ITEM_TYPE_>
+extern void vect_blocs_generic(const int line_size, const ArrOfInt& voisins, const Static_Int_Lists& list, const ArrOfInt& nb_items_par_voisin, TRUSTArray<_TYPE_>& vect, Schema_Comm_Vecteurs& buffers);
+
+template<typename _TYPE_>
+inline void read_from_vect_blocs(const int line_size, const ArrOfInt& voisins, const Static_Int_Lists& list, const ArrOfInt& nb_items_par_voisin, TRUSTArray<_TYPE_>& vect, Schema_Comm_Vecteurs& buffers)
+{
+  vect_blocs_generic<_TYPE_,VECT_BLOCS_TYPE::READ>(line_size,voisins,list,nb_items_par_voisin,vect,buffers);
+}
+
+template<typename _TYPE_>
+inline void write_to_vect_blocs(const int line_size, const ArrOfInt& voisins, const Static_Int_Lists& list, const ArrOfInt& nb_items_par_voisin, TRUSTArray<_TYPE_>& vect, Schema_Comm_Vecteurs& buffers)
+{
+  vect_blocs_generic<_TYPE_,VECT_BLOCS_TYPE::WRITE>(line_size,voisins,list,nb_items_par_voisin,vect,buffers);
+}
+
+template<typename _TYPE_>
+inline void add_to_vect_blocs(const int line_size, const ArrOfInt& voisins, const Static_Int_Lists& list, const ArrOfInt& nb_items_par_voisin, TRUSTArray<_TYPE_>& vect, Schema_Comm_Vecteurs& buffers)
+{
+  vect_blocs_generic<_TYPE_,VECT_BLOCS_TYPE::ADD>(line_size,voisins,list,nb_items_par_voisin,vect,buffers);
+}
+
+#endif /* MD_Vector_std_tools_TPP_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Motcle.cpp b/Utilities/VisItBridge/databases/readers/Lata/Motcle.cpp
new file mode 100644
index 00000000..029d9e80
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Motcle.cpp
@@ -0,0 +1,349 @@
+/****************************************************************************
+* Copyright (c) 2023, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <Motcle.h>
+#include <Noms.h>
+
+Implemente_instanciable_sans_constructeur(Motcle,"Motcle",Nom);
+Implemente_instanciable(Motcles,"Motcles",VECT(Motcle));
+
+
+/*! @brief Ecriture d'un Motcle sur un flot de sortie Utilise l'implementation de la classe Nom
+ *
+ * @param (Sortie& s) le flot de sortie a utiliser
+ * @return (Sortie&) le flot de sortie modifie
+ */
+Sortie& Motcle::printOn(Sortie& s) const
+{
+  return Nom::printOn(s);
+}
+
+
+/*! @brief Ecriture d'un tableau Motcles sur un flot de sortie
+ *
+ * @param (Sortie& s) le flot de sortie a utiliser
+ * @return (Sortie&) le flot de sortie modifie
+ */
+Sortie& Motcles::printOn(Sortie& s) const
+{
+  return VECT(Motcle)::printOn(s);
+}
+
+
+/*! @brief Lecture d'un Motcle dans un flot d'entree Utilise l'implementation de la classe Nom
+ *
+ *     Passe ensuite le Nom en majuscules
+ *
+ * @param (Entree& s) le flux d'entree a utiliser
+ * @return (Entree&) le flux d'entree modifie
+ */
+Entree& Motcle::readOn(Entree& s)
+{
+  Nom::readOn(s);
+  majuscule();
+  return s;
+}
+
+
+/*! @brief Constructeur par defaut Construit un Nom puis le passe en majuscule
+ *
+ */
+Motcle::Motcle() : Nom()
+{
+  majuscule();
+}
+
+
+/*! @brief Construction d'un Motcle a partie d'une chaine de caracteres Construit un Nom puis le passe en majuscules
+ *
+ * @param (const char* nom) la chaine de caracteres du Motcle
+ */
+Motcle::Motcle(const char* const nom) : Nom(nom)
+{
+  majuscule();
+}
+
+Motcle::Motcle(const std::string& nom) : Nom(nom)
+{
+  majuscule();
+}
+
+Motcle::Motcle(const Nom& nom) : Nom(nom)
+{
+  majuscule();
+}
+
+/*! @brief Construction d'un Motcle par copie
+ *
+ * @param (const Motcle& nom) le Motcle a copier
+ */
+Motcle::Motcle(const Motcle& nom) : Nom(nom)
+{
+}
+
+/*! @brief Construction a partir d'une chaine de caracteres Utilise l'implementation de la classe Nom
+ *
+ * @param (const char* const mot) la chaine de caracteres du mot a construire
+ * @return (Motcle&) reference sur le Motcle cree
+ */
+Motcle& Motcle::operator=(const char* const mot)
+{
+  Nom::operator=(mot);
+  majuscule();
+  return *this;
+}
+
+Motcle& Motcle::operator=(const Nom& mot)
+{
+  Nom::operator=(mot);
+  majuscule();
+  return *this;
+}
+
+/*! @brief Construction par copie Utilise l'implementation de la classe Nom
+ *
+ * @param (const Motcle& mot) le Motcle a copier
+ * @return (Motcle&) reference sur le Motcle modifie
+ */
+Motcle& Motcle::operator=(const Motcle& mot)
+{
+  Nom::operator=(mot);
+  return *this;
+}
+
+/*! @brief Lecture d'un tableau Motcles sur un flot d'entree
+ *
+ * @param (Entree& s) le flux d'entree a utiliser
+ * @return (Entree&) le flux d'entree modifie
+ */
+Entree& Motcles::readOn(Entree& s)
+{
+  return VECT(Motcle)::readOn(s);
+}
+
+
+/*! @brief Autotest de la classe Motcle Effectue des affectations de controle
+ *
+ *     Retourne toujours 1
+ *
+ * @return (int) code de retour; retourne toujours 1
+ */
+int Motcle::selftest()
+{
+  Nom un_nom;
+  Motcle un_motcle("PasOk");
+  Motcle un_autre(un_nom);
+  un_nom="Ok";
+  un_motcle=un_nom;
+  un_motcle="Ok";
+  un_motcle=un_autre;
+  return 1;
+}
+
+
+
+/*! @brief Constructeur Cree un tableau de i elements
+ *
+ * @param (int i) nombre de mots cles
+ */
+Motcles::Motcles(int i):
+  VECT(Motcle)(i)
+{
+}
+
+// "a"  == "a|b" returns 0
+// "b"  == "a|b" returns 0
+// "a|b" == "a|c" return 0
+static inline int strcmp_uppercase(const char *n1, const char *n2)
+{
+  // loop on n1
+  unsigned char c1,c2;
+  int i=0;
+  int length_i=0;
+  do
+    {
+      c1 = (unsigned char) ::toupper(n1[i]);
+      i++;
+      length_i++;
+      if (c1==0 || c1==124) // Keyword found in n1
+        {
+          // loop on c2
+          int j=0;
+          int length_j=0;
+          do
+            {
+              c2 = (unsigned char) ::toupper(n2[j]);
+              j++;
+              length_j++;
+              if (c2==0 || c2==124) // Keyword found in n2
+                {
+                  if (length_i==length_j)
+                    {
+                      // Same length, we compare each caracter:
+                      int l=length_i;
+                      int delta=0;
+                      unsigned char C1,C2;
+                      do
+                        {
+                          C1 = (unsigned char) ::toupper(n1[i-l]);
+                          C2 = (unsigned char) ::toupper(n2[j-l]);
+                          delta = C2 - C1;
+                          l--;
+                        }
+                      while (l>1 && delta==0);
+                      if (delta==0)
+                        return 0; // Found the same keyword
+                    }
+                  length_j=0;
+                }
+            }
+          while(c2!=0); // End of n2
+          length_i=0;
+        }
+    }
+  while (c1!=0); // End of n1
+  return 1;
+}
+
+/*! @brief Comparaison d'un mot cle avec une chaine de caracteres
+ *
+ * @param (const Motcle& un_mot) le mot cle a utiliser pour la comparaison
+ * @param (const char* const nom) la chaine de caractere avec laquelle comparer le mot cle
+ * @return (int) 1 si le Nom du mot est egal a la chaine
+ */
+int operator ==(const Motcle& nom, const Motcle& un_mot)
+{
+  const int resu = strcmp_uppercase((const char *) nom, (const char *)un_mot);
+  return (resu == 0);
+}
+
+int operator ==(const Motcle& un_mot, const char* const nom)
+{
+  const int resu = strcmp_uppercase((const char *)un_mot, nom);
+  return (resu == 0);
+}
+
+int operator ==(const char* const nom, const Motcle& un_mot)
+{
+  return (un_mot == nom);
+}
+
+int operator ==(const Motcle& un_mot, const Nom& nom)
+{
+  const int resu = strcmp_uppercase((const char *)un_mot, (const char *) nom);
+  return (resu == 0);
+}
+
+int operator ==(const Nom& nom, const Motcle& un_mot)
+{
+  return (un_mot == nom);
+}
+
+/*! @brief Comparaison d'un mot cle avec une chaine de caracteres
+ *
+ * @param (const Motcle& un_mot) le mot cle a utiliser pour la comparaison
+ * @param (const char* const nom) la chaine de caractere avec laquelle comparer le mot cle
+ * @return (int) 1 si le Nom du mot est different de la chaine
+ */
+int operator !=(const Motcle& nom, const Motcle& un_mot)
+{
+  return ! (nom == un_mot);
+}
+
+int operator !=(const Motcle& un_mot, const char* const nom)
+{
+  return ! (un_mot == nom);
+}
+
+int operator !=(const char* const nom, const Motcle& un_mot)
+{
+  return ! (nom == un_mot);
+}
+
+int operator !=(const Motcle& un_mot, const Nom& nom)
+{
+  return ! (un_mot == nom);
+}
+
+int operator !=(const Nom& nom, const Motcle& un_mot)
+{
+  return ! (nom == un_mot);
+}
+
+Motcle& Motcle::operator+=(const char * const mot)
+{
+  Nom::operator+=(mot);
+  majuscule();
+  return *this;
+}
+
+Motcles noms_to_motcles(const Noms& a)
+{
+  int n = a.size();
+
+  Motcles b(n);
+  for (int i = 0; i < n; i++)
+    b[i] = a[i]; // ouais, ecriture bizarre mais la plus efficace...
+  return b;
+}
+
+int Motcle::finit_par(const char* const mot) const
+{
+  Motcle mm(mot);
+  return Nom::finit_par(mm);
+}
+
+
+int Motcle::debute_par(const char* const mot) const
+{
+  Motcle mm(mot);
+  return Nom::debute_par(mm);
+}
+
+int Motcle::find(const char* const mot) const
+{
+  Motcle mm(mot);
+  return Nom::find(mm);
+}
+
+int Motcles::search(const Motcle& t ) const
+{
+  assert(size()>=0);
+  int i=size();
+  while(i--)
+    if (operator[](i)==t)
+      {
+        return i;
+      }
+  return -1;
+}
+
+int Motcles::contient_(const char* const ch) const
+{
+  return (rang(ch)!=-1);
+}
+/* Returns the VECT position number of a string (-1 if not found) */
+int Motcles::rang(const char* const ch) const
+{
+  Nom nom(ch);
+  assert(size()>=0);
+  int i=size();
+  while(i--)
+    if (operator[](i)==nom)
+      {
+        return i;
+      }
+  return -1;
+}
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Motcle.h b/Utilities/VisItBridge/databases/readers/Lata/Motcle.h
new file mode 100644
index 00000000..db7751aa
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Motcle.h
@@ -0,0 +1,73 @@
+/****************************************************************************
+* Copyright (c) 2023, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Motcle_included
+#define Motcle_included
+
+#include <TRUST_Vector.h>
+#include <Nom.h>
+
+/*! @brief Une chaine de caractere (Nom) en majuscules
+ *
+ */
+class Motcle : public Nom
+{
+  Declare_instanciable_sans_constructeur(Motcle);
+
+public:
+
+  Motcle();
+  Motcle(const Motcle& nom);
+  Motcle& operator=(const Motcle& );
+
+  Motcle(const char * const nom);
+  Motcle(const std::string& nom);
+  Motcle(const Nom&);
+  Motcle& operator=(const char * const);
+  Motcle& operator=(const Nom&);
+  Motcle& operator+=(const char * const);
+  int selftest();
+
+  int debute_par(const char* const n) const override;
+  int finit_par(const char* const n) const override;
+  int find(const char* const n) const override;
+
+  friend int operator ==(const Motcle& , const Motcle& ) ;
+  friend int operator !=(const Motcle& , const Motcle& ) ;
+  friend int operator ==(const Motcle& , const char* const ) ;
+  friend int operator !=(const Motcle& , const char* const ) ;
+  friend int operator ==(const char* const , const Motcle& ) ;
+  friend int operator !=(const char* const , const Motcle& ) ;
+  friend int operator ==(const Motcle& , const Nom& ) ;
+  friend int operator !=(const Motcle& , const Nom& ) ;
+  friend int operator ==(const Nom& , const Motcle& ) ;
+  friend int operator !=(const Nom& , const Motcle& ) ;
+};
+
+/*! @brief Un tableau d'objets de la classe Motcle
+ *
+ */
+class Motcles : public VECT(Motcle)
+{
+  Declare_instanciable(Motcles);
+public:
+  Motcles(int);
+  int rang(const char* const ch) const;
+  int contient_(const char* const ch) const;
+  int search(const Motcle& t ) const ;
+};
+
+#endif
+// MOTCLE_H
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Nom.cpp b/Utilities/VisItBridge/databases/readers/Lata/Nom.cpp
new file mode 100644
index 00000000..b525233b
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Nom.cpp
@@ -0,0 +1,600 @@
+/****************************************************************************
+* Copyright (c) 2025, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <Nom.h>
+#include <stdio.h>
+#include <string>
+#include <math.h>
+#include <algorithm>
+#include <cmath>
+
+int Nom::nb_noms=0;
+
+Implemente_instanciable_sans_constructeur_ni_destructeur(Nom,"Nom",Objet_U);
+// XD nom objet_u nom 0 Class to name the TRUST objects.
+// XD attr mot chaine mot 1 Chain of characters.
+
+
+int Nom::check_case_non_sensitive_=1;
+
+
+void Nom::sed_check_case_non_sensitive(int i)
+{
+  check_case_non_sensitive_=i;
+}
+
+/*! @brief Surcharge Objet_U::printOn(Sortie&) Ecriture d'un Nom sur un flot de sortie
+ *
+ * @param (Sortie& s) le flot de sortie a utiliser
+ * @return (Sortie&) le flot de sortie modifie
+ */
+Sortie& Nom::printOn(Sortie& s) const
+{
+  const char* nom=getChar();
+  if(nom)
+    return s << nom;
+  else
+    return s;
+}
+#define BUFLEN 100000
+
+/*! @brief Lecture d'un nom.
+ *
+ * En cas d'echec, le nom vaut "??" a la sortie.
+ *
+ */
+Entree& Nom::readOn(Entree& s)
+{
+  char buffer[BUFLEN];
+  const int ok = s.get(buffer, BUFLEN);
+  if (ok)
+    operator=(buffer);
+  else
+    operator=("??");
+  return s;
+}
+
+//// Nom()
+//
+
+/*! @brief Constructeur par defaut.
+ *
+ * Cree la chaine "??"
+ *
+ */
+Nom::Nom()
+{
+  nb_noms++;
+  nom_ = "??";
+}
+
+/*! @brief Construction d'un nom a partir d'un caractere
+ *
+ * @param (char c) le caractere du nom
+ */
+Nom::Nom(char c)
+{
+  nb_noms++;
+  nom_=c;
+}
+
+
+/*! @brief Construction d'un nom a partir d'un entier La chaine cree est la representation de l'entier
+ *
+ *     Exemple : Nom(128) cree la chaine "128"
+ *
+ * @param (int i) l'entier a utiliser
+ */
+Nom::Nom(True_int i)
+{
+  nb_noms++;
+  nom_ = "";
+  // 22 caracteres suffisent pour stocker n'importe quel entier
+  char chaine[22];
+  snprintf(chaine, 22, "%d", i);
+  operator=(chaine);
+}
+
+Nom::Nom(long i)
+{
+  nb_noms++;
+  nom_ = "";
+  // 22 caracteres suffisent pour stocker n'importe quel entier
+  char chaine[22];
+  snprintf(chaine, 22, "%ld", i);
+  operator=(chaine);
+}
+
+Nom::Nom(long long i)
+{
+  nb_noms++;
+  nom_ = "";
+  // 22 caracteres suffisent pour stocker n'importe quel entier long long
+  char chaine[22];
+  snprintf(chaine, 22, "%lld", i);
+  operator=(chaine);
+}
+
+/*! @brief Construction d'un nom a partir d'une chaine de caracteres La chaine est copiee
+ *
+ * @param (const char* nom) la chaine de caracteres a utiliser
+ */
+Nom::Nom(const char* nom) : nom_(nom)
+{
+  nb_noms++;
+}
+
+Nom::Nom(const std::string& nom) : nom_(nom)
+{
+  nb_noms++;
+}
+
+
+/*! @brief Constructeur par copie d'un nom
+ *
+ * @param (const Nom& nom) le nom a utiliser
+ */
+Nom::Nom(const Nom& nom) : Objet_U(nom), nom_(nom.nom_)
+{
+  nb_noms++;
+}
+
+/*! @brief Construction d'un nom a partir d'un flottant La chaine cree est la representation du nombre reel (snprintf)
+ *
+ * @param (double le_reel) le reel a utiliser
+ */
+Nom::Nom(double le_reel)
+{
+  nb_noms++;
+  nom_ = "";
+  char la_chaine[80];
+  snprintf(la_chaine,80,"%f",le_reel);
+  operator=(la_chaine);
+}
+
+/*! @brief Construction d'un nom a partir d'un flottant La chaine cree est la representation du nombre reel (snprintf)
+ *
+ *     Le format du nombre represente par la chaine est donne par format
+ *
+ * @param (double le_reel) le reel a utiliser
+ */
+Nom::Nom(double le_reel, const char* format)
+{
+  char la_chaine[80];
+  snprintf(la_chaine,80,format,le_reel);
+#ifdef MICROSOFT
+  // sous windows les chiffres s'ecrivent 1.0000e+000 (avec 3 chiffres pour les puissances)
+  // on retire le premier zero
+  unsigned int length=strlen(la_chaine);
+  if (la_chaine[length-5]=='e')
+    {
+      if (la_chaine[length-3]!='0') exit();
+      for (unsigned int i=length-3; i<=length; i++)
+        la_chaine[i]=la_chaine[i+1];
+    }
+#endif
+  nom_ =  la_chaine;
+  //delete[] la_chaine;
+  nb_noms++;
+}
+
+
+/*! @brief Destructeur
+ *
+ */
+Nom::~Nom()
+{
+  nb_noms--;
+}
+
+/*! @brief Transforme le nom en majuscules Seules les lettres 'a'-'z' sont modifiees
+ *
+ */
+Nom& Nom::majuscule()
+{
+  std::transform(nom_.begin(), nom_.end(), nom_.begin(), ::toupper);
+  return *this;
+}
+
+/*! @brief Renvoie le nombre de caracteres de la chaine du Nom y compris le caractere zero de fin de chaine.
+ *
+ *     Exemple : Nom("hello").longueur() == 6
+ *
+ */
+int Nom::longueur() const
+{
+  return (int)nom_.size()+1;
+}
+
+/*! @brief Copie la chaine nom.
+ *
+ * Modif BM pour que nom puisse pointer sur une sous-partie de nom_
+ *
+ */
+Nom& Nom::operator=(const char* const nom)
+{
+  nom_=nom;
+  return *this;
+}
+
+/*! @brief Copie le Nom nom
+ *
+ * @param (const Nom& nom) le nom a copier
+ * @return (Nom&) reference sur this qui represente la chaine du Nom nom
+ */
+Nom& Nom::operator=(const Nom& nom)
+{
+  nom_ = nom.nom_;
+  return *this;
+}
+
+/*! @brief Concatenation avec un Nom
+ *
+ * @param (const Nom& x) la nom a concatener
+ * @return (Nom&) reference sur this
+ */
+Nom& Nom::operator +=(const Nom& x)
+{
+  nom_ += x.nom_;
+  return *this;
+}
+
+Nom& Nom::operator+=(const char *x)
+{
+  nom_ += x;
+  return *this;
+}
+
+/*! @brief concatenation de chaine
+ *
+ */
+Nom& Nom::operator +=(char x)
+{
+  char n[2];
+  n[0] = x;
+  n[1] = 0;
+  operator+=(n);
+  return *this;
+}
+
+Nom& Nom::operator +=(unsigned char x)
+{
+  char n[2];
+  n[0] = (char)x;
+  n[1] = 0;
+  operator+=(n);
+  return *this;
+}
+
+
+Nom& Nom::operator +=(int x)
+{
+  nom_ += Nom(x);
+  return *this;
+}
+
+/*! @brief Extraction de suffixe : Nom x("azerty");
+ *
+ *      x.suffix("aze")
+ *      x contient "rty".
+ *
+ * @param (const char* const ch) chaine de caractere a utiliser comme prefixe
+ * @return (Nom&) reference sur this
+ */
+Nom& Nom::suffix(const char* const s)
+{
+  if (debute_par(s))
+    {
+      int n2 = (int)strlen(s);
+      nom_.erase(0,n2);
+    }
+  return *this;
+}
+
+const Nom Nom::getSuffix(const char* const s) const
+{
+  if (debute_par(s))
+    {
+      const int n1 = (int)strlen(s);
+      const int n2 = (int)nom_.size();
+      const std::string str1 = nom_.substr(n1,n2);
+      return Nom(str1);
+
+    }
+  return *this;
+}
+
+int Nom::debute_par(const std::string& ch) const
+{
+  return (nom_.rfind(ch, 0) == 0);
+}
+
+int Nom::finit_par(const std::string& s) const
+{
+  auto l = nom_.size(), e = s.size();
+  if (l >= e)
+    return (0 == nom_.compare(l - e, e, s));
+  else
+    return 0;
+}
+
+int Nom::find(const std::string& n) const
+{
+  std::size_t x = nom_.find(n);
+  return (x != std::string::npos) ? (int)x : -1;
+}
+
+int Nom::find(const char* const n ) const
+{
+  return find(std::string(n));
+}
+
+int Nom::debute_par(const char* const n) const
+{
+  return debute_par(std::string(n));
+}
+
+int Nom::finit_par(const char* const n) const
+{
+  return finit_par(std::string(n));
+}
+
+Nom& Nom::prefix(const char* const s)
+{
+  if (finit_par(s))
+    {
+      int n = (int)nom_.size();
+      int n2 = (int)strlen(s);
+      nom_.erase(n-n2,n2);
+    }
+  return *this;
+}
+
+const Nom Nom::getPrefix(const char* const s) const
+{
+  if (finit_par(s))
+    {
+      const int n1 = (int)nom_.size();
+      const int n2 = (int)strlen(s);
+      const std::string str1 = nom_.substr(0,n1-n2);
+      return Nom(str1);
+
+    }
+  return *this;
+}
+
+/*! @brief Concatenation avec un Nom
+ *
+ * @param (const Nom& x) la nom a concatener
+ * @return (Nom) le nouveau Nom cree avec la concatenation de this et de x
+ */
+Nom Nom::operator +(const Nom& x) const
+{
+  Nom nouveau(*this);
+  nouveau += x;
+  return nouveau;
+}
+
+/*! @brief Comparaison avec un Objet_U l'Objet_U est caste en Nom pour la comparaison
+ *
+ * @param (const Objet_U& x) l'Objet_U a utiliser pour la comparaison
+ * @return (int) 1 si egalite
+ */
+int Nom::est_egal_a(const Objet_U& x) const
+{
+#ifndef LATATOOLS
+  if (!(sub_type(Nom, x))) return 0;
+  return (*this == ref_cast( Nom, x));
+#else
+  const Nom& n2 = dynamic_cast<const Nom&>(x);
+  return (*this == n2);
+#endif
+}
+
+/*! @brief Insere _prefix000n (n=me() ou nproc()) dans un nom de fichier (par ex:toto.
+ *
+ * titi) pour donner toto_prefix000n.titi
+ *
+ * @param (without_padding) flag indiquant que l'on ne souhaite pas ajouter de zeros devant n
+ */
+Nom Nom::nom_me(int n, const char* prefixe, int without_padding) const
+{
+  int compteur=(int)nom_.size();
+  const char* ptr=nom_.c_str()+compteur;
+  while((*ptr!='.') && (*ptr!='/')&&(compteur>0))  // backward loop
+    {
+      ptr--;
+      compteur--;
+      if (*ptr=='/')
+        {
+          compteur=0;
+        }
+    }
+  int pas_de_point=0;
+  if(compteur==0)
+    {
+      compteur=(int)nom_.size();
+      pas_de_point=1 ;
+    }
+  std::string newname=nom_.substr(0,compteur);
+
+  //searching for the number of digits we want to write
+  int digits=0,diviseur=0;
+  if(without_padding)
+    {
+      digits = (n==0) ? 1 : (int)std::lrint(std::truncl(log10(n)+1.0));
+      diviseur = (int)std::lrint(std::truncl(pow(10, digits-1)));
+    }
+  else
+    {
+      if (Process::nproc()<=10000)
+        {
+          //the underscore will be taken into account later
+          //digits=5;
+          digits=4;
+          diviseur=1000;
+        }
+      else if (Process::nproc()<=100000)
+        {
+          //the underscore will be taken into account later
+          //digits=6;
+          digits=5;
+          diviseur=10000;
+        }
+      else if (Process::nproc()<=1000000)
+        {
+          //the underscore will be taken into account later
+          //digits=7;
+          digits=6;
+          diviseur=100000;
+        }
+      else
+        {
+          Cerr << "Error in Nom::nom_me. Contact TRUST support." << finl;
+          exit();
+        }
+
+    }
+
+  int prefix_len = 1; //for the underscore
+  if(prefixe) prefix_len+=(int)strlen(prefixe);
+
+  char *c_numero=new char[prefix_len+digits+1];
+  int resultat;
+  c_numero[0]='_';
+  if(prefixe) strcpy(c_numero+1, prefixe);
+  for (int i=prefix_len; i<prefix_len+digits; i++)
+    {
+      resultat=n/diviseur;
+      char c= (char)((int)'0' + resultat); // on old compilos, '+' is not for char, always int ...
+      c_numero[i]=c;
+      n-=resultat*diviseur;
+      diviseur/=10;
+    }
+  c_numero[prefix_len+digits]='\0';
+  newname+=c_numero;
+  if (pas_de_point==0)
+    newname+=ptr;
+  Nom new_name(newname);
+  delete[] c_numero;
+  return new_name;
+}
+
+/*! @brief Retourne un nom selon la commande usuelle substr ATTENTION : deb = 1 => premier caractere de la chaine !!!
+ *
+ */
+Nom Nom::substr_old(const int deb, const int la_longueur) const
+{
+
+  assert(deb > 0);
+  assert(deb - 1 + la_longueur <= (int) nom_.size());
+  Nom nouveau(nom_.substr(deb-1,la_longueur));
+  return nouveau;
+}
+
+/*! @brief Retourne fichier si le nom est sous la forme /toto/titi/fichier
+ *
+ * @param (Signification)
+ */
+Nom Nom::basename() const
+{
+  Nom dirname("");
+  Nom the_basename(nom_);
+  int iLength = (int)nom_.size();
+  for (int i=0; i<iLength; i++)
+    {
+      dirname+=nom_[i];
+      if (nom_[i]=='/' || nom_[i]=='\\')    // slash or backslash
+        {
+          the_basename.suffix(dirname);
+          dirname="";
+        }
+    }
+  return the_basename;
+}
+
+/*! @brief Retourne un pointeur sur la chaine de caractere du nom
+ *
+ * @return (char*) pointeur sur la chaine de caractere du nom
+ */
+Nom::operator const char*() const
+{
+  return nom_.c_str();
+}
+
+/*! @brief Comparaison d'un nom avec une chaine de caractere Utilise strcmp
+ *
+ * @param (const Nom& un_nom)
+ * @param (const char* const un_autre)
+ * @return (int) 1 si les noms sont egaux, 0 sinon
+ */
+int operator ==(const Nom& un_nom, const char* const un_autre)
+{
+  int res_actu=(un_nom.nom_.compare(un_autre)==0);
+#ifndef NDEBUG
+  if ((!res_actu) && (Nom::check_case_non_sensitive_==1))
+    {
+      Nom toto(un_autre);
+      if (toto.majuscule().nom_.compare(un_nom.getChar()) == 0)
+        {
+          Cerr << "Warning: " << un_nom << " and " << un_autre << " are they really different ?" << finl;
+          Cerr << "A test in the code on a string of characters does not seem to take account of the case." << finl;
+          Cerr << "Contact TRUST support by sending your data file of this calculation." << finl;
+          Cerr << finl;
+        }
+    }
+#endif
+  return res_actu;
+}
+
+int operator ==(const Nom& un_nom, const Nom& un_autre)
+{
+  return (un_nom==un_autre.getChar());
+}
+
+int operator ==(const char* const un_autre, const Nom& un_nom)
+{
+  return (un_nom == un_autre);
+}
+
+/*! @brief Comparaison d'un nom avec une chaine de caractere
+ *
+ * @param (const Nom& un_nom)
+ * @param (const char* const un_autre)
+ * @return (int) 1 si les noms sont differents, 0 sinon
+ */
+int operator !=(const Nom& un_nom, const char* un_autre)
+{
+  return ! (un_nom == un_autre);
+}
+
+int operator !=(const Nom& un_nom, const Nom& un_autre)
+{
+  return ! (un_nom == un_autre);
+}
+
+int operator !=(const char* const un_autre, const Nom& un_nom)
+{
+  return ! (un_autre == un_nom);
+}
+
+/*! @brief Renvoie *this;
+ *
+ * @return (const Nom&) reference sur le Nom
+ */
+const Nom& Nom::le_nom() const
+{
+  return *this;
+}
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Nom.h b/Utilities/VisItBridge/databases/readers/Lata/Nom.h
new file mode 100644
index 00000000..887afa4c
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Nom.h
@@ -0,0 +1,101 @@
+/****************************************************************************
+* Copyright (c) 2025, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+
+
+#ifndef Nom_included
+#define Nom_included
+
+#include <Objet_U.h>
+#include <cstring>
+#include <string>
+
+/*! @brief class Nom Une chaine de caractere pour nommer les objets de TRUST
+ *
+ * @sa Motcle
+ */
+
+class Nom : public Objet_U
+{
+  Declare_instanciable_sans_constructeur_ni_destructeur(Nom);
+public:
+  Nom();                                         // construit "??"
+  Nom(True_int i);                                // Nom(485)="485"
+  Nom(long i);                                    // Nom(485)="485"
+  Nom(long long i);                                    // Nom(485)="485"
+  Nom(const char* nom);
+  Nom(const std::string& nom);
+  Nom(const Nom&);
+  Nom(char c);
+  Nom(double );
+  Nom(double le_reel, const char* format);
+  ~Nom() override;
+
+  operator const char*() const;
+
+  Nom&   majuscule();
+  int est_egal_a(const Objet_U&) const override;
+  int longueur() const ;
+  const Nom& le_nom() const override;
+
+  Nom& operator=(const char* const);
+  Nom& operator=(const Nom&);
+  Nom operator +(const Nom&) const;
+  Nom& operator +=(const Nom& x);
+  Nom& operator +=(const char *);
+  Nom& operator +=(char x);
+  Nom& operator +=(unsigned char x);
+  Nom& operator +=(int x);
+  Nom& suffix(const char* const) ;
+  const Nom getSuffix(const char* const) const ;
+  Nom& prefix(const char* const) ;
+  const Nom getPrefix(const char* const) const ;
+  Nom nom_me(int, const char* prefix=0, int without_padding=0) const;
+  Nom substr_old(const int, const int) const;
+  Nom basename() const;
+
+  virtual int find(const char* const n) const;
+  virtual int debute_par(const char* const n) const;
+  virtual int finit_par(const char* const n) const;
+
+  int find(const std::string& n) const;
+  int debute_par(const std::string&) const;
+  int finit_par(const std::string&) const;
+
+  friend int operator ==(const Nom& , const char* const) ;
+  friend int operator !=(const Nom& , const char* ) ;
+  friend int operator ==(const Nom& , const Nom&) ;
+  friend int operator !=(const Nom& , const Nom& ) ;
+  friend int operator ==(const char* const, const Nom&) ;
+  friend int operator !=(const char* const, const Nom&) ;
+  inline bool contient(const Nom& nom) const
+  {
+    std::size_t found = nom_.find(nom.nom_);
+    return found!=std::string::npos;
+  }
+  inline const char* getChar() const  {  return nom_.c_str();  }
+  inline const std::string& getString() const  {    return nom_;   }
+  inline std::string& getString()  {  return nom_;   }
+
+  static void sed_check_case_non_sensitive(int i) ;
+protected :
+
+  static int nb_noms;
+  std::string nom_;
+
+  static int check_case_non_sensitive_; // pour descativer dans ==
+};
+
+#endif // NOM_H
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Noms.cpp b/Utilities/VisItBridge/databases/readers/Lata/Noms.cpp
new file mode 100644
index 00000000..1b21973a
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Noms.cpp
@@ -0,0 +1,75 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <Noms.h>
+Implemente_instanciable(Noms,"Noms",VECT(Nom));
+
+// XD nom_anonyme nom nul -1 not_set
+// XD vect_nom listobj vect_nom 0 nom_anonyme 0 Vect of name.
+// XD list_nom listobj list_nom 1 nom_anonyme 0 List of name.
+// XD list_nom_virgule listobj list_nom_virgule 1 nom_anonyme 1 List of name.
+
+// XD un_pb objet_lecture nul 0 pour les groupes
+// XD   attr mot ref_Pb_base mot 0 the string
+// XD list_un_pb listobj nul 1 un_pb 1 pour les groupes
+
+Sortie& Noms::printOn(Sortie& s) const
+{
+  return VECT(Nom)::printOn(s);
+}
+
+Entree& Noms::readOn(Entree& s)
+{
+  return VECT(Nom)::readOn(s);
+}
+
+int Noms::search(const Nom& t ) const
+{
+  //Use rang() now
+  return rang(t.getString().c_str());
+}
+
+int Noms::search_without_checking_Motcle(const Nom& t ) const
+{
+  assert(size()>=0);
+  int i=size();
+  while(i--)
+    {
+      const Nom& unnom=operator[](i);
+      if (unnom.getString().compare(t)==0)
+        {
+          return i;
+        }
+    }
+  return -1;
+}
+
+int Noms::contient_(const char* const ch) const
+{
+  return (rang(ch)!=-1);
+}
+/* Returns the VECT position number of a string (-1 if not found) */
+int Noms::rang(const char* const ch) const
+{
+  //Optimization to avoid creating an object Nom:
+  assert(size()>=0);
+  int i=size();
+  while(i--)
+    if (operator[](i).getString()==ch)
+      {
+        return i;
+      }
+  return -1;
+}
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Noms.h b/Utilities/VisItBridge/databases/readers/Lata/Noms.h
new file mode 100644
index 00000000..a52f0c74
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Noms.h
@@ -0,0 +1,42 @@
+/****************************************************************************
+* Copyright (c) 2023, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Noms_included
+#define Noms_included
+
+#include <TRUST_Vector.h>
+#include <Nom.h>
+
+/*! @brief Un tableau de chaine de caracteres (VECT(Nom))
+ *
+ */
+class Noms : public VECT(Nom)
+{
+  Declare_instanciable(Noms);
+public :
+  inline Noms(int );
+  int rang(const char* const ch) const;
+  int contient_(const char* const ch) const;
+  int search(const Nom& t ) const ;
+  int search_without_checking_Motcle(const Nom& t ) const ;
+};
+
+
+/*! @brief Constructeur Construit un tableau de i noms
+ *
+ * @param (int i) nombre d'elements du tableau
+ */
+inline Noms::Noms(int i): VECT(Nom)(i) {}
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Objet_U.cpp b/Utilities/VisItBridge/databases/readers/Lata/Objet_U.cpp
new file mode 100644
index 00000000..ca63a529
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Objet_U.cpp
@@ -0,0 +1,360 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <Objet_U.h>
+#include <Nom.h>
+
+#ifndef LATATOOLS
+#include <Memoire.h>
+#include <Interprete_bloc.h>
+#include <Lire.h>
+
+int Objet_U::dimension=0;
+int Objet_U::format_precision_geom=11;
+int Objet_U::axi=0;
+int Objet_U::bidim_axi=0;
+int Objet_U::static_obj_counter_=0;
+int Objet_U::DEACTIVATE_SIGINT_CATCH=0;
+bool Objet_U::computeOnDevice=true;
+Interprete* Objet_U::l_interprete=0;
+
+int Objet_U::disable_TU=0; // Flag to disable or not the writing of the .TU files
+bool Objet_U::stat_per_proc_perf_log=false; // Flag to enable the writing of the statistics detailed per processor in _csv.TU file
+Type_info Objet_U::info_obj("Objet_U");
+
+// Permet de debugger en remontant a la creation d'un objet donne:
+static int object_id_to_track = -1;
+
+// Fonction utilitaire pour intercepter la creation d'un objet
+// ATTENTION: depuis gcc3, le compilo genere plusieurs routines pour
+//  chaque constructeur: au moins Objet_U::Objet_U() et Objet_U::Objet_U$base()
+//  Cela rend difficile l'utilisation de breakpoints dans ces routines.
+//  Poser le breakpoint ici:
+static void object_trap(int obj_id)
+{
+  Cerr << "Objet_U::Objet_U() : object_id_=" << obj_id << finl;
+}
+
+/*! @brief Constructeur par defaut : attribue un numero d'identifiant unique a l'objet (object_id_), et enregistre l'objet en "memoire"
+ *
+ *    en lui donnant un numero _num_obj_. L'object_id_ et tres
+ *    pratique pour debugger...
+ *
+ */
+Objet_U::Objet_U() :  Process(),
+  object_id_(static_obj_counter_++)
+{
+  int obj_id = object_id_;
+  if (obj_id == object_id_to_track)
+    {
+      object_trap(obj_id);
+    }
+  Memoire& memoire = Memoire::Instance();
+  _num_obj_ = memoire.add(this);
+}
+
+/*! @brief Constructeur par copie.
+ *
+ * Cree un nouveau numero d'objet (ne copie pas le numero de l'autre objet !)
+ *
+ */
+Objet_U::Objet_U(const Objet_U&) : Process(),
+  object_id_(static_obj_counter_++)
+{
+  int obj_id = object_id_;
+  if (obj_id == object_id_to_track)
+    {
+      object_trap(obj_id);
+    }
+  Memoire& memoire = Memoire::Instance();
+  _num_obj_ = memoire.add(this);
+}
+
+/*! @brief Operateur= : ne fait rien (on conserve le numero et l'identifiant)
+ *
+ */
+const Objet_U& Objet_U::operator=(const Objet_U&)
+{
+  return *this;
+}
+
+/*! @brief Renvoie l'identifiant unique de l'objet object_id_
+ *
+ */
+int Objet_U::get_object_id() const
+{
+  return object_id_;
+}
+
+/*! @brief renvoie la chaine identifiant la classe.
+ *
+ * @return (const Nom&) Nom identifiant la classe de l'objet
+ */
+const Nom& Objet_U::que_suis_je() const
+{
+  return get_info()->name();
+}
+
+/*! @brief Lecture des parametres de type non simple d'un objet_U a partir d'un flot d'entree.
+ *
+ * @param (Motcle& motlu) le nom du terme a lire
+ * @param (Entree& is) un flot d'entree
+ * @return (int) negative value if the keyword is not understood, otherwise positive value.
+ */
+int Objet_U::lire_motcle_non_standard(const Motcle& motlu, Entree& is)
+{
+  Cerr << "The method " << __func__ << " must be overloaded in " << que_suis_je() << " !!!!" << finl;
+  Process::exit();
+  return -1;
+}
+
+/*! @brief Donne des informations sur le type de l'Objet_U
+ *
+ * @return (const Type_info*) structure regroupant les informations sur le type de l'Objet_U
+ */
+const Type_info*  Objet_U::get_info() const
+{
+  return &info_obj;
+}
+
+
+/*! @brief Donne des informations sur le type de l'Objet_U
+ *
+ * @return (const Type_info*) structure regroupant les informations sur le type de l'Objet_U
+ */
+const Type_info*  Objet_U::info()
+{
+  return &info_obj;
+}
+
+/*! @brief Renvoie une reference constante vers le nom du cas.
+ *
+ * Cette methode est statique.
+ *
+ */
+const Nom& Objet_U::nom_du_cas()
+{
+  return get_set_nom_du_cas();
+}
+
+/*! @brief Renvoie une reference non constante vers le nom du cas (pour pouvoir le modifier).
+ *
+ *   Cette methode est statique.
+ *
+ */
+Nom& Objet_U::get_set_nom_du_cas()
+{
+  // Cet objet statique est construit au premier appel
+  // a la fonction.
+  static Nom nom_du_cas_;
+  return nom_du_cas_;
+}
+
+/*! @brief methode ajoutee pour caster en python
+ *
+ */
+const Objet_U& Objet_U::self_cast(const Objet_U& obj)
+{
+  return ref_cast_non_const(Objet_U,obj);
+}
+Objet_U& Objet_U::self_cast(Objet_U& obj)
+{
+  return ref_cast_non_const(Objet_U,obj);
+}
+
+/*! @brief Change le numero interne de l'Objet_U
+ *
+ * @param (const int* const new_ones) tableau compose des nouveaux numeros, indexe par les anciens numeros
+ * @return (int) le nouveau numero affecte a l'Objet_U
+ */
+int Objet_U::change_num(const int* const new_ones)
+{
+  return _num_obj_=new_ones[_num_obj_];
+}
+
+
+/*! @brief Donne le nom du type de l'Objet_U
+ *
+ * @return (const char*) chaine de caracteres representant le type de l'Objet_U
+ */
+const char* Objet_U::le_type() const
+{
+  return get_info()->name();
+}
+
+/*! @brief Associe l'Objet_U a un autre Objet_U Methode virtuelle a surcharger
+ *
+ * @param (Objet_U&) l'Objet_U avec lequel doit s'effectuer l'association
+ * @return (int) code de retour
+ */
+int Objet_U::associer_(Objet_U&)
+{
+  return 0;
+}
+
+static Interprete& interprete_bidon()
+{
+  static Lire bidon;
+  return bidon;
+}
+// BM : a supprimer a terme (utiliser Interprete::objet)
+const Interprete& Objet_U::interprete() const
+{
+  return interprete_bidon();
+}
+
+// BM : a supprimer a terme (utiliser Interprete::objet)
+Interprete& Objet_U::interprete()
+{
+  return interprete_bidon();
+}
+
+/*! @brief retourne x.
+ *
+ * est_egal_a(y)
+ *
+ * @param (const Objet_U& x) Objet_U a utiliser pour la comparaison
+ * @param (const Objet_U& y) Objet_U a utiliser pour la comparaison
+ * @return (int) 1 si les deux Objet_U sont egaux, 0 sinon
+ */
+int operator==(const Objet_U& x, const Objet_U& y)
+{
+  return x.est_egal_a(y);
+}
+
+/*! @brief Comparaison de deux Objet_U x et y Renvoie 1 - x.
+ *
+ * est_egal_a(y);
+ *
+ * @param (const Objet_U& x) Objet_U a utiliser pour la comparaison
+ * @param (const Objet_U& y) Objet_U a utiliser pour la comparaison
+ * @return (int) 1 si les deux Objet_U sont differents, 0 s'ils sont egaux
+ */
+int operator!=(const Objet_U& x, const Objet_U& y)
+{
+  return (1-(x.est_egal_a(y)));
+}
+
+#endif   // LATATOOLS
+
+double Objet_U::precision_geom = 1e-10;
+
+/*! @brief Destructeur, supprime l'objet de la liste d'objets enregistres dans "memoire".
+ *
+ */
+Objet_U::~Objet_U()
+{
+#ifndef LATATOOLS
+  Memoire& memoire = Memoire::Instance();
+  memoire.suppr(_num_obj_);
+  _num_obj_ = -2; // Paranoia
+#endif
+}
+
+/*! @brief Renvoie l'indice de l'objet dans Memoire::data
+ *
+ */
+int Objet_U::numero() const
+{
+#ifndef LATATOOLS
+  return _num_obj_;
+#else
+  return 0;
+#endif
+}
+
+/*! @brief Ecriture de l'objet sur un flot de sortie Methode a surcharger
+ *
+ * @param (Sortie& s) flot de sortie
+ * @return (Sortie&) flot de sortie modifie
+ */
+Sortie& Objet_U::printOn(Sortie& s) const
+{
+  return s;
+}
+
+
+/*! @brief Lecture d'un Objet_U sur un flot d'entree Methode a surcharger
+ *
+ * @param (Entree& s) flot d'entree
+ * @return (Entree& s) flot d'entree modifie
+ */
+Entree& Objet_U::readOn(Entree& s)
+{
+  return s;
+}
+
+/*! @brief Renvoie 1 si l'objet x et *this sont une seule et meme instance (meme adresse en memoire).
+ *
+ */
+int Objet_U::est_egal_a(const Objet_U& x) const
+{
+#ifndef LATATOOLS
+  int resultat;
+  if (&x==this)
+    resultat = 1;
+  else
+    resultat = 0;
+  return resultat;
+#else
+  return 0;
+#endif
+}
+
+/*! @brief Donne le nom de l'Objet_U Methode a surcharger : renvoie "neant" dans cette implementation
+ *
+ * @return (Nom&) le nom de l'Objet_U
+ */
+const Nom& Objet_U::le_nom() const
+{
+  static Nom inconnu="neant";
+  return inconnu;
+}
+
+/*! @brief Donne un nom a l'Objet_U Methode virtuelle a surcharger
+ *
+ * @param (const Nom&) le nom a affectuer a l'Objet_U
+ */
+void Objet_U::nommer(const Nom&)
+{
+}
+
+/*! @brief Reprise d'un Objet_U sur un flot d'entree Methode a surcharger
+ *
+ * @param (Entree&) flot d'entree a utiliser pour la reprise
+ * @return (int) code de retour
+ */
+int Objet_U::reprendre(Entree&)
+{
+#ifndef LATATOOLS
+  Cerr << "The method " << __func__ << " must be overloaded in " << que_suis_je() << " !!!!" << finl;
+  Process::exit();
+#endif
+  return 1;
+}
+
+/*! @brief Sauvegarde d'un Objet_U sur un flot de sortie Methode a surcharger
+ *
+ * @param (Sortie&) flot de sortie a utiliser pour la sauvegarde
+ * @return (int) code de retour
+ */
+int Objet_U::sauvegarder(Sortie& ) const
+{
+#ifndef LATATOOLS
+  Cerr << "The method " << __func__ << " must be overloaded in " << que_suis_je() << " !!!!" << finl;
+  Process::exit();
+#endif
+  return 0;
+}
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Objet_U.h b/Utilities/VisItBridge/databases/readers/Lata/Objet_U.h
new file mode 100644
index 00000000..e98e1314
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Objet_U.h
@@ -0,0 +1,153 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+
+#ifndef Objet_U_included
+#define Objet_U_included
+
+//     On rencontre des fous
+//     qui #define min max ou throw!
+#undef min
+#undef max
+#undef throw
+
+#include <assert.h>
+#include <DecBaseInst.h>
+
+#ifdef LATATOOLS
+#include <LataJournal.h>
+#include <Sortie.h>
+#include <Entree.h>
+#define Cerr Journal()
+#define finl std::endl
+#define tspace " "
+
+#else
+#include <EntreeSortie.h>
+#endif
+
+#include <Process.h>
+
+class Type_info;
+class Interprete;
+class Motcle;
+/*! @brief classe Objet_U Cette classe est la classe de base des Objets de TRUST
+ *
+ *      Dans les classes derivees de Objet_U, on ajoute toujours
+ *       une macro Declare_instanciable ou Declare_base qui donne aux
+ *       objets les proprietes suivantes:
+ *      Un Objet_U peut etre lu dans une Entree ou ecrit dans une Sortie
+ *       (entree/sortie standard, jeu de donnees .data, fichier disque,
+ *        buffer memoire, buffer de communication parallele).
+ *        Il faut donc toujours implementer les methodes readOn et printOn
+ *      Un Objet_U d'un type quelconque peut etre instancie grace a une
+ *       chaine de caracteres qui l'identifie (que_suis_je()), voir OWN_PTR::typer
+ *      Un Objet_U peut etre "sauvegarde" ou "repris" sur disque (au sens sauvegarde
+ *       et reprise d'un calcul). Ces operations sont differentes de readOn/printOn
+ *       car elles permettent eventuellement une redistribution des donnees paralleles
+ *       ou des changements de version.
+ *      Un Objet_U, s'il est "Declare_instanciable", peut etre cree dynamiquement et lu
+ *       dans le jeu de donnees TRUST (a travers readOn). Il possede alors le nom
+ *       (le_nom()) attribue dans le jeu de donnees (voir les classes Interprete_bloc et Lire)
+ *      Un Objet_U fait l'objet d'une gestion memoire speciale par le noyau permettant
+ *       le debuggage et l'optimisation (operations specifiques a la creation,
+ *       a la destruction et a la copie)
+ *
+ * @sa Memoire Objet_U_ptr Process, Classe abstraite
+ */
+class Objet_U : public Process
+{
+public:
+  friend class Sortie;
+  friend class Entree;
+
+  ~Objet_U() override;
+  int        numero() const;
+  virtual int    duplique()  const =0;
+  virtual Sortie&   printOn(Sortie& ) const;
+  virtual Entree&   readOn(Entree& ) ;
+  virtual unsigned  taille_memoire() const =0;
+  virtual int    est_egal_a(const Objet_U&) const;
+  virtual const Nom& le_nom() const;
+  static double precision_geom;
+
+  virtual void       nommer(const Nom&);
+  virtual int    reprendre(Entree& ) ;
+  virtual int    sauvegarder(Sortie& ) const;
+
+
+#ifndef LATATOOLS            // All the below is not needed in lata_tools:
+  int        get_object_id() const;
+
+  // Elie Saikali : add to this to statically test if class templates are REF/OWN_PTR or normal !
+  static constexpr bool HAS_POINTER = false;
+
+  static int dimension;
+  static int format_precision_geom;
+  static int axi;
+  static int bidim_axi;
+  static int DEACTIVATE_SIGINT_CATCH; // flag to not enter the overloaded function signal_callback_handler
+  static const Nom& nom_du_cas();
+  static Nom& get_set_nom_du_cas();
+
+  static Type_info         info_obj;
+  virtual const Type_info* get_info() const;
+  static const Type_info*  info();
+
+  const Nom&         que_suis_je() const;
+  const char*        le_type() const;
+
+  friend int     operator ==(const Objet_U&, const Objet_U&);
+  friend int     operator !=(const Objet_U&, const Objet_U&);
+  virtual int    change_num(const int* const );
+  virtual int lire_motcle_non_standard(const Motcle& motlu, Entree& is);
+  virtual int    associer_(Objet_U&) ;
+  const Interprete& interprete() const;
+  Interprete& interprete();
+  /* methode rajoutee pour caster en python */
+  static const Objet_U& self_cast(const Objet_U&);
+  static Objet_U& self_cast( Objet_U&);
+
+  static int disable_TU; // Flag to disable the writing of the .TU files
+  static bool stat_per_proc_perf_log; // Flag to enable the writing of the statistics detailed per processor in _csv.TU file
+  static bool computeOnDevice; // Flag pour activer/desactiver calcul sur GPU
+protected:
+  Objet_U();
+  Objet_U(const Objet_U&);
+  const Objet_U& operator=(const Objet_U&);
+
+private:
+  // Numero de l'objet (indice de l'objet dans Memoire::data)
+  // Ce numero peut changer entre la construction et la destruction.
+  int _num_obj_;
+  // Identifiant unique de l'objet (attribue par le constructeur,
+  // et jamais modifie ensuite).
+  const int object_id_;
+
+  // Compteur d'objets crees (incremente par le constructeur).
+  static int static_obj_counter_;
+  static Interprete* l_interprete;
+
+#endif
+};
+
+#ifndef LATATOOLS
+int operator==(const Objet_U& x, const Objet_U& y) ;
+int operator!=(const Objet_U& x, const Objet_U& y) ;
+#endif
+
+#endif
+
+
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Objet_U_ptr.h b/Utilities/VisItBridge/databases/readers/Lata/Objet_U_ptr.h
new file mode 100644
index 00000000..12c5b4f8
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Objet_U_ptr.h
@@ -0,0 +1,78 @@
+/****************************************************************************
+* Copyright (c) 2023, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Objet_U_ptr_included
+#define Objet_U_ptr_included
+
+#include <Objet_U.h>
+
+class Nom;
+
+/*! @brief Pointeur sur un Objet_U.
+ *
+ * Le constructeur par defaut construit un pointeur "nul".
+ *
+ *
+ * @sa TRUST_Deriv
+ */
+class Objet_U_ptr: public Objet_U
+{
+  Declare_base_sans_constructeur_ni_destructeur(Objet_U_ptr);
+
+public:
+  static constexpr bool HAS_POINTER = true;
+  Objet_U_ptr(const Objet_U_ptr&) = delete;
+  const Objet_U_ptr& operator=(const Objet_U_ptr&) = delete;
+
+  bool non_nul() const;
+  bool est_nul() const;
+
+  const Nom& le_nom() const override;
+  Objet_U * typer(const char * nom_type);
+  void detach();
+#ifndef LATATOOLS
+  int associer_(Objet_U& objet) override;
+#endif
+
+protected:
+  ~Objet_U_ptr() override;
+  Objet_U_ptr();
+
+  virtual void set_Objet_U_ptr(Objet_U*);
+  virtual Objet_U* get_Objet_U_ptr() const;
+
+  void recopie(const Objet_U&);
+#ifndef LATATOOLS
+  int change_num(const int* const) override; // renumerotation des objets
+#endif
+
+  Objet_U* get_Objet_U_ptr_check() const;
+  int check_Objet_U_ptr_type(const Objet_U *ptr) const;
+
+  // Renvoie le Type_info du type de base accepte par le pointeur (l'objet pointe derive obligatoirement de ce type).
+  virtual const Type_info& get_info_ptr() const = 0;
+
+private:
+  // cle_ est le numero de cle de l'objet en reference.
+  // Si cle_ == -1, le pointeur est "nul".
+  // L'objet peut etre recupere par la_memoire().objet_u(cle_)
+  // Attention, la cle_ peut changer au cours du deroulement du programme (voir Memoire::comprimer())
+  int cle_ = -1;
+  // ptr_object_id_ est l'object_id_ de l'objet en reference.
+  // Permet de tester facilement si on pointe sur l'objet que l'on croit.
+  int ptr_object_id_ = -1;
+};
+
+#endif // Objet_U_ptr_H
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Octree_Double.cpp b/Utilities/VisItBridge/databases/readers/Lata/Octree_Double.cpp
new file mode 100644
index 00000000..5c2bd934
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Octree_Double.cpp
@@ -0,0 +1,209 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <Octree_Double.h>
+
+template <typename _SIZE_>
+void Octree_Double_32_64<_SIZE_>::reset()
+{
+  dim_ = 0;
+  octree_int_.reset();
+  origin_.reset();
+  factor_.reset();
+}
+
+/*! @brief cherche les elements ou les points contenus dans l'octree_floor qui contient le point (x,y,z).
+ *
+ * Renvoie le nombre n de ces elements.
+ *   Les indices des elements sont dans floor_elements()[index+i] pour 0 <= i < n
+ *
+ */
+template <typename _SIZE_>
+typename Octree_Double_32_64<_SIZE_>::int_t Octree_Double_32_64<_SIZE_>::search_elements(double x, double y, double z, int_t& index) const
+{
+  if (dim_ == 0)
+    return 0; // octree vide
+  int ix = 0, iy = 0, iz = 0;
+  int ok = integer_position(x, 0, ix)
+           && integer_position(y, 1, iy)
+           && integer_position(z, 2, iz);
+  return ok ? octree_int_.search_elements(ix, iy, iz, index) : 0;
+}
+
+/*! @brief construit un octree contenant les points de coordonnees coords.
+ *
+ * Si include_virtual=1, on stocke coords.dimension_tot(0) elements, sinon on en
+ *   stocke coords.dimension(0)
+ *   Si epsilon = 0, on construit un octree de points de taille nulle (chaque point
+ *    se trouve dans un seul octree_floor)
+ *   Sinon, on construit un octree d'elements cubiques centres sur les coords, de demie-largeur epsilon.
+ *    Un point peut alors se trouver dans plusieurs octree_floor.
+ *
+ */
+template <typename _SIZE_>
+void Octree_Double_32_64<_SIZE_>::build_nodes(const DoubleTab_t& coords, const bool include_virtual, const double epsilon)
+{
+  octree_int_.reset();
+  compute_origin_factors(coords, epsilon, include_virtual);
+  const int_t nb_som = include_virtual ? coords.dimension_tot(0) : coords.dimension(0);
+  if (nb_som == 0)
+    return; // octree vide
+  const int dim = coords.dimension_int(1);
+  if (epsilon < 0.)
+    {
+      Cerr << "Internal error in Octree_Double_32_64<_SIZE_>::build_nodes: negative epsilon" << finl;
+      Process::exit();
+    }
+  bool have_epsilon = (epsilon != 0.);
+  IntTab_t elements_boxes;
+  elements_boxes.resize(nb_som, have_epsilon ? (dim*2) : dim, RESIZE_OPTIONS::NOCOPY_NOINIT);
+
+  for (int_t i = 0; i < nb_som; i++)
+    for (int j = 0; j < dim; j++)
+      {
+        int pos1 = 0;
+        const double x0 = coords(i, j);
+        double x = x0 - epsilon;
+        if (!integer_position(x, j, pos1))
+          {
+            Cerr << "Fatal error in octree : integer position outside octree" << finl;
+            Process::exit();
+          }
+        elements_boxes(i, j) = pos1;
+        if (have_epsilon)
+          {
+            pos1 = 0;
+            double xbis = x0 + epsilon;
+            if (!integer_position(xbis, j, pos1))
+              {
+                Cerr << "Fatal error in octree : integer position outside octree" << finl;
+                Process::exit();
+              }
+            elements_boxes(i, dim+j) = pos1;
+          }
+      }
+  octree_int_.build(dim, elements_boxes);
+}
+
+/*! @brief cherche tous les elements ou points ayant potentiellement une intersection non vide avec la boite donnee.
+ *
+ */
+template <typename _SIZE_>
+typename Octree_Double_32_64<_SIZE_>::int_t Octree_Double_32_64<_SIZE_>::search_elements_box(double xmin, double ymin, double zmin,
+                                                                                             double xmax, double ymax, double zmax,
+                                                                                             ArrOfInt_t& elements) const
+{
+  const int dim = dim_;
+  if (dim == 0)
+    {
+      elements.resize_array(0);
+      return 0;
+    }
+  int x0 = 0, x1 = 0, y0 = 0, y1 = 0, z0 = 0, z1 = 0;
+  int ok = integer_position_clip(xmin, xmax, x0, x1, 0);
+  if ((ok) && (dim >= 1))
+    {
+      ok = integer_position_clip(ymin, ymax, y0, y1, 1);
+      if ((ok) && (dim >= 2))
+        ok = integer_position_clip(zmin, zmax, z0, z1, 2);
+    }
+  if (ok)
+    octree_int_.search_elements_box(x0, y0, z0, x1, y1, z1, elements);
+  else
+    elements.resize_array(0);
+  return elements.size_array();
+}
+
+/*! @brief cherche tous les elements ou points ayant potentiellement une intersection non vide avec la boite donnee (centre + ou - radius dans chaque direction)
+ *
+ */
+template <typename _SIZE_>
+typename Octree_Double_32_64<_SIZE_>::int_t
+Octree_Double_32_64<_SIZE_>::search_elements_box(const ArrOfDouble& center, const double radius,
+                                                 ArrOfInt_t& elements) const
+{
+  int dim = center.size_array();
+  double x = center[0];
+  double y = (dim>=2) ? center[1] : 0.;
+  double z = (dim>2) ? center[2] : 0.;
+  int_t i = search_elements_box(x-radius, y-radius, z-radius,
+                                x+radius, y+radius, z+radius,
+                                elements);
+  return i;
+}
+
+/*! @brief Methode hors classe Cherche parmi les sommets de la liste node_list ceux qui sont a une
+ *
+ *   distance inferieure a epsilon du point (x,y,z). node_list contient des indices de
+ *   sommets dans le tableau coords. La liste des noeuds verifiant le critere est mise
+ *   dans node_list. On renvoie l'indice dans le tableau coords du sommet le plus proche.
+ *
+ */
+template <typename _SIZE_>
+typename Octree_Double_32_64<_SIZE_>::int_t  Octree_Double_32_64<_SIZE_>::search_nodes_close_to(double x, double y, double z,
+                                                                                                const DoubleTab_t& coords, ArrOfInt_t& node_list,
+                                                                                                double epsilon)
+{
+  const int_t n = node_list.size_array();
+  double eps2 = epsilon * epsilon;
+  int_t count = 0;
+  const int dim = coords.dimension_int(1);
+  double dmin = eps2;
+  int_t nearest = -1;
+  for (int_t i = 0; i < n; i++)
+    {
+      const int_t som = node_list[i];
+      double dx = x - coords(som, 0);
+      double dy = (dim >= 2) ? y - coords(som, 1) : 0.;
+      double dz = (dim >= 3) ? z - coords(som, 2) : 0.;
+      double d2 = dx * dx + dy * dy + dz * dz;
+      if (d2 < eps2)
+        {
+          node_list[count] = som;
+          if (d2 < dmin)
+            {
+              dmin = d2;
+              nearest = som;
+            }
+          count++;
+        }
+    }
+  node_list.resize_array(count);
+  return nearest;
+}
+
+/*! @brief Idem que search_nodes_close_to(double x, double y, double z, .
+ *
+ * ..)
+ *
+ */
+template <typename _SIZE_>
+typename Octree_Double_32_64<_SIZE_>::int_t  Octree_Double_32_64<_SIZE_>::search_nodes_close_to(const ArrOfDouble& point,
+                                                                                                const DoubleTab_t& coords, ArrOfInt_t& node_list,
+                                                                                                double epsilon)
+{
+  int dim = point.size_array();
+  double x = point[0];
+  double y = (dim>=2) ? point[1] : 0.;
+  double z = (dim>2) ? point[2] : 0.;
+  int_t i = search_nodes_close_to(x, y, z, coords, node_list, epsilon);
+  return i;
+}
+
+template class Octree_Double_32_64<int>;
+#if INT_is_64_ == 2
+template class Octree_Double_32_64<trustIdType>;
+#endif
+
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Octree_Double.h b/Utilities/VisItBridge/databases/readers/Lata/Octree_Double.h
new file mode 100644
index 00000000..78abd172
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Octree_Double.h
@@ -0,0 +1,133 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Octree_Double_included
+#define Octree_Double_included
+
+#include <Octree_Int.h>
+#include <TRUSTTab.h>
+
+/*! @brief : Un octree permettant de chercher dans l'espace des elements ou des points decrits par des coordonnees reeles.
+ *
+ * Cet objet est base sur Octree_Int.
+ *   Astuces:
+ *    Pour chercher des points a epsilon pres on peut faire:
+ *     1)  build_nodes(coord, include_virt, 0.)
+ *       suivi de
+ *         search_elements_box(center, epsilon, elements);
+ *
+ *     2)  build_nodes(coord, include_virt, epsilon)
+ *       suivi de
+ *         search_elements(x,y,z,...)
+ *     La premiere solution prend plus de temps pour construire l'octree mais la recherche est plus rapide
+ *     La deuxieme, c'est inverse... et on peut choisir epsilon pour chaque point.
+ *
+ */
+template <typename _SIZE_>
+class Octree_Double_32_64
+{
+public:
+  using int_t = _SIZE_;
+  using ArrOfInt_t = ArrOfInt_T<_SIZE_>;
+  using IntTab_t = IntTab_T<_SIZE_>;
+  using ArrOfDouble_t = ArrOfDouble_T<_SIZE_>;
+  using DoubleTab_t = DoubleTab_T<_SIZE_>;
+
+  void reset();
+
+  template<class _TAB_TYPE_>
+  void build_elements(const _TAB_TYPE_& coords, const IntTab_t& elements, const double epsilon, const bool include_virtual);
+
+  void build_nodes(const DoubleTab_t& coords, const bool include_virtual, const double epsilon = 0.);
+  int_t search_elements(double x, double y, double z, int_t& index) const;
+  int_t search_elements_box(double xmin, double ymin, double zmin, double xmax, double ymax, double zmax, ArrOfInt_t& elements) const;
+  static int_t search_nodes_close_to(double x, double y, double z, const DoubleTab_t& coords, ArrOfInt_t& node_list, double epsilon);
+  int_t search_elements_box(const ArrOfDouble& center, const double radius, ArrOfInt_t& elements) const;
+  static int_t search_nodes_close_to(const ArrOfDouble& point, const DoubleTab_t& coords, ArrOfInt_t& node_list, double epsilon);
+  int dimension() const
+  {
+    assert(dim_ > 0);
+    return dim_;
+  }
+  inline const ArrOfInt_t& floor_elements() const  { return octree_int_.floor_elements(); }
+
+protected:
+  inline bool integer_position(double x, int direction, int& ix) const;
+  inline bool integer_position_clip(double xmin, double xmax, int& x0, int& x1, int direction) const;
+
+  template<class _TAB_TYPE_>
+  void compute_origin_factors(const _TAB_TYPE_& coords, const double epsilon, const int include_virtual);
+
+  Octree_Int_32_64<_SIZE_> octree_int_;
+  // Ces deux tableaux sont toujours de taille 3 par commodite
+  ArrOfDouble origin_, factor_;
+  int dim_ = 0;
+};
+
+//////////////////// INLINE METHODS /////////////////////////////
+
+/*! @brief Convertit une coordonnee reelle en coordonnee entiere pour l'octree_int
+ *
+ * Valeur de retour: 1 si ok, 0 si coordonnee hors de l'octree
+ */
+template <typename _SIZE_>
+inline bool Octree_Double_32_64<_SIZE_>::integer_position(double x, int direction, int& ix) const
+{
+  const double coord_max = (double) Octree_Int_32_64<_SIZE_>::coord_max_;
+  double rnd_x = (x - origin_[direction]) * factor_[direction];
+  // 0.49 permet d'accepter une coordonnee x egale a xmin ou xmax de l'octree,
+  //  sinon pour un octree cree a partir de sommets, il y a un risque
+  //  de ne pas trouver les coordonnees des points qu'on avait mis au bord de l'octree.
+  if (rnd_x >= -0.49 && rnd_x <= coord_max + 0.49)
+    {
+      ix = (int) floor(rnd_x + 0.5);
+      return true;
+    }
+  return false;
+}
+
+// Valeur de retour: 1 s'il y a une intersection non vide avec l'octree, 0 sinon
+template <typename _SIZE_>
+inline bool Octree_Double_32_64<_SIZE_>::integer_position_clip(double xmin, double xmax,
+                                                               int& x0, int& x1,
+                                                               int direction) const
+{
+  const double coord_max = (double) Octree_Int_32_64<_SIZE_>::coord_max_;
+  xmin = (xmin - origin_[direction]) * factor_[direction];
+  xmax = (xmax - origin_[direction]) * factor_[direction];
+  // pas de marge ici comme on cherche avec une boite, l'epsilon est deja
+  // dans la dimension de la boite.
+  if (xmin > coord_max || xmax < 0.)
+    return false;
+  if (xmin < .0)
+    x0 = 0;
+  else
+    x0 = (int) (floor(xmin+0.5));
+  if (xmax > coord_max)
+    x1 = Octree_Int_32_64<_SIZE_>::coord_max_;
+  else
+    x1 = (int) (floor(xmax+0.5));
+  return true;
+}
+
+
+//////////////////// TEMPLATE METHOD IMPL ////////////////////////
+
+#include <Octree_Double.tpp>
+
+using Octree_Double = Octree_Double_32_64<int>;
+using Octree_Double_64 = Octree_Double_32_64<trustIdType>;
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Octree_Double.tpp b/Utilities/VisItBridge/databases/readers/Lata/Octree_Double.tpp
new file mode 100644
index 00000000..ba592c70
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Octree_Double.tpp
@@ -0,0 +1,116 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Octree_Double_TPP_included
+#define Octree_Double_TPP_included
+
+/*! @brief Construit un octree a partir d'elements volumiques decrits par des ensembles de sommets.
+ *
+ * On stocke dans l'octree les parallelipipdes englobant chaque
+ *   element (contenant tous les sommets de l'element) plus une marge de epsilon.
+ *   Si include_virtual=1, on stocke elements.dimension_tot(0) elements, sinon on en
+ *   stocke elements.dimension(0)
+ *
+ * Template car on a besoin de la version float pour lata tools.
+ *
+ */
+template<typename _SIZE_>
+template<class _TAB_TYPE_>
+void Octree_Double_32_64<_SIZE_>::build_elements(const _TAB_TYPE_& coords, const IntTab_t& elements,
+                                                 const double epsilon, const bool include_virtual)
+{
+  octree_int_.reset();
+  compute_origin_factors(coords, epsilon, include_virtual);
+
+  const int_t nb_elems = include_virtual ? elements.dimension_tot(0) : elements.dimension(0);
+  const int nb_som_elem = elements.dimension_int(1);
+  const int dim = coords.dimension_int(1);
+  IntTab_t elements_boxes;
+  elements_boxes.resize(nb_elems, dim * 2, RESIZE_OPTIONS::NOCOPY_NOINIT);
+  for (int_t i = 0; i < nb_elems; i++)
+    {
+      for (int j = 0; j < dim; j++)
+        {
+          double xmin = 1.e37;
+          double xmax = -1.e37;
+          for (int k = 0; k < nb_som_elem; k++)
+            {
+              const int_t som = elements(i, k);
+              if (som < 0) continue; // for polyhedrons, som might be -1 (padding)
+              const double x = coords(som, j);
+              xmin = (x<xmin) ? x : xmin;
+              xmax = (x>xmax) ? x : xmax;
+            }
+          int pos1 = 0, pos2 = 0;
+          if (!integer_position(xmin, j, pos1) || !integer_position(xmax, j, pos2))
+            {
+              Cerr << "Fatal error in octree : integer position outside octree" << finl;
+              Process::exit();
+            }
+          elements_boxes(i, j) = pos1;
+          elements_boxes(i, j+dim) = pos2;
+        }
+    }
+  octree_int_.build(dim, elements_boxes);
+}
+
+/*! @brief methode outil pour build_nodes et build_elements (calcul des facteurs de conversion entre reels et entiers pour Octree_Int
+ *
+ *   epsilon est ajoute aux coordonnees min et max pour la bounding box de l'octree.
+ *
+ * Template car on a besoin de la version float pour lata tools.
+ */
+template<typename _SIZE_>
+template<class _TAB_TYPE_>
+void Octree_Double_32_64<_SIZE_>::compute_origin_factors(const _TAB_TYPE_& coords,
+                                                         const double epsilon,
+                                                         const int include_virtual)
+{
+  // Recherche des coordonnees min et max du domaine
+  const int_t nb_som = include_virtual ? coords.dimension_tot(0) : coords.dimension(0);
+  if (nb_som == 0) return; // octree vide
+
+  dim_ = coords.dimension_int(1);
+  origin_.resize_array(3);
+  factor_.resize_array(3);
+  ArrOfDouble_t xmin(dim_);
+  xmin = 1.e37;
+  ArrOfDouble_t xmax(dim_);
+  xmax = -1.e-37;
+  assert(dim_ >= 1 && dim_ <= 3);
+  for (int_t i = 0; i < nb_som; i++)
+    for (int j = 0; j < dim_; j++)
+      {
+        const double x = coords(i, j);
+        if (x < xmin[j])
+          xmin[j] = x;
+        if (x > xmax[j])
+          xmax[j] = x;
+      }
+
+  const double coord_max = (double) Octree_Int_32_64<_SIZE_>::coord_max_;
+  for (int j = 0; j < dim_; j++)
+    {
+      xmin[j] -= epsilon;
+      xmax[j] += epsilon;
+      origin_[j] = xmin[j];
+      if (xmax[j] - xmin[j] > 0.)
+        factor_[j] = coord_max / (xmax[j] - xmin[j]);
+      else
+        factor_[j] = 0.;
+    }
+}
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Octree_Int.cpp b/Utilities/VisItBridge/databases/readers/Lata/Octree_Int.cpp
new file mode 100644
index 00000000..a199ba20
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Octree_Int.cpp
@@ -0,0 +1,503 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+#include <Octree_Int.h>
+
+static constexpr int max_levels_ = 32; // 1 de plus que le nombre de bits=1 dans coords_max
+// La valeur suivante doit etre une puissance de deux
+template<> const int Octree_Int_32_64<int>::root_octree_half_width_ = 1073741824; /* 2^30   = 0100 0000  0000 0000  0000 0000  0000 0000b */
+// La valeur suivante doit etre egale a (root_octree_half_width_ * 2 - 1)
+template<> const int Octree_Int_32_64<int>::coord_max_ = 2147483647;              /* 2^31-1 = 0111 1111  1111 1111  1111 1111  1111 1111b */
+
+
+#if INT_is_64_ == 2
+template<> const int Octree_Int_32_64<trustIdType>::root_octree_half_width_ = 1073741824;
+template<> const int Octree_Int_32_64<trustIdType>::coord_max_ = 2147483647;
+#endif
+
+/*! @brief construction d'un octree_id (voir octree_structure_)
+ *
+ *   Si type==EMPTY, l'octree_id est 0
+ *   Si type==OCTREE, on suppose que index est un indice dans octree_structure_
+ *   Si type==FLOOR, on suppose que index est un indice dans floor_elements_
+ */
+template <typename _SIZE_>
+inline typename Octree_Int_32_64<_SIZE_>::int_t Octree_Int_32_64<_SIZE_>::octree_id(int_t index, Octree_Type type)
+{
+  switch(type)
+    {
+    case EMPTY:
+      return 0;
+    case OCTREE:
+      return index + 1;
+    case FLOOR:
+      return - index - 1;
+    }
+  return -1;
+}
+
+/*! @brief calcul de l'index de l'octree dans octree_structure ou floor_elements en fonction du type de l'octree et de son octree_id.
+ *
+ *   En general on a deja determine le type avant, on le passe en parametre pour optimiser.
+ *
+ */
+template <typename _SIZE_>
+inline typename Octree_Int_32_64<_SIZE_>::int_t Octree_Int_32_64<_SIZE_>::octree_index(int_t octree_id, Octree_Type type)
+{
+  assert(type==octree_type(octree_id));
+  switch(type)
+    {
+    case EMPTY:
+      return -1;
+    case OCTREE:
+      return octree_id - 1;
+    case FLOOR:
+      return - octree_id - 1;
+    }
+  return -1;
+}
+
+/*! @brief Renvoie le type d'un octree en fonction de son octree_id.
+ *
+ */
+template <typename _SIZE_>
+inline typename Octree_Int_32_64<_SIZE_>::Octree_Type Octree_Int_32_64<_SIZE_>::octree_type(int_t octree_id)
+{
+  if (octree_id > 0)
+    return OCTREE;
+  else if (octree_id == 0)
+    return EMPTY;
+  else
+    return FLOOR;
+}
+
+/*! @brief construction de l'octree.
+ *
+ * On donne la dimension (1, 2 ou 3) et un tableau d'elements a stocker dans l'octree. Deux possibilites:
+ *   1) les elements sont ponctuels si elements_boxes.dimension(1) == dimension.
+ *      Dans ce cas, chaque element se trouve dans un et un seul octree_floor
+ *   2) les elements sont des parallelipipedes, si elements_boxes.dimension(1) == dimension*2
+ *      Les "dimension" premieres colonnes sont les coordonnees inferieures,
+ *      les "dimension" suivantes sont les coordonnees superieures.
+ *      Un parallelipipede peut etre affecte a plusieurs octree_floor.
+ *   Les coordonnees stockees dans elements_boxes peuvent aller de 0 a coord_max_ inclus.
+ *   Il vaut mieux utiliser toute la plage des entiers en multipliant par un facteur adequat.
+ *
+ */
+template <typename _SIZE_>
+void Octree_Int_32_64<_SIZE_>::build(const int dimension, const IntTab_t& elements_boxes)
+{
+  assert(dimension >= 1 && dimension <= 3);
+  assert(elements_boxes.dimension(1) == dimension
+         || elements_boxes.dimension(1) == dimension * 2 );
+
+  const int_t nb_elems = elements_boxes.dimension(0);
+  nb_elements_ = nb_elems;
+
+  floor_elements_.resize_array(0);
+  const int nb_octrees = 1 << dimension;  // = 2^dim
+  octree_structure_.resize(0, nb_octrees);
+
+  assert(elements_boxes.size_array() == 0
+         || (min_array(elements_boxes) >= 0 && max_array(elements_boxes) <= coord_max_));
+
+  AOFlagS_ tmp_elem_flags(max_levels_);
+  ArrsOfInt_t tmp_elem_list(max_levels_);
+  ArrOfInt_t& elements_list = tmp_elem_list[0];
+  elements_list.resize_array(nb_elems, RESIZE_OPTIONS::NOCOPY_NOINIT);
+  for (int_t i = 0; i < nb_elems; i++)
+    elements_list[i] = i;
+
+  root_octree_id_ = build_octree_recursively(root_octree_half_width_,root_octree_half_width_,root_octree_half_width_,
+                                             root_octree_half_width_,
+                                             elements_boxes,
+                                             tmp_elem_list,
+                                             0,
+                                             tmp_elem_flags);
+}
+
+/*! @brief renvoie la liste des elements contenant potentiellement le point (x,y,z) On renvoie n=nombre d'elements de la liste et les elements sont dans
+ *
+ *   floor_elements()[index+i] pour 0 <= i < n.
+ *   En realite on renvoie tous les elements qui ont une intersection non vide avec l'octree_floor
+ *   contenant le point (x,y,z)
+ *
+ */
+template <typename _SIZE_>
+typename Octree_Int_32_64<_SIZE_>::int_t Octree_Int_32_64<_SIZE_>::search_elements(int x, int y, int z, int_t& index) const
+{
+  const int nb_octrees = octree_structure_.dimension_int(1);
+  if (nb_octrees == 2)
+    y = 0; // important pour ne pas tomber sur des cubes inexistants
+  if (nb_octrees <= 4)
+    z = 0; // idem
+  assert(x >= 0 && x <= coord_max_);
+  assert(y >= 0 && y <= coord_max_);
+  assert(z >= 0 && z <= coord_max_);
+
+  const int_t my_octree_id = search_octree_floor(x, y, z);
+
+  if (octree_type(my_octree_id) == EMPTY)
+    return 0;
+
+  const int_t idx = octree_index(my_octree_id, FLOOR);
+  const int_t n = floor_elements_[idx];
+  index = idx + 1;
+  return n;
+}
+
+template <typename _SIZE_>
+struct IntBoxData
+{
+  using ArrOfInt_t = ArrOfInt_T<_SIZE_>;
+  using AOBit_ = ArrOfBit_32_64<_SIZE_>;
+
+  IntBoxData(int xmin, int ymin, int zmin,
+             int xmax, int ymax, int zmax,
+             ArrOfInt_t& elements,
+             AOBit_ *markers) :
+    xmin_(xmin), ymin_(ymin), zmin_(zmin),
+    xmax_(xmax), ymax_(ymax), zmax_(zmax),
+    elements_(elements),
+    markers_(markers) { };
+  int xmin_, ymin_, zmin_;
+  int xmax_, ymax_, zmax_;
+  ArrOfInt_t& elements_;
+  AOBit_ *markers_;
+};
+
+/*! @brief cherche les elements ayant potentiellement une intersection non vide
+ * avec la boite xmin..zmax.
+ *   Les elements peuvent apparaitre plusieurs fois dans le tableau "elements"
+ */
+template <typename _SIZE_>
+typename Octree_Int_32_64<_SIZE_>::int_t Octree_Int_32_64<_SIZE_>::search_elements_box(int xmin, int ymin, int zmin,
+                                                                                       int xmax, int ymax, int zmax,
+                                                                                       ArrOfInt_t& elements) const
+{
+  const int nb_octrees = octree_structure_.dimension_int(1);
+  if (nb_octrees == 2)
+    ymin = ymax = 0; // important pour ne pas tomber sur des cubes inexistants
+  if (nb_octrees <= 4)
+    zmin = zmax = 0; // idem
+  assert(xmin >= 0 && xmin <= coord_max_);
+  assert(ymin >= 0 && ymin <= coord_max_);
+  assert(zmin >= 0 && zmin <= coord_max_);
+  assert(xmax >= 0 && xmax <= coord_max_);
+  assert(ymax >= 0 && ymax <= coord_max_);
+  assert(zmax >= 0 && zmax <= coord_max_);
+
+  elements.resize_array(0);
+  IntBoxData<_SIZE_> boxdata(xmin, ymin, zmin, xmax, ymax, zmax, elements, 0);
+  switch(octree_type(root_octree_id_))
+    {
+    case FLOOR:
+      search_elements_box_floor(boxdata, root_octree_id_);
+      break;
+    case OCTREE:
+      search_elements_box_recursively(boxdata, root_octree_id_,
+                                      root_octree_half_width_,root_octree_half_width_,root_octree_half_width_,
+                                      root_octree_half_width_);
+      break;
+    case EMPTY:
+      break;
+    }
+  const int_t n = elements.size_array();
+  return n;
+}
+
+/*! @brief ajoute des elements de l'octree_floor a boxdata.
+ *
+ * elements_
+ *
+ */
+template <typename _SIZE_>
+void Octree_Int_32_64<_SIZE_>::search_elements_box_floor(IntBoxData<_SIZE_>& boxdata,
+                                                         int_t octree_floor_id) const
+{
+  const int_t idx = octree_index(octree_floor_id, FLOOR);
+  const int_t n = floor_elements_[idx];
+  if (boxdata.markers_)
+    for (int_t i = 0; i < n; i++)
+      {
+        const int_t elem = floor_elements_[idx+1+i];
+        if (!boxdata.markers_->testsetbit(elem))
+          boxdata.elements_.append_array(elem);
+      }
+  else
+    for (int_t i = 0; i < n; i++)
+      {
+        const int_t elem = floor_elements_[idx+1+i];
+        boxdata.elements_.append_array(elem);
+      }
+}
+
+// Pour chaque direction, drapeaux des cubes de la rangee inferieure
+static int sub_cube_flags_min[3] = { 1+4+16+64, /* drapeaux des cubes 0,2,4,6 */
+                                     1+2+16+32, /* drapeaux des cubes 0,1,4,5 */
+                                     1+2+4+8    /* drapeaux des cubes 0,1,2,3 */
+                                   };
+static int sub_cube_flags_max[3] = { 2+8+32+128, /* drapeaux des cubes 1,3,5,7 */
+                                     4+8+64+128, /* drapeaux des cubes 2,3,7,8 */
+                                     16+32+64+128 /* drapeaux des cubes 4,5,6,7 */
+                                   };
+
+/*! @brief cherche recursivement les elements inclus dans la boite boxdata pour l'octree_id donne, de centre cx, cy, cz.
+ *
+ */
+template <typename _SIZE_>
+void Octree_Int_32_64<_SIZE_>::search_elements_box_recursively(IntBoxData<_SIZE_>& boxdata,
+                                                               int_t the_octree_id,
+                                                               int cx, int cy, int cz,
+                                                               int half_width) const
+{
+  int flags = 255;
+  if (cx > boxdata.xmax_) // les cubes superieurs en x ne sont pas dedans
+    flags &= sub_cube_flags_min[0];
+  if (cx <= boxdata.xmin_) // les cubes inferieurs ne sont pas dedans
+    flags &= sub_cube_flags_max[0];
+  if (cy > boxdata.ymax_)
+    flags &= sub_cube_flags_min[1];
+  if (cy <= boxdata.ymin_)
+    flags &= sub_cube_flags_max[1];
+  if (cz > boxdata.zmax_)
+    flags &= sub_cube_flags_min[2];
+  if (cz <= boxdata.zmin_)
+    flags &= sub_cube_flags_max[2];
+  int test_flag = 1;
+  const int_t idx = octree_index(the_octree_id, OCTREE);
+  const int half_width_2 = half_width >> 1;
+  const int mhalf_width = - half_width_2;
+  int cx2, cy2, cz2;
+  for (int i = 0; i < 8; i++, test_flag <<= 1)
+    {
+      if ((flags & test_flag) != 0)
+        {
+          const int_t id = octree_structure_(idx, i);
+          switch(octree_type(id))
+            {
+            case FLOOR:
+              search_elements_box_floor(boxdata, id);
+              break;
+            case OCTREE:
+              cx2 = cx + ((i & 1) ? half_width_2 : mhalf_width);
+              cy2 = cy + ((i & 2) ? half_width_2 : mhalf_width);
+              cz2 = cz + ((i & 4) ? half_width_2 : mhalf_width);
+              search_elements_box_recursively(boxdata, id,
+                                              cx2, cy2, cz2,
+                                              half_width_2);
+              break;
+            case EMPTY:
+              break;
+            }
+        }
+    }
+}
+
+template <typename _SIZE_>
+void Octree_Int_32_64<_SIZE_>::reset()
+{
+  root_octree_id_ = octree_id(0, EMPTY);
+  nb_elements_ = 0;
+  octree_structure_.reset();
+  floor_elements_.reset();
+}
+
+/*! @brief construit un octree_floor avec la liste d'elements donnee et renvoie l'octree_id de cet octree_floor
+ *
+ */
+template <typename _SIZE_>
+typename Octree_Int_32_64<_SIZE_>::int_t Octree_Int_32_64<_SIZE_>::build_octree_floor(const ArrOfInt_t& elements_list)
+{
+  const int_t nb_elems = elements_list.size_array();
+  const int_t index = floor_elements_.size_array();
+  floor_elements_.resize_array(index + nb_elems + 1, RESIZE_OPTIONS::COPY_NOINIT);
+  floor_elements_[index] = nb_elems;
+  for (int_t i = 0; i < nb_elems; i++)
+    floor_elements_[index + 1 + i] = elements_list[i];
+  return octree_id(index, FLOOR);
+}
+
+/*! @brief octree_center_i est le premier int de la moitie superieure de l'octree dans la direction i.
+ *
+ * octree_half_width est une puissance de 2 egale a octree_center_i-octree_min_i (octree_min_i
+ *    est le premier int inclu dans cet octree dans la direction i)
+ *  Valeur de retour: octree_id de l'octree construit (void octree_structure_)
+ *
+ */
+template <typename _SIZE_>
+typename Octree_Int_32_64<_SIZE_>::int_t Octree_Int_32_64<_SIZE_>::build_octree_recursively(const int octree_center_x,
+                                                                                            const int octree_center_y,
+                                                                                            const int octree_center_z,
+                                                                                            const int octree_half_width,
+                                                                                            const IntTab_t& elements_boxes,
+                                                                                            ArrsOfInt_t& vect_elements_list,
+                                                                                            const int level,
+                                                                                            AOFlagS_& tmp_elem_flags)
+{
+  // Criteres d'arret de la subdivision:
+  // Nombre maximal d'elements dans un sous-cube floor
+  constexpr int OCTREE_FLOOR_MAX_ELEMS = 8;
+  // S'il y a beaucoup d'elements dupliques, mais pas trop, et que le nombre d'elements
+  //  dans l'octree est superieur a cette valeur, on subdivise quand-meme
+  constexpr int OCTREE_DUPLICATE_ELEMENTS_LIMIT = 64;
+  const ArrOfInt_t& elements_list = vect_elements_list[level];
+  // Si le nombre d'elements est inferieur a la limite, on cree un floor_element,
+  // sinon on subdivise
+  const int_t nb_elems = elements_list.size_array();
+  if (nb_elems == 0)
+    return octree_id(0, EMPTY);
+
+  if (nb_elems < OCTREE_FLOOR_MAX_ELEMS || octree_half_width == 1 /* dernier niveau */)
+    {
+      const int_t the_octree_id = build_octree_floor(elements_list);
+      return the_octree_id;
+    }
+
+  AOFlag_& elem_flags = tmp_elem_flags[level];
+  elem_flags.resize_array(nb_elems, RESIZE_OPTIONS::NOCOPY_NOINIT);
+
+  const int nb_octrees = octree_structure_.dimension_int(1);
+  assert(nb_octrees == 2 || nb_octrees == 4 || nb_octrees == 8);
+  const int elem_box_dim = elements_boxes.dimension_int(1);
+  // Soit elements_boxes contient dimension colonnes, soit dimension*2
+  const int box_delta = (elem_box_dim > 3) ? (elem_box_dim >> 1) : 0;
+  // Nombre d'elements stockes en double dans l'octree (a cause des elements a cheval
+  //  sur plusieurs sous-octrees)
+  int_t nb_duplicate_elements = 0;
+  // On range les elements de la liste dans 8 sous-cubes (remplissage de elem_flags)
+  for (int_t i_elem = 0; i_elem < nb_elems; i_elem++)
+    {
+      const int_t elem = elements_list[i_elem];
+      // dir_flag vaut 1 pour la direction x, 2 pour y et 4 pour z
+      int dir_flag = 1;
+      // sub_cube_flags contient 2^dim drapeaux binaires (1 par sous-cube),
+      // et indique les sous-cubes coupes par l'element
+      int octree_flags = 255;
+      // dans combien de sous-octree cet element est-il stocke ?
+      int_t nb_duplicates = 1;
+
+      for (int direction = 0; direction < 3; direction++)
+        {
+          const int_t elem_min = elements_boxes(elem, direction);
+          const int_t elem_max = elements_boxes(elem, box_delta+direction);
+          assert(elem_max >= elem_min);
+          // coordonnee du centre du cube dans la direction j:
+          const int center = (direction==0) ? octree_center_x : ((direction==1) ? octree_center_y : octree_center_z);
+          // L'element coupe-t-il la partie inferieure et la partie superieure du cube dans la "direction" ?
+          if (elem_min >= center) // non -> on retire les flags des cubes de la partie inferieure
+            octree_flags &= sub_cube_flags_max[direction];
+          else if (elem_max < center) // non -> on retire les flags des cubes de la partie superieure
+            octree_flags &= sub_cube_flags_min[direction];
+          else
+            nb_duplicates <<= 1; // l'element coupe les deux parties !
+          dir_flag = dir_flag << 1;
+          if (dir_flag == nb_octrees)
+            break;
+        }
+      elem_flags[i_elem] = octree_flags;
+      nb_duplicate_elements += nb_duplicates - 1;
+    }
+
+  // Critere un peu complique : s'il y a vraiment beaucoup d'elements
+  //  dans cet octree, on autorise jusqu'a dupliquer tous les elements,
+  //  ce qui permet de ranger des elements tres alonges qui sont forcement
+  //  dupliques dans une direction (>OCTREE_DUPLICATE_ELEMENTS_LIMIT).
+  if ((nb_duplicate_elements * 2 >= nb_elems && nb_elems < OCTREE_DUPLICATE_ELEMENTS_LIMIT)
+      || nb_duplicate_elements > nb_elems)
+    {
+      const int_t the_octree_id = build_octree_floor(elements_list);
+      // On renvoie un index d'octreefloor
+      return the_octree_id;
+    }
+
+  // On reserve une case a la fin de octree_structure pour stocker cet octree:
+  const int_t index_octree = octree_structure_.dimension(0);
+  octree_structure_.resize_dim0(index_octree + 1, RESIZE_OPTIONS::COPY_NOINIT);
+  ArrOfInt_t& new_liste_elems = vect_elements_list[level+1];
+  new_liste_elems.resize_array(0);
+  const int width = octree_half_width >> 1;
+  const int m_width = - width;
+  // Traitement recursif des sous-cubes de l'octree:
+  for (int i_cube = 0; i_cube < nb_octrees; i_cube++)
+    {
+      const int octree_flag = 1 << i_cube;
+      new_liste_elems.resize_array(nb_elems, RESIZE_OPTIONS::NOCOPY_NOINIT);
+      int_t count = 0;
+      // Liste des elements inclus dans le sous-cube:
+      for (int_t i_elem = 0; i_elem < nb_elems; i_elem++)
+        if ((elem_flags[i_elem] & octree_flag) != 0)
+          new_liste_elems[count++] = elements_list[i_elem];
+      new_liste_elems.resize_array(count);
+
+      int_t sub_octree_id;
+      if (new_liste_elems.size_array() == 0)
+        sub_octree_id = octree_id(-1, EMPTY);
+      else
+        {
+          // Coordonnees du nouveau sous-cube
+          const int cx = octree_center_x + ((i_cube&1) ? width : m_width);
+          const int cy = octree_center_y + ((i_cube&2) ? width : m_width);
+          const int cz = octree_center_z + ((i_cube&4) ? width : m_width);
+          sub_octree_id = build_octree_recursively(cx, cy, cz, width,
+                                                   elements_boxes,
+                                                   vect_elements_list,
+                                                   level+1,
+                                                   tmp_elem_flags);
+        }
+      octree_structure_(index_octree, i_cube) = sub_octree_id;
+    }
+
+  return octree_id(index_octree, OCTREE);
+}
+
+/*! @brief renvoie l'octree_id de l'octree_floor contenant le sommet (x,y,z) (peut renvoyer l'octree EMPTY)
+ *
+ */
+template <typename _SIZE_>
+typename Octree_Int_32_64<_SIZE_>::int_t Octree_Int_32_64<_SIZE_>::search_octree_floor(int x, int y, int z) const
+{
+  if (octree_type(root_octree_id_) != OCTREE)
+    return root_octree_id_;
+  // Le test pour savoir si on est dans la partie superieure ou inferieure d'un octree au niveau i consiste simplement a tester
+  // le i-ieme bit de la position.
+  int flag = root_octree_half_width_;
+
+  int_t index = octree_index(root_octree_id_, OCTREE);
+
+  // Descendre dans la hierarchie d'octree subdivises jusqu'au cube le plus petit
+  while (1)
+    {
+      // Numero du sous-cube dans lequel se trouve le sommet x,y,z
+      const int ix = (x & flag) ? 1 : 0;
+      const int iy = (y & flag) ? 2 : 0;
+      const int iz = (z & flag) ? 4 : 0;
+      int i_sous_cube = ix + iy + iz;
+      // On entre dans le sous-cube :
+      const int_t the_octree_id = octree_structure_(index, i_sous_cube);
+      if (octree_type(the_octree_id) != OCTREE) // floor or empty
+        return the_octree_id;
+
+      index = octree_index(the_octree_id, OCTREE);
+      flag >>= 1;
+    }
+  //return -1; // On n'arrive jamais ici !
+}
+
+
+
+template class Octree_Int_32_64<int>;
+#if INT_is_64_ == 2
+template class Octree_Int_32_64<trustIdType>;
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Octree_Int.h b/Utilities/VisItBridge/databases/readers/Lata/Octree_Int.h
new file mode 100644
index 00000000..7c5c55f8
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Octree_Int.h
@@ -0,0 +1,91 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+#ifndef Octree_Int_included
+#define Octree_Int_included
+
+#include <TRUSTArrays.h>
+#include <TRUSTTab.h>
+#include <ArrOfBit.h>
+
+template <typename _SIZE_> struct IntBoxData;
+
+/*! @brief : Un octree permettant de retrouver des objets ponctuels ou parallelipipediques dans un espace 1D, 2D ou 3D et des coordonnees entieres
+ */
+template <typename _SIZE_>
+class Octree_Int_32_64
+{
+public:
+  using int_t = _SIZE_;
+  using ArrOfInt_t = ArrOfInt_T<_SIZE_>;
+  using IntTab_t = IntTab_T<_SIZE_>;
+  using ArrOfDouble_t= ArrOfDouble_T<_SIZE_>;
+  using DoubleTab_t = DoubleTab_T<_SIZE_>;
+  using ArrsOfInt_t = ArrsOfInt_T<_SIZE_>;
+  using AOFlag_ = TRUSTArray<int, _SIZE_>;
+  using AOFlagS_ = TRUST_Vector<AOFlag_>;  // A vector of arrays of small values (flags here)
+
+
+  void build(const int dimension, const IntTab_t& elements_boxes);
+  int_t search_elements(int x, int y, int z, int_t& floor_elements_index) const;
+  int_t search_elements_box(int xmin, int ymin, int zmin, int xmax, int ymax, int zmax, ArrOfInt_t& elements) const;
+  void reset();
+
+  inline const ArrOfInt_t& floor_elements() const { return floor_elements_; }
+
+  // Le plus grand int autorise pour les coordonnees (du type 2^n - 1)
+  static const int coord_max_;
+  // Premier int de la moitie superieure de l'octree root (si coord_max_=2^n-1, half_width_=2^(n-1))
+  static const int root_octree_half_width_;
+
+protected:
+  int_t build_octree_recursively(const int octree_center_x, const int octree_center_y, const int octree_center_z,
+                                 const int octree_half_width,
+                                 const IntTab_t& elements_boxes,
+                                 ArrsOfInt_t& vect_elements_list,
+                                 const int level,
+                                 AOFlagS_& tmp_elem_flags);
+  int_t build_octree_floor(const ArrOfInt_t& elements_list);
+  int_t search_octree_floor(int x_pos, int y_pos, int z_pos) const;
+  void search_elements_box_floor(IntBoxData<_SIZE_>& boxdata, int_t octree_floor_id) const;
+  void search_elements_box_recursively(IntBoxData<_SIZE_>& boxdata, int_t octree_id, int cx, int cy, int cz, int half_width) const;
+
+  // Un octree peut etre soit vide, soit subdivise en nb_octrees autres octrees,
+  // soit un octree_floor contenant une liste d'elements.
+  enum Octree_Type { EMPTY, OCTREE, FLOOR };
+
+  static inline int_t octree_id(int_t index, Octree_Type type);
+  static inline int_t octree_index(int_t octree_id, Octree_Type type);
+  static inline Octree_Type octree_type(int_t octree_id);
+
+  // Octree_id du cube principal : peut etre EMPTY, OCTREE ou FLOOR
+  int_t root_octree_id_;
+  // Nombre d'elements stockes (dimension(0) du tableau elements_boxes)
+  int_t nb_elements_;
+  // Tableau contenant tous les cubes qui sont divises en sous-cubes
+  //  octree_structure_(i, j) decrit le contenu du sous-cube j du cube d'index i.
+  //  pour 0 <= j < nombre de sous-cubes par cube.
+  //  On appelle "octree_id" une valeur X=octree_structure_(i,j) (identifiant octree)
+  //  L'octree id encode a la fois le type de l'octree et l'index ou
+  //  il se trouve dans les tableaux (voir octree_id(int, Octree_Type))
+  IntTab_t octree_structure_;
+
+  // Tableau contenant la liste des elements de chaque sous-cube final non subdivise.
+  // Si X < 0, on note i_debut = -X-1.
+  // floor_elements_(i_debut) = n = nombre d'elements dans ce sous-cube
+  // floor_elements_[i_debut+j] = numero d'un element qui coupe ce sous-cube pour 1 <= j <= n
+  ArrOfInt_t floor_elements_;
+};
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Operator.h b/Utilities/VisItBridge/databases/readers/Lata/Operator.h
new file mode 100644
index 00000000..eb323296
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Operator.h
@@ -0,0 +1,224 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef OPERATORS_H
+#define OPERATORS_H
+#include <LataFilter.h>
+
+// A tool to "reconnect" several subdomains of a parallel computation:
+//  reconnect_geometry() searches for duplicate node coordinates and
+//  changes the elements_ and faces_ arrays to use the smallest node
+//  index that has the same coordinate. Hence, we recover the connectivity
+//  between blocks.
+class Reconnect
+{
+public:
+  static void reconnect_geometry(DomainUnstructured& geom, double tolerance, trustIdType nb_nodes_untouched = 0);
+  static void apply_renumbering(const BigArrOfTID& nodes_renumber, BigArrOfTID& data);
+  static void search_duplicate_nodes(const BigFloatTab& src_coord, BigArrOfTID& nodes_renumber, double eps, trustIdType nb_nodes_untouched = 0);
+};
+
+class OperatorClipbox: public Operator
+{
+public:
+  void build_geometry(const Domain& src_domain, LataDeriv<Domain>& dest) override;
+  void build_field(const Domain& src_domain, const LataField_base& src_field, const Domain& dest_domain, LataDeriv<LataField_base>& dest) override;
+  // Renumerotation des sommets, elements et faces par rapport aux donnees brutes lues
+  // renum_truc_[new_index] = index in lata file;
+  // La renumerotation vient de clip_box et de regularize
+  BigArrOfInt renum_nodes_;
+  BigArrOfInt renum_elements_;
+  BigArrOfInt renum_faces_;
+};
+
+class OperatorBoundary: public Operator
+{
+public:
+  OperatorBoundary() : geom_init_(false) { }
+  void build_geometry(const Domain& src_domain, LataDeriv<Domain>& dest) override;
+  void build_field(const Domain& src_domain, const LataField_base& src_field, const Domain& dest_domain, LataDeriv<LataField_base>& dest) override;
+  Size_t compute_memory_size() const override
+  {
+    return memory_size(src_nodes_) + memory_size(src_element_) + memory_size(src_face_);
+  }
+  // Renumerotation des sommets, elements et faces par rapport aux donnees brutes lues
+  // renum_truc_[new_index] = index in lata file;
+  // La renumerotation vient de clip_box et de regularize
+  BigArrOfTID src_nodes_; // for each boundary node, which node is it in source domain ?
+  BigArrOfTID src_element_; // same for boundary face vs source domain element
+  BigArrOfInt src_face_; // local (hence 'int', not 'TID') face number on src_element_
+  bool geom_init_;
+};
+
+class OperatorRegularize: public Operator
+{
+public:
+  OperatorRegularize()
+  {
+    tolerance_ = -1.;
+    geom_init_ = false;
+    extend_layer_ = 0;
+  }
+  void set_tolerance(double epsilon)
+  {
+    tolerance_ = epsilon;
+  }
+  void set_extend_layer(int n)
+  {
+    if (n >= 0)
+      extend_layer_ = n;
+    else
+      extend_layer_ = 0;
+  }
+  void build_geometry(const Domain& src_domain, LataDeriv<Domain>& dest) override;
+  void build_field(const Domain& src_domain, const LataField_base& src_field, const Domain& dest_domain, LataDeriv<LataField_base>& dest) override;
+
+  Size_t compute_memory_size() const override
+  {
+    return memory_size(renum_nodes_) + memory_size(renum_elements_) + memory_size(renum_faces_);
+  }
+  // Renumerotation des sommets, elements et faces par rapport aux donnees brutes lues
+  // renum_truc_[old_index] = new_index;
+  BigArrOfTID renum_nodes_;
+  BigArrOfTID renum_elements_;
+  // Pour les faces: les faces de chaque direction du domaine ijk sont numerotees
+  //  separement: faces de normales X entre 0 et N, faces de normales Y entre 0 et N, etc...
+  // Le numero d'une face est egal au plus petit des numeros de ses sommets du le maillage ijk.
+  // Renum faces contient le codage suivant:
+  //  numero de la face = renum_faces_[i] >> 2;
+  //  direction de la face  = (renum_faces_ & 3)
+  BigArrOfTID renum_faces_;
+  double tolerance_;
+  int extend_layer_;
+  bool geom_init_;
+};
+
+class OperatorDualMesh: public Operator
+{
+public:
+  void build_geometry(const Domain& src_domain, LataDeriv<Domain>& dest) override;
+  void build_field(const Domain& src_domain, const LataField_base& src_field, const Domain& dest_domain, LataDeriv<LataField_base>& dest) override;
+  Size_t compute_memory_size() const override
+  {
+    return 0;
+  }
+};
+class OperatorFacesMesh: public Operator
+{
+public:
+  void build_geometry(const Domain& src_domain, LataDeriv<Domain>& dest) override;
+  void build_field(const Domain& src_domain, const LataField_base& src_field, const Domain& dest_domain, LataDeriv<LataField_base>& dest) override;
+  Size_t compute_memory_size() const override
+  {
+    return 0;
+  }
+};
+
+class OperatorNCMesh: public Operator
+{
+public:
+  void build_geometry(const Domain& src_domain, LataDeriv<Domain>& dest) override;
+  void build_field(const Domain& src_domain, const LataField_base& src_field, const Domain& dest_domain, LataDeriv<LataField_base>& dest) override;
+  Size_t compute_memory_size() const override
+  {
+    return 0;
+  }
+};
+
+// These generic methods just say that the particular function does not exist:
+void build_geometry_(Operator& op, const Domain& src, LataDeriv<Domain>& dest);
+void build_field_(Operator& op, const Domain& src, const Domain& dest, const LataField_base& srcf, LataField_base& destf);
+
+template<class Op>
+void apply_geometry(Op& op, const Domain& src_domain, LataDeriv<Domain>& dest)
+{
+  const DomainUnstructured *src1 = dynamic_cast<const DomainUnstructured*>(&src_domain);
+  const DomainIJK *src2 = dynamic_cast<const DomainIJK*>(&src_domain);
+
+  if (src1)
+    build_geometry_(op, *src1, dest);
+  else if (src2)
+    build_geometry_(op, *src2, dest);
+  else
+    {
+      Journal() << "Error in OperatorDualMesh::build_geometry: unsupported domain type" << endl;
+      throw;
+    }
+}
+
+// See apply_field
+template<class Op, class DomSrc, class DomDest>
+void apply_field3(Op& op, const DomSrc& src_domain, const LataField_base& src_field, const DomDest& dest_domain, LataDeriv<LataField_base>& dest)
+{
+  const Field<BigDoubleTab> *src1 = dynamic_cast<const Field<BigDoubleTab>*>(&src_field);
+  const Field<BigFloatTab> *src2 = dynamic_cast<const Field<BigFloatTab>*>(&src_field);
+  const Field<BigIntTab> *src3 = dynamic_cast<const Field<BigIntTab>*>(&src_field);
+  const Field<BigTIDTab> *src4 = dynamic_cast<const Field<BigTIDTab>*>(&src_field);
+
+
+  if (src1)
+    build_field_(op, src_domain, dest_domain, *src1, dest.instancie(Field<BigDoubleTab> ));
+  else if (src2)
+    build_field_(op, src_domain, dest_domain, *src2, dest.instancie(Field<BigFloatTab> ));
+  else if (src3)
+    build_field_(op, src_domain, dest_domain, *src3, dest.instancie(Field<BigIntTab> ));
+  else if (src4)
+    build_field_(op, src_domain, dest_domain, *src3, dest.instancie(Field<BigTIDTab> ));
+  else
+    {
+      Journal() << "Error in apply_field3: unsupported field type" << endl;
+      throw;
+    }
+}
+
+// See apply_field
+template<class Op, class DomSrc>
+void apply_field2(Op& op, const DomSrc& src_domain, const LataField_base& src_field, const Domain& dest_domain, LataDeriv<LataField_base>& dest)
+{
+  const DomainUnstructured *d1 = dynamic_cast<const DomainUnstructured*>(&dest_domain);
+  const DomainIJK *d2 = dynamic_cast<const DomainIJK*>(&dest_domain);
+  if (d1)
+    apply_field3(op, src_domain, src_field, *d1, dest);
+  else if (d2)
+    apply_field3(op, src_domain, src_field, *d2, dest);
+  else
+    {
+      Journal() << "Error in apply_field2: unsupported destination domain type" << endl;
+      throw;
+    }
+}
+
+// This template calls the appropriate "build_field_()" method in the given operator.
+//  The operator should implement non virtual methods for any usefull combination
+//  of source domain type, destination domain type and source field type. This template
+//  will call the correct method depending on the effective type of the parameters
+//  (determined with dynamic_cast).
+template<class Op>
+void apply_field(Op& op, const Domain& src_domain, const LataField_base& src_field, const Domain& dest_domain, LataDeriv<LataField_base>& dest)
+{
+  const DomainUnstructured *d1 = dynamic_cast<const DomainUnstructured*>(&src_domain);
+  const DomainIJK *d2 = dynamic_cast<const DomainIJK*>(&src_domain);
+  if (d1)
+    apply_field2(op, *d1, src_field, dest_domain, dest);
+  else if (d2)
+    apply_field2(op, *d2, src_field, dest_domain, dest);
+  else
+    {
+      Journal() << "Error in apply_field: unsupported source domain type" << endl;
+      throw;
+    }
+}
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/OperatorBoundary.cpp b/Utilities/VisItBridge/databases/readers/Lata/OperatorBoundary.cpp
new file mode 100644
index 00000000..62ffaa2a
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/OperatorBoundary.cpp
@@ -0,0 +1,212 @@
+/* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <LataFilter.h>
+#include <Operator.h>
+#include <Static_Int_Lists.h>
+#include <Connectivite_som_elem.h>
+
+// Journal level for messages
+#define verb_level 4
+
+void build_ref_elem_face(const Domain::Element elt_type, IntTab& ref_elem_face)
+{
+  static int faces_sommets_tetra[4][3] = { { 1, 2, 3 }, { 0, 3, 2 }, { 3, 0, 1 }, { 0, 2, 1 } };
+  static int faces_sommets_hexa[6][4] = { { 0, 2, 4, 6 }, { 0, 1, 4, 5 }, { 0, 1, 2, 3 }, { 1, 3, 5, 7 }, { 2, 3, 6, 7 }, { 4, 5, 6, 7 } };
+
+  int i, j;
+  switch(elt_type)
+    {
+    case Domain::tetra:
+      ref_elem_face.resize(4, 3);
+      for (i = 0; i < 4; i++)
+        for (j = 0; j < 3; j++)
+          ref_elem_face(i, j) = faces_sommets_tetra[i][j];
+      break;
+    case Domain::hexa:
+      ref_elem_face.resize(6, 4);
+      for (i = 0; i < 6; i++)
+        for (j = 0; j < 4; j++)
+          ref_elem_face(i, j) = faces_sommets_hexa[i][j];
+      break;
+    default:
+      Journal() << "build_ref_elem_face : non code pour element " << endl;
+    }
+}
+
+void build_geometry_(OperatorBoundary& op, const DomainUnstructured& src, LataDeriv<Domain>& dest_domain)
+{
+  Journal(verb_level) << "OperatorBoundary domain " << src.id_.name_ << endl;
+  DomainUnstructured& dest = dest_domain.instancie(DomainUnstructured);
+  switch(src.elt_type_)
+    {
+    case Domain::tetra:
+      dest.elt_type_ = Domain::triangle;
+      break;
+    case Domain::hexa:
+      dest.elt_type_ = Domain::quadri;
+      break;
+    default:
+      Journal() << "Error in OperatorBoundary: element type not supported" << endl;
+      throw;
+    }
+
+  Static_Int_Lists_64 som_elem;
+  construire_connectivite_som_elem<trustIdType>(src.nb_nodes(), src.elements_, som_elem, 0);
+  // For each element:
+  //  for each face of this element
+  //    how many neighbouring elements ?
+  //      if only one neighbour, it's a boundary face !
+
+  IntTab element_faces;
+  build_ref_elem_face(src.elt_type_, element_faces);
+  const int nb_nodes_per_face = element_faces.dimension(1);
+  const int nb_faces_per_element = element_faces.dimension(0);
+
+  ArrOfTID one_face(nb_nodes_per_face);
+  ArrOfTID adjacent_elements;
+
+  // For each node in the source domain, node number on the boundary:
+  BigArrOfTID nodes_renumber;
+  nodes_renumber.resize_array(src.nb_nodes());
+  nodes_renumber = -1;
+
+  int element_index, local_face_index;
+  // Browse only real elements (so we don't see boundaries between processors)
+  const trustIdType nelem = src.nb_elements() - src.nb_virt_items(LataField_base::ELEM);
+  int i;
+  trustIdType count = 0;
+  for (element_index = 0; element_index < nelem; element_index++)
+    {
+      for (local_face_index = 0; local_face_index < nb_faces_per_element; local_face_index++)
+        {
+          for (i = 0; i < nb_nodes_per_face; i++)
+            {
+              int local_node = element_faces(local_face_index, i);
+              trustIdType node = src.elements_(element_index, local_node);
+              one_face[i] = node;
+            }
+          find_adjacent_elements(som_elem, one_face, adjacent_elements);
+          if (adjacent_elements.size_array() == 1)
+            {
+              op.src_element_.append_array(element_index);
+              op.src_face_.append_array(local_face_index);
+              for (i = 0; i < nb_nodes_per_face; i++)
+                {
+                  trustIdType node = one_face[i];
+                  trustIdType dest_node = nodes_renumber[node];
+                  if (dest_node < 0)
+                    {
+                      dest_node = count++;
+                      op.src_nodes_.append_array(node);
+                      nodes_renumber[node] = dest_node;
+                    }
+                }
+            }
+        }
+    }
+
+  // Build nodes
+  const trustIdType nb_nodes = op.src_nodes_.size_array();
+  const int dim = (int)src.nodes_.dimension(1);
+  dest.nodes_.resize(nb_nodes, dim);
+  for (i = 0; i < nb_nodes; i++)
+    {
+      const trustIdType n = op.src_nodes_[i];
+      for (int j = 0; j < dim; j++)
+        dest.nodes_(i, j) = src.nodes_(n, j);
+    }
+
+  // Build elements
+  const trustIdType nb_elems = op.src_element_.size_array();
+  dest.elements_.resize(nb_elems, nb_nodes_per_face);
+  for (i = 0; i < nb_elems; i++)
+    {
+      const trustIdType elem = op.src_element_[i];
+      const int face = op.src_face_[i];
+      for (int j = 0; j < nb_nodes_per_face; j++)
+        {
+          const trustIdType src_node = src.elements_(elem, element_faces(face, j));
+          dest.elements_(i, j) = nodes_renumber[src_node];
+        }
+    }
+  op.geom_init_ = 1;
+}
+
+template<class TabType>
+void build_field_(OperatorBoundary& op, const DomainUnstructured& src_domain, const DomainUnstructured& dest_domain, const Field<TabType>& src, Field<TabType>& dest)
+{
+  if (!op.geom_init_)
+    {
+      // Must fill the renum_.... arrays first !
+      LataDeriv<Domain> destb;
+      op.build_geometry(src_domain, destb);
+    }
+  dest.component_names_ = src.component_names_;
+  dest.localisation_ = src.localisation_;
+  dest.nature_ = src.nature_;
+  if (dest.localisation_ == LataField_base::FACES)
+    dest.localisation_ = LataField_base::ELEM;
+
+  const int nb_compo = (int)src.data_.dimension(1);
+  trustIdType i, sz = 0;
+  switch(src.localisation_)
+    {
+    case LataField_base::ELEM:
+      sz = dest_domain.nb_elements();
+      dest.data_.resize(sz, nb_compo);
+      for (i = 0; i < sz; i++)
+        {
+          const trustIdType old_i = op.src_element_[i];
+          for (int j = 0; j < nb_compo; j++)
+            dest.data_(i, j) = src.data_(old_i, j);
+        }
+      break;
+    case LataField_base::SOM:
+      sz = dest_domain.nb_nodes();
+      dest.data_.resize(sz, nb_compo);
+      for (i = 0; i < sz; i++)
+        {
+          const trustIdType old_i = op.src_nodes_[i];
+          for (int j = 0; j < nb_compo; j++)
+            dest.data_(i, j) = src.data_(old_i, j);
+        }
+      break;
+    case LataField_base::FACES:
+      sz = dest_domain.nb_elements();
+      dest.data_.resize(sz, nb_compo);
+      for (i = 0; i < sz; i++)
+        {
+          const trustIdType old_i = src_domain.elem_faces_(op.src_element_[i], op.src_face_[i]);
+          for (int j = 0; j < nb_compo; j++)
+            dest.data_(i, j) = src.data_(old_i, j);
+        }
+      break;
+    default:
+      Journal() << "Error in OperatorRegularize::build_field_: unknown localisation" << endl;
+      throw;
+    }
+}
+
+void OperatorBoundary::build_geometry(const Domain& src_domain, LataDeriv<Domain>& dest)
+{
+  apply_geometry(*this, src_domain, dest);
+}
+
+void OperatorBoundary::build_field(const Domain& src_domain, const LataField_base& src_field, const Domain& dest_domain, LataDeriv<LataField_base>& dest)
+{
+  apply_field(*this, src_domain, src_field, dest_domain, dest);
+}
+
+#undef verb_level
diff --git a/Utilities/VisItBridge/databases/readers/Lata/OperatorDualMesh.cpp b/Utilities/VisItBridge/databases/readers/Lata/OperatorDualMesh.cpp
new file mode 100644
index 00000000..0ccaf40d
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/OperatorDualMesh.cpp
@@ -0,0 +1,225 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <LataFilter.h>
+#include <Operator.h>
+
+// Journal level
+#define verb_level 4
+
+void build_geometry_(OperatorDualMesh& op, const DomainUnstructured& src, LataDeriv<Domain>& dest_domain)
+{
+  Journal(verb_level) << "OperatorDualMesh geometry(unstructured) " << src.id_.name_ << endl;
+  if (!src.faces_ok())
+    {
+      Journal() << "Error in OperatorDualMesh::build_geometry: source domain has no faces data" << endl;
+      throw;
+    }
+  const trustIdType nb_som = src.nodes_.dimension(0), nb_elem = src.elem_faces_.dimension(0), nb_faces = src.faces_.dimension(0); // Not elements_, in case elem_faces_ has no virtual data.
+  const trustIdType dim = src.dimension();
+
+  DomainUnstructured& dest = dest_domain.instancie(DomainUnstructured);
+  dest.id_ = src.id_;
+  dest.id_.name_ += "_dual";
+  dest.elt_type_ = dim < 3 ? Domain::polygone : Domain::polyedre;
+
+  dest.nodes_ = src.nodes_;
+  dest.nodes_.resize(nb_som + nb_elem, int(dim));
+  src.compute_cell_center_coordinates(dest.nodes_, nb_som);
+
+  dest.elements_.resize(nb_faces, int(src.faces_.dimension(1)) + 2);
+  dest.elem_faces_.resize(nb_faces, 2 * int(src.faces_.dimension(1)));
+  dest.faces_.resize(0, int(src.faces_.dimension(1)));
+
+  for (trustIdType f = 0, s, e; f < nb_faces; f++)
+    {
+      /* dest.elements_ : les sommets de la face + amont/aval */ 
+      if (dim < 3) /* 2D : un sommet de la face -> CG elem amont -> l'autre sommet -> CG elem aval */
+        {
+          int k = 0;
+          for (int i = 0; i < 2; i++)
+            for (int j = 0; j < 2; j++)
+              if (j ? (s = src.faces_(f, i)) >= 0 : (e = src.face_voisins_(f, i)) >= 0 && e < nb_elem)
+                dest.elements_(f, k) = j ? s : nb_som + e, k++;
+          for (; k < dest.elements_.dimension(1); k++) dest.elements_(f, k) = -1;
+        }
+      else
+        {
+          int i;
+          for (i = 0; i < src.faces_.dimension(1) && (s = src.faces_(f, i)) >= 0; i++)
+            dest.elements_(f, i) = s;
+          for (int j = 0; j < 2; j++)
+            if ((e = src.face_voisins_(f, j)) >= 0 && e < nb_elem)
+              dest.elements_(f, i) = nb_som + e, i++;
+          for ( ; i < dest.elements_.dimension(1); i++)
+            dest.elements_(f, i) = -1;
+        }
+      /* dest.elem_faces_ et dest_faces_ : une face par arete et par cote des faces orginales */
+      int j = 0;
+      for (int i = 0; i < 2; i++)
+        if ((e = src.face_voisins_(f, i)) >= 0 && e < nb_elem) /* un voisin reel -> boucles sur les aretes */
+          for (int k = 0; k < src.faces_.dimension(1) && (s = src.faces_(f, k)) >= 0; k++)
+            {
+              trustIdType sb = dim < 3 ? -1 : src.faces_(f, k + 1 < src.faces_.dimension(1) && src.faces_(f, k + 1) >= 0 ? k + 1 : 0);
+              trustIdType l = dest.faces_.dimension(0);
+              dest.faces_.resize(l + 1, int(src.faces_.dimension(1)));
+              dest.elem_faces_(f, j) = l, j++;
+              for (int m = 0; m < src.faces_.dimension(1); m++)
+                dest.faces_(l, m) = m < 1 ? nb_som + e : m < 2 ? s : m < dim ? sb : -1;
+            }
+        else
+        {
+          trustIdType l = dest.faces_.dimension(0);
+          dest.faces_.resize(l + 1, int(src.faces_.dimension(1)));
+          dest.elem_faces_(f, j) = l;
+          j++;
+          for (int k = 0; k < src.faces_.dimension(1); k++) /* sinon -> on insere la face originale */
+            dest.faces_(l, k) = src.faces_(f, k);
+        }
+      for (; j < dest.elem_faces_.dimension(1); j++) dest.elem_faces_(f, j) = -1;
+    }
+  dest.set_nb_virt_items(LataField_base::ELEM, src.nb_virt_items(LataField_base::FACES));
+}
+
+// Builds a field on the dual domain from the field on the source domain.
+// Source field must be located at faces.
+// (destination field is located at the elements. the value for an element
+//  is the value associated to the adjacent face of the source domain).
+template<class TabType>
+void build_field_(OperatorDualMesh& op, const DomainUnstructured& src_domain, const DomainUnstructured& dest_domain, const Field<TabType>& src, Field<TabType>& dest)
+{
+  Journal(verb_level) << "OperatorDualMesh field(unstructured) " << src.id_.uname_ << endl;
+  dest.component_names_ = src.component_names_;
+  dest.localisation_ = LataField_base::ELEM;
+  dest.nature_ = src.nature_;
+  dest.data_ = src.data_;
+}
+
+void build_geometry_(OperatorDualMesh& op, const DomainIJK& src, LataDeriv<Domain>& dest_domain)
+{
+  Journal(verb_level) << "OperatorDualMesh geometry(ijk) " << src.id_.name_ << endl;
+  if (src.elt_type_ != Domain::quadri && src.elt_type_ != Domain::hexa)
+    {
+      Journal() << "Error in OperatorDualMesh::build_geometry: cannot operate on unstructured mesh with this element type" << endl;
+      throw;
+    }
+
+  DomainIJK& dest = dest_domain.instancie(DomainIJK);
+  dest.elt_type_ = src.elt_type_;
+  const int dim = src.dimension();
+  for (int i_dim = 0; i_dim < dim; i_dim++)
+    {
+      const ArrOfFloat& c1 = src.coord_[i_dim];
+      ArrOfFloat& c2 = dest.coord_.add(ArrOfFloat());
+      const int n = c1.size_array() - 1;
+      c2.resize_array(n * 2 + 1);
+      for (int i = 0; i < n; i++)
+        {
+          c2[i * 2] = c1[i];
+          c2[i * 2 + 1] = (c1[i] + c1[i + 1]) * 0.5f;
+        }
+      c2[n * 2] = c1[n];
+    }
+
+  if (src.invalid_connections_.size_array() > 0)
+    {
+      dest.invalid_connections_.resize_array(dest.nb_elements());
+      dest.invalid_connections_ = 0;
+      int index = 0;
+
+      const int ni = dest.coord_[0].size_array() - 1;
+      const int nj = dest.coord_[1].size_array() - 1;
+      const int nk = (dim == 3) ? (dest.coord_[2].size_array() - 1) : 1;
+      const int ni_src = src.coord_[0].size_array() - 1;
+      const int nj_src = src.coord_[1].size_array() - 1;
+      for (int k = 0; k < nk; k++)
+        {
+          const int k_src = k / 2;
+          for (int j = 0; j < nj; j++)
+            {
+              const int j_src = j / 2;
+              const trustIdType idx_source = ((trustIdType)k_src * (trustIdType)nj_src + (trustIdType)j_src) * (trustIdType)ni_src;
+              for (int i = 0; i < ni; i++)
+                {
+                  const trustIdType idx = idx_source + i / 2;
+                  if (src.invalid_connections_[idx])
+                    dest.invalid_connections_.setbit(index);
+                  index++;
+                }
+            }
+        }
+    }
+  dest.virtual_layer_begin_ = 2 * src.virtual_layer_begin_;
+  dest.virtual_layer_end_ = 2 * src.virtual_layer_end_;
+}
+
+#define IJK(i,j,k) ((trustIdType)k*nj_ni_src + (trustIdType)j*(trustIdType)ni_src + (trustIdType)i)
+
+template<class TabType>
+void build_field_(OperatorDualMesh& op, const DomainIJK& src_domain, const DomainIJK& dest_domain, const Field<TabType>& src, Field<TabType>& dest)
+{
+  Journal(verb_level) << "OperatorDualMesh field(ijk) " << src.id_.uname_ << endl;
+  dest.component_names_ = src.component_names_;
+  dest.localisation_ = LataField_base::ELEM;
+  dest.nature_ = LataDBField::VECTOR;
+  const int dim = src_domain.dimension();
+  trustIdType index = 0;
+
+  // Loop on destination elements
+  const int ni = dest_domain.coord_[0].size_array() - 1;
+  const int nj = dest_domain.coord_[1].size_array() - 1;
+  const int nk = (dim == 3) ? (dest_domain.coord_[2].size_array() - 1) : 1;
+  dest.data_.resize(ni * nj * nk, dim);
+  const int ni_src = src_domain.coord_[0].size_array();
+  const trustIdType nj_ni_src = (trustIdType)src_domain.coord_[1].size_array() * (trustIdType)ni_src;
+  for (int k = 0; k < nk; k++)
+    {
+      const int k2 = k / 2;
+      const int k3 = (k + 1) / 2;
+      for (int j = 0; j < nj; j++)
+        {
+          const int j2 = j / 2;
+          const int j3 = (j + 1) / 2;
+          for (int i = 0; i < ni; i++)
+            {
+              const int i2 = i / 2;
+              const int i3 = (i + 1) / 2;
+              dest.data_(index, 0) = src.data_(IJK(i3, j2, k2), 0);
+              dest.data_(index, 1) = src.data_(IJK(i2, j3, k2), 1);
+              if (dim == 3)
+                dest.data_(index, 2) = src.data_(IJK(i2, j2, k3), 2);
+              index++;
+            }
+        }
+    }
+}
+
+#undef IJK
+
+void OperatorDualMesh::build_geometry(const Domain& src_domain, LataDeriv<Domain>& dest)
+{
+  apply_geometry(*this, src_domain, dest);
+}
+
+void OperatorDualMesh::build_field(const Domain& src_domain, const LataField_base& src_field, const Domain& dest_domain, LataDeriv<LataField_base>& dest)
+{
+  if (src_field.localisation_ != LataField_base::FACES)
+    {
+      Journal() << "Error in OperatorDualMesh::build_field: source field is not located at faces" << endl;
+      throw;
+    }
+  apply_field(*this, src_domain, src_field, dest_domain, dest);
+}
+#undef level
diff --git a/Utilities/VisItBridge/databases/readers/Lata/OperatorFacesMesh.cpp b/Utilities/VisItBridge/databases/readers/Lata/OperatorFacesMesh.cpp
new file mode 100644
index 00000000..9457ca53
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/OperatorFacesMesh.cpp
@@ -0,0 +1,102 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <LataFilter.h>
+#include <Operator.h>
+
+// Journal level
+#define verb_level 4
+
+void build_geometry_(OperatorFacesMesh& op, const DomainUnstructured& src, LataDeriv<Domain>& dest_domain)
+{
+  Journal(verb_level) << "OperatorFacesMesh geometry(unstructured) " << src.id_.name_ << endl;
+  if (!src.faces_ok())
+    {
+      Journal() << "Error in OperatorFacesMesh::build_geometry: source domain has no faces data" << endl;
+      throw;
+    }
+  // const int max_nb_som_face = 3; // for tetrahedra
+  if (src.elt_type_ != Domain::triangle && src.elt_type_ != Domain::quadri && src.elt_type_ != Domain::polygone && src.elt_type_ != Domain::tetra && src.elt_type_ != Domain::polyedre)
+    {
+      Journal() << "Error in OperatorFacesMesh::build_geometry: cannot operate on unstructured mesh with this element type" << endl;
+      throw;
+    }
+  //  const int nb_som = src.nodes_.dimension(0);
+  // const int nb_elem = src.elem_faces_.dimension(0); // Not elements_, in case elem_faces_ has no virtual data.
+  //const int dim = src.dimension();
+
+  DomainUnstructured& dest = dest_domain.instancie(DomainUnstructured);
+  dest.id_ = src.id_;
+  dest.id_.name_ += "_centerfaces";
+  if (src.elt_type_ == Domain::triangle || src.elt_type_ == Domain::quadri || src.elt_type_ == Domain::polygone)
+    dest.elt_type_ = Domain::line;
+  else if (src.elt_type_ == Domain::tetra)
+    dest.elt_type_ = Domain::triangle;
+  else if (src.elt_type_ == Domain::polyedre)
+    dest.elt_type_ = Domain::polygone;
+
+  dest.nodes_ = src.nodes_;
+  dest.elements_ = src.faces_;
+
+  const trustIdType nb_elem_virt = src.nb_virt_items(LataField_base::FACES);
+  dest.set_nb_virt_items(LataField_base::ELEM, nb_elem_virt);
+}
+
+// Builds a field on the dual domain from the field on the source domain.
+// Source field must be located at faces.
+// (destination field is located at the elements. the value for an element
+//  is the value associated to the adjacent face of the source domain).
+template<class TabType>
+void build_field_(OperatorFacesMesh& op, const DomainUnstructured& src_domain, const DomainUnstructured& dest_domain, const Field<TabType>& src, Field<TabType>& dest)
+{
+  Journal(verb_level) << "OperatorFacesMesh field(unstructured) " << src.id_.uname_ << endl;
+  dest.component_names_ = src.component_names_;
+  dest.localisation_ = LataField_base::ELEM;
+  dest.nature_ = src.nature_;
+
+  dest.data_ = src.data_;
+
+}
+
+void build_geometry_(OperatorFacesMesh& op, const DomainIJK& src, LataDeriv<Domain>& dest_domain)
+{
+  Journal(verb_level) << "OperatorFacesMesh geometry(ijk) " << src.id_.name_ << endl;
+  Journal() << "Error in OperatorFacesMesh::build_geometry: cannot operate on domainIJK" << endl;
+  throw;
+
+}
+template<class TabType>
+void build_field_(OperatorFacesMesh& op, const DomainIJK& src_domain, const DomainIJK& dest_domain, const Field<TabType>& src, Field<TabType>& dest)
+{
+  Journal(verb_level) << "OperatorFacesMesh field(ijk) " << src.id_.uname_ << endl;
+  Journal() << "Error in OperatorFacesMesh::build_geometry: cannot operate on domainIJK" << endl;
+  throw;
+}
+
+void OperatorFacesMesh::build_geometry(const Domain& src_domain, LataDeriv<Domain>& dest)
+{
+  apply_geometry(*this, src_domain, dest);
+}
+
+void OperatorFacesMesh::build_field(const Domain& src_domain, const LataField_base& src_field, const Domain& dest_domain, LataDeriv<LataField_base>& dest)
+{
+  if (src_field.localisation_ != LataField_base::FACES)
+    {
+      Journal() << "Error in OperatorFacesMesh::build_field: source field is not located at faces" << endl;
+      throw;
+    }
+  apply_field(*this, src_domain, src_field, dest_domain, dest);
+}
+#undef level
diff --git a/Utilities/VisItBridge/databases/readers/Lata/OperatorReconnect.cpp b/Utilities/VisItBridge/databases/readers/Lata/OperatorReconnect.cpp
new file mode 100644
index 00000000..47ad0fc5
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/OperatorReconnect.cpp
@@ -0,0 +1,106 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <Operator.h>
+#include <Octree_Double.h>
+
+#define verb_level 4
+
+// Description: Find duplicate coordinates in the "coord" array.
+//  nodes_renumber will have dimension src_coord.dimension(0)
+//  nodes_renumber[i] = i if the node imust be conserved,
+//  nodes_renumber[i] = j if the node i is identical to node j. We always have j<i
+//  eps = tolerance in each direction to consider that two nodes are identical
+//  nb_nodes_untouched : do not search duplicate nodes in the "nb_nodes_untouched"
+//   first nodes. The remaining nodes are still compared to all nodes.
+void Reconnect::search_duplicate_nodes(const BigFloatTab& src_coord, BigArrOfTID& nodes_renumber, double eps, trustIdType nb_nodes_untouched)
+{
+  // Create a temporary DoubleTab (coords are normally float)
+  const trustIdType nb_nodes = src_coord.dimension(0);
+  const int dim = (int)src_coord.dimension(1);
+  // Build an octree with all coordinates
+  Journal(verb_level + 1) << " Building octree" << endl;
+  BigDoubleTab coords;
+  coords.resize(nb_nodes, dim);
+  for (trustIdType i = 0; i < nb_nodes; i++)
+    for (int j = 0; j < dim; j++)
+      coords(i, j) = src_coord(i, j);
+  Octree_Double_64 octree;
+  octree.build_nodes(coords, 0 /* no virtual nodes */);
+
+  Journal(verb_level + 1) << " Searching duplicate nodes" << endl;
+  nodes_renumber.resize_array(nb_nodes);
+  for (trustIdType i = 0; i < nb_nodes; i++)
+    nodes_renumber[i] = i;
+  // For each node, are there several nodes within epsilon ?
+  BigArrOfTID node_list;
+  trustIdType count = 0; // Number of nodes renumbered
+  for (trustIdType i = 0; i < nb_nodes; i++)
+    {
+      if (nodes_renumber[i] != i)
+        continue; // node already suppressed
+
+      const double x = coords(i, 0);
+      const double y = (dim > 1) ? coords(i, 1) : 0.;
+      const double z = (dim > 2) ? coords(i, 2) : 0.;
+      octree.search_elements_box(x - eps, y - eps, z - eps, x + eps, y + eps, z + eps, node_list);
+      Octree_Double_64::search_nodes_close_to(x, y, z, coords, node_list, eps);
+      const trustIdType n = node_list.size_array();
+      if (n > 1)
+        {
+          for (trustIdType j = 0; j < n; j++)
+            {
+              // Change only nodes with rank > i
+              const trustIdType node = node_list[j];
+              if (node > j)
+                {
+                  nodes_renumber[node] = i;
+                  count++;
+                }
+            }
+        }
+    }
+  Journal(verb_level + 1) << " " << count << " duplicate nodes will be removed" << endl;
+}
+
+void Reconnect::apply_renumbering(const BigArrOfTID& nodes_renumber, BigArrOfTID& data)
+{
+  trustIdType ntot = data.size_array();
+  for (trustIdType i = 0; i < ntot; i++)
+    {
+      const trustIdType node = data[i];
+      const trustIdType n = nodes_renumber[node];
+      if (n != node)
+        data[i] = n;
+    }
+}
+
+// Description: updates the elements_ and faces_ arrays of the domain so that
+//  all nodes having the same coordinates are replaced by one unique node
+//  in these arrays. See search_duplicate_nodes for nb_nodes_untouched description.
+void Reconnect::reconnect_geometry(DomainUnstructured& geom, double tolerance, trustIdType nb_nodes_untouched)
+{
+  Journal(verb_level) << "Reconnect domain " << geom.id_.name_ << endl;
+
+  BigArrOfTID nodes_renumber;
+  search_duplicate_nodes(geom.nodes_, nodes_renumber, tolerance, nb_nodes_untouched);
+
+  apply_renumbering(nodes_renumber, geom.elements_);
+
+  if (geom.faces_ok())
+    apply_renumbering(nodes_renumber, geom.faces_);
+}
+
+#undef verb_level
diff --git a/Utilities/VisItBridge/databases/readers/Lata/OperatorRegularize.cpp b/Utilities/VisItBridge/databases/readers/Lata/OperatorRegularize.cpp
new file mode 100644
index 00000000..5d79ec2f
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/OperatorRegularize.cpp
@@ -0,0 +1,315 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <LataFilter.h>
+#include <Operator.h>
+#include <limits>
+
+#define verb_level 4
+
+template<class T, class Tab> int search_in_ordered_vect(T x, const Tab& v, const T epsilon)
+{
+  using int_t = typename Tab::int_t;
+  if (!v.size_array())
+    return -1;
+  int_t i1 = 0;
+  int_t i;
+  int_t i2 = v.size_array() - 1;
+  while (i1 != i2)
+    {
+      i = (i1 + i2) / 2;
+      if (epsilon + v[i] < x)
+        i1 = i + 1;
+      else
+        i2 = i;
+    }
+  if (v[i1] == x)
+    return i1;
+  if (((v[i1] - x) * (v[i1] - x)) <= (epsilon * epsilon))
+    return i1;
+
+  return -1;
+}
+
+template<class T, class Tab>
+static void retirer_doublons(Tab& tab, const T epsilon)
+{
+  using int_t = typename Tab::int_t;
+  int_t i = 0;
+  int_t j;
+  const int_t n = tab.size_array();
+  T last_tab_i = -std::numeric_limits<T>::max();
+  for (j = 0; j < n; j++)
+    {
+      const T x = tab[j];
+      assert(x >= last_tab_i); // Array must be sorted
+      if (x - last_tab_i > epsilon)
+        {
+          tab[i] = x;
+          last_tab_i = x;
+          i++;
+        }
+    }
+  tab.resize_array(i);
+}
+
+void build_geometry_(OperatorRegularize& op, const DomainUnstructured& src, LataDeriv<Domain>& dest_domain)
+{
+  Journal(verb_level) << "OperatorRegularize domain " << src.id_.name_ << endl;
+  if (src.elt_type_ != Domain::quadri && src.elt_type_ != Domain::hexa)
+    {
+      Journal() << "Error in OperatorRegularize::build_geometry: cannot operate on unstructured mesh with this element type" << endl;
+      throw;
+    }
+
+  DomainIJK& dest = dest_domain.instancie(DomainIJK);
+  dest.elt_type_ = src.elt_type_;
+  const trustIdType nsom = src.nodes_.dimension(0);
+  const int dim = (int)src.nodes_.dimension(1);
+  ArrOfInt nb_som_dir(dim);
+  {
+    double product_n = 1.;
+    for (int i_dim = 0; i_dim < dim; i_dim++)
+      {
+        BigArrOfFloat coord_big;
+        coord_big.resize_array(nsom);
+        trustIdType i;
+        for (i = 0; i < nsom; i++)
+          coord_big[i] = src.nodes_(i, i_dim);
+        coord_big.ordonne_array();
+        retirer_doublons(coord_big, (float) op.tolerance_);
+        product_n *= (double)coord_big.size_array();
+        // Add extended domain layer:
+        if (coord_big.size_array() > 1)
+          {
+            const trustIdType n = coord_big.size_array();
+            const trustIdType l = op.extend_layer_;
+            coord_big.resize_array(n + l * 2);
+            float x0 = coord_big[n - 1];
+            float delta = coord_big[n - 2] - x0;
+            for (i = 1; i <= l; i++)
+              coord_big[n + l + i] = x0 + delta * (float) i;
+            for (i = l - 1; i >= 0; i--)
+              coord_big[i + l] = coord_big[i];
+            x0 = coord_big[l];
+            delta = coord_big[l + 1] - x0;
+            for (i = 1; i <= l; i++)
+              coord_big[l - i] = x0 - delta * (float) i;
+          }
+        int sz = (int)coord_big.size_array();
+        nb_som_dir[i_dim] = (int)sz;
+        if(sz<0)
+          {
+            Journal() << "Positions do not seem regular !" << endl;
+            throw;
+          }
+        // Register final (reduced) coord_big in coord:
+        ArrOfFloat& coord = dest.coord_.add(ArrOfFloat());
+        coord_big.ref_as_small(coord);
+      }
+    // Verifying that unique has deleted many points...
+    // If well organised, nsom=nx*ny*nz
+    // If chaos, nsom=(nx+ny+nz)/3
+    // We want to verify that we are nearer to organisation than to chaos !
+    if (product_n > (double) nsom * (double) nsom - 1.)
+      {
+        Journal() << "Positions do not seem regular !" << endl;
+        throw;
+      }
+  }
+  op.renum_nodes_.resize_array(nsom);
+  BigIntTab ijk_indexes;  // Not BigTIDTab ...
+  ijk_indexes.resize(nsom, dim);
+  for (trustIdType i = 0; i < nsom; i++)
+    {
+      trustIdType ijk_index = 0;
+      for (int j = dim - 1; j >= 0; j--)
+        {
+          const double x = src.nodes_(i, j);
+          int index = search_in_ordered_vect(x, dest.coord_[j], op.tolerance_);
+          if (index < 0)
+            {
+              Journal() << "Error: coordinate (" << i << "," << j << ") = " << x << " not found in regularize" << endl << "Try reducing regularize tolerance value (option regularize=epsilon)" << endl;
+              throw;
+            }
+          ijk_indexes(i, j) = index;
+          ijk_index += index;
+          if (j)
+            ijk_index *= nb_som_dir[j - 1];
+        }
+      op.renum_nodes_[i] = ijk_index;
+    }
+  const int max_index = max_array(nb_som_dir);
+  trustIdType nb_elems_ijk = 1;
+  for (int i = 0; i < dim; i++)
+    nb_elems_ijk *= nb_som_dir[i] - 1;
+  dest.invalid_connections_.resize_array(nb_elems_ijk);
+  dest.invalid_connections_ = 1; // Everything invalid by default
+  const trustIdType nelem = src.elements_.dimension(0);
+  const int nb_som_elem = (int)src.elements_.dimension(1);
+  op.renum_elements_.resize_array(nelem);
+  // Pour chaque element, indice dans le maillage ijk du plus sommet le plus proche de l'origine
+  // (pour les faces...)
+  BigArrOfTID idx_elem_som;
+  idx_elem_som.resize_array(nelem);
+  int min_index[3];
+  for (trustIdType i = 0; i < nelem; i++)
+    {
+      min_index[0] = min_index[1] = min_index[2] = max_index;
+      for (int j = 0; j < nb_som_elem; j++)
+        {
+          trustIdType node = src.elements_(i, j);
+          for (int k = 0; k < loop_max(dim, 3); k++)
+            {
+              int idx = ijk_indexes(node, k);
+              min_index[k] = (idx < min_index[k]) ? idx : min_index[k];
+              break_loop(k, dim);
+            }
+        }
+      trustIdType idx = 0;
+      trustIdType idx_som = 0;
+      if (dim == 1)
+        {
+          idx = min_index[0];
+          idx_som = idx;
+        }
+      else if (dim == 2)
+        {
+          idx = (trustIdType)min_index[1] * ((trustIdType)nb_som_dir[0] - 1) + (trustIdType)min_index[0];
+          idx_som = (trustIdType)min_index[1] * (trustIdType)nb_som_dir[0] + (trustIdType)min_index[0];
+        }
+      else if (dim == 3)
+        {
+          idx = ((trustIdType)min_index[2] * ((trustIdType)nb_som_dir[1] - 1) + (trustIdType)min_index[1]) * ((trustIdType)nb_som_dir[0] - 1) + (trustIdType)min_index[0];
+          idx_som = ((trustIdType)min_index[2] * (trustIdType)nb_som_dir[1] + (trustIdType)min_index[1]) * (trustIdType)nb_som_dir[0] + (trustIdType)min_index[0];
+        }
+      else
+        throw;
+      op.renum_elements_[i] = idx;
+      dest.invalid_connections_.clearbit(idx);
+      idx_elem_som[i] = idx_som;
+    }
+
+  if (src.faces_ok())
+    {
+      const trustIdType nfaces = src.faces_.dimension(0);
+      op.renum_faces_.resize_array(nfaces);
+      op.renum_faces_ = -1;
+      const int nb_elem_face = (int)src.elem_faces_.dimension(1);
+      ArrOfInt delta_dir(dim);
+      delta_dir[0] = 1;
+      for (int i = 1; i < dim; i++)
+        delta_dir[i] = delta_dir[i - 1] * nb_som_dir[i - 1];
+      for (trustIdType i = 0; i < nelem; i++)
+        {
+          // Les faces haut, gauche et arriere du cube a l'origine portent le numero 0
+          // Voir DomaineIJK pour la convention sur la numerotation des faces
+          for (int j = 0; j < nb_elem_face; j++)
+            {
+              const trustIdType i_face = src.elem_faces_(i, j);
+              int dir = (int)(j % dim);
+              trustIdType index = idx_elem_som[i];
+              if (j >= dim)
+                index += (trustIdType)delta_dir[dir];
+              // Encodage du numero de la face et de la direction
+              index = (index << 2) + (trustIdType)dir;
+              if (op.renum_faces_[i_face] < 0)
+                {
+                  op.renum_faces_[i_face] = index;
+                }
+              else if (op.renum_faces_[i_face] != index)
+                {
+                  Journal() << "Error in OperatorRegularize: faces renumbering failed" << endl;
+                  throw;
+                }
+            }
+        }
+    }
+  op.geom_init_ = 1;
+}
+
+template<class TabType>
+void build_field_(OperatorRegularize& op, const DomainUnstructured& src_domain, const DomainIJK& dest_domain, const Field<TabType>& src, Field<TabType>& dest)
+{
+  Journal(verb_level) << "OperatorRegularize field " << src.id_.uname_ << endl;
+  if (!op.geom_init_)
+    {
+      // Must fill the renum_.... arrays first !
+      LataDeriv<Domain> destr;
+      op.build_geometry(src_domain, destr);
+    }
+  dest.component_names_ = src.component_names_;
+  dest.localisation_ = src.localisation_;
+  dest.nature_ = src.nature_;
+  const trustIdType sz = src.data_.dimension(0);
+  const int nb_compo = (int)src.data_.dimension(1);
+  trustIdType i;
+  switch(src.localisation_)
+    {
+    case LataField_base::ELEM:
+      dest.data_.resize(dest_domain.nb_elements(), nb_compo);
+      for (i = 0; i < sz; i++)
+        {
+          const trustIdType new_i = op.renum_elements_[i];
+          for (int j = 0; j < nb_compo; j++)
+            dest.data_(new_i, j) = src.data_(i, j);
+        }
+      break;
+    case LataField_base::SOM:
+      dest.data_.resize(dest_domain.nb_nodes(), nb_compo);
+      for (i = 0; i < sz; i++)
+        {
+          const trustIdType new_i = op.renum_nodes_[i];
+          for (int j = 0; j < nb_compo; j++)
+            dest.data_(new_i, j) = src.data_(i, j);
+        }
+      break;
+    case LataField_base::FACES:
+      {
+        if (nb_compo != 1)
+          {
+            Journal() << "Error in OperatorRegularize: field at faces has nb_compo != 1" << endl;
+            throw;
+          }
+        dest.nature_ = LataDBField::VECTOR;
+        const int nb_dim = dest_domain.dimension();
+        dest.data_.resize(dest_domain.nb_faces(), nb_dim);
+        // Field is interpreted as normal component to the face
+        for (i = 0; i < sz; i++)
+          {
+            const trustIdType code = op.renum_faces_[i];
+            // decodage numero et direction de la face:
+            const trustIdType new_i = code >> 2;
+            const int direction = (int)(code & 3);
+            dest.data_(new_i, direction) = src.data_(i, 0);
+          }
+      }
+      break;
+    default:
+      Journal() << "Error in OperatorRegularize::build_field_: unknown localisation" << endl;
+      throw;
+    }
+}
+
+void OperatorRegularize::build_geometry(const Domain& src_domain, LataDeriv<Domain>& dest)
+{
+  apply_geometry(*this, src_domain, dest);
+}
+
+void OperatorRegularize::build_field(const Domain& src_domain, const LataField_base& src_field, const Domain& dest_domain, LataDeriv<LataField_base>& dest)
+{
+  apply_field(*this, src_domain, src_field, dest_domain, dest);
+}
+#undef verb_level
diff --git a/Utilities/VisItBridge/databases/readers/Lata/PE_Groups.h b/Utilities/VisItBridge/databases/readers/Lata/PE_Groups.h
new file mode 100644
index 00000000..28fd2ffa
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/PE_Groups.h
@@ -0,0 +1,62 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef PE_Groups_included
+#define PE_Groups_included
+
+#include <TRUSTTabs_forward.h>
+#include <TRUST_Deriv.h>
+#include <Comm_Group.h>
+
+/*! @brief : Cette classe regroupe des fonctions permettant la creation, la
+ *
+ *   destruction et le changement du groupe de processeurs actif.
+ *   La creation du groupe principal doit etre dans le MAIN.cpp
+ *   et il faut initialiser PE_Groups en lui donnant le groupe principal.
+ *   Les autres groupes crees seront du meme type.
+ *
+ *   @sa la class Comm_Group
+ *
+ */
+class PE_Groups
+{
+public:
+  inline static const Comm_Group& current_group();
+  static void create_group(const ArrOfInt& liste_pe, OWN_PTR(Comm_Group) &group, int force_Comm_Group_NoParallel = 0);
+  static int enter_group(const Comm_Group& group);
+  static void exit_group();
+  static const int& get_nb_groups();
+  static int rank_translate(int rank, const Comm_Group& group, const Comm_Group& dest_group = current_group());
+  static const Comm_Group& groupe_TRUST();
+
+  static void initialize(const Comm_Group& groupe_trio_u);
+  static void finalize();
+
+private:
+  static int check_current_group();
+  // This pointer always points to the last element of the "groups" vector in the .cpp file
+  static const Comm_Group *current_group_;
+};
+
+/*! @brief renvoie une reference au groupe de processeurs actif courant
+ *
+ */
+inline const Comm_Group& PE_Groups::current_group()
+{
+  assert(check_current_group());
+  return *current_group_;
+}
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Process.h b/Utilities/VisItBridge/databases/readers/Lata/Process.h
new file mode 100644
index 00000000..69cb57e5
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Process.h
@@ -0,0 +1,132 @@
+/****************************************************************************
+* Copyright (c) 2025, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Process_included
+#define Process_included
+
+#include <arch.h>
+
+#ifdef LATATOOLS
+#include <string>
+#include <stdlib.h>
+#else
+#include <TRUST_Version.h>  // so that it is accessible from everywhere in TRUST
+#endif
+
+class Objet_U;
+class Nom;
+class Sortie;
+
+int get_disable_stop();
+void change_disable_stop(int new_stop);
+
+/*! @brief Classe de base de TRUST (notamment Objet_U).
+ *
+ * Elle fournit quelques services de base
+ *    accessibles de partout dans le code (ces services etaient historiquement
+ *    des methodes non statiques, depuis que tous ces services sont statiques,
+ *    cette classe n'a plus vraiment d'autre fonction que de ranger ces methodes
+ *    quelque part)
+ *
+ * @sa Objet_U
+ */
+
+class Process
+{
+public:
+  virtual ~Process() { }
+
+  // Simplified dummy API for lata_tools
+#ifdef LATATOOLS
+  static int me() { return 0; }
+  static int nproc()  { return 1; }
+  static bool is_parallel()  { return false; }
+  static void exit(int exit_code = -1) { ::exit(exit_code); }
+  static void exit(const std::string& s) { ::exit(-1); }
+
+  static double mp_sum(double) { return 0; }
+  static float mp_sum(float) { return 0; }
+  static double mp_max(double) { return 0; }
+  static int mp_max(int) { return 0; }
+  static double mp_min(double) { return 0; }
+  static int mp_min(int) { return 0; }
+  static trustIdType mp_sum(int) { return 0; }
+  static trustIdType mp_sum(trustIdType) { return 0; }
+
+#else
+  static int me(); /* mon rang dans le groupe courant */
+  static int nproc();
+  static bool is_parallel();
+  static void exit(int exit_code = -1);
+
+  //
+  // Min/max across all procs
+  //
+  static double mp_max(double);
+  static double mp_min(double);
+  static int mp_max(int);
+  static int mp_min(int);
+#if INT_is_64_ == 2
+  static trustIdType mp_max(trustIdType);
+  static trustIdType mp_min(trustIdType);
+#endif
+
+  //
+  // Sum across all procs
+  //
+  static double mp_sum(double);
+  static float mp_sum(float);
+#if INT_is_64_ == 2
+  // Careful, the sum of many 'int' on several procs, might return a 'long'!!
+  static trustIdType mp_sum(int v) { return mp_sum(static_cast<trustIdType>(v)); }
+#endif
+  static trustIdType mp_sum(trustIdType);
+  // When computing percentages or ratios, useful:
+  static double mp_sum_as_double(int v) { return static_cast<double>(mp_sum(v)); }
+#if INT_is_64_ == 2
+  static double mp_sum_as_double(trustIdType v) { return static_cast<double>(mp_sum(v)); }
+#endif
+
+  // Summing for all procs before me:
+  static trustIdType mppartial_sum(trustIdType i);
+#if INT_is_64_ == 2
+  static trustIdType mppartial_sum(int i) { return mppartial_sum(static_cast<trustIdType>(i)); }
+#endif
+
+  // Summing two doubles at once
+  static void mpsum_multiple(double& x1, double& x2);
+
+  static bool mp_and(bool);
+  static bool mp_or(bool);
+
+  static int check_int_overflow(trustIdType);
+
+  static int je_suis_maitre();
+  static void exit(const Nom& message, int exit_code = -1);
+  static bool is_sequential(); // serial ?
+  static void barrier();
+  static void abort();
+
+  static Sortie& Journal(int message_level = 0);
+  static double ram_processeur();
+  static void imprimer_ram_totale(int all_process = 0);
+  static int exception_sur_exit;
+  static int multiple_files;
+  static bool force_single_file(const int ranks, const Nom& filename);
+#endif
+};
+
+#endif /* Process_included */
+
diff --git a/Utilities/VisItBridge/databases/readers/Lata/ReaderFORT21.cpp b/Utilities/VisItBridge/databases/readers/Lata/ReaderFORT21.cpp
new file mode 100644
index 00000000..97151f66
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/ReaderFORT21.cpp
@@ -0,0 +1,1522 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <ReaderFORT21.h>
+
+#include <algorithm>
+#include <cassert>
+#include <float.h>
+#include <iostream>
+#include <set>
+#include <stdio.h>
+
+#include <exception>
+#include <iomanip>  // used for setprecision()
+#include <iostream>
+#include <string.h>
+
+#define MAX_NAME_SIZE 16
+#define MAX_NUM_VARS 10000
+
+#ifdef WNT
+#pragma warning(disable : 4996)
+#else
+#include <fenv.h>
+#include <math.h>
+#include <string.h>
+#endif
+
+/*
+
+Description of FORT21
+
+Heder:
+ TYPE$$$$ FICHIER$ DOUBLE$$
+ VERSION$ LABEL$$$ NONE$$$$
+ IDENT$$$ 26/03/24  c3 v3.0.0 (git: f46e225) Date: 11-12-2023                                        PWR 6 INCH COLD LEG BREAK LOCA                                                  08:02:39
+
+Description (constant part)
+ DESCR$$$
+list de STACK (see below)
+
+List of times
+ VARIA$$$
+ VARIA$$$ 0.000000D+00
+list de STACK (see below)
+ VARIA$$$
+ VARIA$$$ 1.000000D+00
+....
+
+
+Read STACK
+ DESSTACK
+ name_of_stack type   nb_ptr nb_int nb_float nb_string
+ DIMEVAL$$          (nb_ptr+nb_int+nb_float+nb_string) integers size of the vars
+for each type
+ var_name value(s)
+
+exemple
+ DESSTACK
+ WALL1            WALVORIF                1        3        9        1
+ DIMVAL$$        1        1        1        2        1        1        2        1        1        1        2        2        2        1
+ ITYPER                540
+ GLOBAL                  1
+ SCALAR                  1
+ IWHYD                   1        1
+ GLOBAL           0.100000D+03
+ SCALAR           0.110000D+03
+ ZSW              0.100000D+01 0.200000D+01
+ WHSURTOT         0.453616D+02
+ ZPMIN            0.200000D-03
+ ZPMAX            0.288800D+01
+ RAYON1           0.250000D+01 0.250000D+01
+ RAYON2           0.255000D+01 0.255000D+01
+ RAYON3           0.275200D+01 0.275200D+01
+ NAMPER           VOLDOWN
+
+
+*/
+struct tbuff
+{
+  int Lo;
+  int Hi;
+  tbuff()
+    : Lo(0)
+    , Hi(0)
+  {
+  }
+};
+
+//=============================================================================
+// Function : int InverseInt
+// Purpose  :
+//=============================================================================
+inline static int InverseInt(const int theValue)
+{
+  return (0 | ((theValue & 0x000000ff) << 24) | ((theValue & 0x0000ff00) << 8) | ((theValue & 0x00ff0000) >> 8) | ((theValue >> 24) & 0x000000ff));
+}
+
+//================================================================
+// Function : inverse
+// Purpose  :
+//================================================================
+inline static tbuff inverse(const tbuff theBuff)
+{
+  tbuff aRes;
+  aRes.Hi = InverseInt(theBuff.Lo);
+  aRes.Lo = InverseInt(theBuff.Hi);
+  return aRes;
+}
+
+//=============================================================================
+// Function : getSizeOfRecordLength
+// Purpose  : Fets amount of bytes used for storing record length in FORT21 file
+//=============================================================================
+inline static int getSizeOfRecordLength(Platform thePlatform)
+{
+  return thePlatform == Linux_64gcc ? 8 : 4;
+}
+
+//=============================================================================
+// Function : int getSizeOfLong
+// Purpose  : gets amount of bytes used for storing integer variable in FORT21 file
+//=============================================================================
+inline static int getSizeOfLong(Platform thePlatform)
+{
+  return thePlatform == Linux_64f90 || thePlatform == Tru64_64f90 || thePlatform == Unix_64f77 ? 8 : 4;
+}
+
+//=============================================================================
+// Function : IsBigEndian
+// Purpose  : Verifies whether platform uses Big-endian byte order or Little-endian
+//=============================================================================
+inline static bool IsBigEndian(Platform thePlatform)
+{
+  return thePlatform == SGI_32;
+}
+
+//=============================================================================
+// Function : getSizeOfReal
+// Purpose  : gets amount of bytes used for storing float variable in FORT21 file
+//=============================================================================
+inline static int getSizeOfReal(Platform thePlatform)
+{
+  return thePlatform == Unix_64f77 || thePlatform == Linux_Tech ? 8 : 4;
+}
+
+//=============================================================================
+// Function : int ToInt
+// Purpose  :
+//=============================================================================
+inline static int ToInt(const tbuff theBuff, const int theSize, const bool theIsBigEndian)
+{
+  int aRes;
+
+  // inverse buffer if necessary
+  if (theIsBigEndian)
+  {
+    if (theSize == 8)
+    {
+      aRes = inverse(theBuff).Lo;
+    }
+    else
+      aRes = InverseInt(theBuff.Lo);
+  }
+  else
+    aRes = theBuff.Lo;
+
+  return aRes;
+}
+
+//=============================================================================
+// Function : inverseReal
+// Purpose  :
+//=============================================================================
+inline double MyInverseReal(const double& theValue)
+{
+  double aResult;
+  int* i = (int*)&theValue;
+  int* j = (int*)&aResult;
+  j[1] = InverseInt(i[0]);
+  j[0] = InverseInt(i[1]);
+  return aResult;
+}
+
+//================================================================
+// Function : ToReal
+// Purpose  : Convert real variable (stored in double theBuff) to
+//            double in accordance with parameters of given platform
+//================================================================
+inline static double ToReal(const tbuff theBuff, const int theSize, const bool theIsBigEndian)
+{
+#ifdef WNT
+  // disable all floating point exceptions
+  unsigned int oldx87mask = _control87(MCW_EM, MCW_EM);
+#elif defined(__APPLE__)
+ feclearexcept(FE_ALL_EXCEPT);
+#else
+  fedisableexcept(FE_ALL_EXCEPT);
+#endif
+
+  double aRes = DBL_MAX;
+  // inverse buffer if necessary
+  if (theIsBigEndian)
+  {
+    if (theSize == 8)
+    {
+      const double* val = (const double*)(&theBuff);
+      aRes = MyInverseReal(*val);
+      // aRes = MyInverseReal( (const double&)(theBuff) );
+    }
+    else if (theSize == 4)
+    {
+      // Function can crash during conversation from Nan to float,
+      // so make conversion right here before check result value
+      // float aResult = InverseShortReal( *(float*) &theBuff );
+      int* j = (int*)&theBuff;
+      float aResult;
+      int* i = (int*)&aResult;
+      *i = InverseInt(*j);
+#ifndef WNT
+#if defined(__APPLE__)
+      if (!isnan(aResult) && !isinf(aResult))
+#else
+      // Verification performed for Linux platform only because isnan method works
+      // with float and double on this platform. On WNT _isnan method works with double
+      // argument only. In this case assignement NAN float calue to double leads exception.
+      // To avoid this GUITHARE mask floating point exceptions.
+      if (!__isnanf(aResult) && !__isinf(aResult))
+#endif
+#endif
+        aRes = aResult;
+    }
+  }
+  else
+  {
+    if (theSize == 8)
+    {
+      const double* val = (const double*)&theBuff;
+      aRes = *(val);
+    }
+    else if (theSize == 4)
+    {
+      const float* val = (const float*)&theBuff;
+      aRes = *(val);
+    }
+  }
+
+#ifdef WNT
+  _control87(oldx87mask, MCW_EM);
+#endif
+  return aRes;
+}
+
+//=============================================================================
+// Function : float ToFloat
+// Purpose  :
+//=============================================================================
+/* inline static float ToFloat(const tbuff theBuff, const int theSize, const bool theIsBigEndian)
+{
+  double aVal = ToReal(theBuff, theSize, theIsBigEndian);
+
+  if (aVal > FLT_MAX)
+    return FLT_MAX;
+  else if (aVal < -FLT_MAX)
+    return FLT_MIN;
+  else
+    return (float)aVal;
+} */
+
+//=============================================================================
+// Function : ReaderFORT21
+// Purpose  :
+//=============================================================================
+ReaderFORT21::ReaderFORT21(int v)
+{
+  myStatus = NotDone;
+  myRealSize = 4;
+  myMaxSizeInt = 100000000;
+  myIsC3 = false;
+  myIsSimpleReal = true;
+  verbosity_ = v;
+}
+
+//=============================================================================
+// Function : ~ReaderFORT21
+// Purpose  :
+//=============================================================================
+ReaderFORT21::~ReaderFORT21()
+{
+}
+
+//=============================================================================
+// Function : setFile
+// Purpose  :
+//=============================================================================
+void ReaderFORT21::setFile(const std::string& theName)
+{
+  myInFile = theName;
+  // reset previous read
+  Times_glob_.clear();
+  offset_a_time_.clear();
+  elements_list_.clear();
+
+}
+
+//=============================================================================
+// Function : TruncTailWS
+// Purpose  : Truncates the trailing white-space in the string of given size
+//=============================================================================
+inline void TruncTailWS(char* theStr, int theSize)
+{
+  int i = theSize - 1;
+  while (i > -1 && (theStr[i] == ' ' || theStr[i] == 0))
+    i--;
+  theStr[i + 1] = 0;
+}
+
+//=============================================================================
+// Function : getStatus
+// Purpose  :
+//=============================================================================
+ReaderFORT21::Status ReaderFORT21::getStatus() const
+{
+  return myStatus;
+}
+
+//=============================================================================
+// Function : setPlatform
+// Purpose  :
+//=============================================================================
+void ReaderFORT21::setPlatform(const Platform thePlatform)
+{
+  myField.setPlatform(thePlatform);
+}
+
+//=======================================================================
+// function : parse
+// purpose  : parses the file
+//=======================================================================
+void ReaderFORT21::parse()
+{
+  //#define _TIMER
+#ifdef _TIMER
+  OSD_Timer aTimer;
+  aTimer.Start();
+#endif
+
+  myStatus = Fail;
+
+  // open the file
+  FILE* aFile = open_file(myInFile.c_str(), "rb");
+  if (aFile == 0)
+  {
+    std::cerr << " error while opening " << myInFile << std::endl;
+    exit(-1);
+    return;
+  }
+
+  myField.setFile(aFile);
+  myField.setMaxFileInt(myMaxSizeInt);
+
+  // read records
+  if (!myField.read(24))
+    return;
+
+  myStatus = Done;
+  while (myField.size() != 0)
+  {
+    if (!readRecord())
+    {
+      std::cerr << " error while reading " << myInFile << std::endl;
+      exit(-1);
+      return;
+    }
+  }
+
+#ifdef _TIMER
+  aTimer.Stop();
+  std::ofstream stream("D:/a.txt", std::ofstream::out);
+  aTimer.Show(stream);
+#endif
+}
+void ReaderFORT21::fix_bad_times()
+{
+  double told=-1;
+  bool repair=false;
+  unsigned int i=0;
+  for (; i<getTimes().size(); i++)
+  {
+    double t = getTimes()[i];
+    if (t==told) {
+      //std::cout <<"t == told == " << t<<std::endl;
+      repair=true;
+      break;
+    }
+    told=t;
+  }
+  if (repair)
+  {
+    // on doit fusionner i et i-1
+    // on garde le premier enregistrement du champ
+    std::cout<< " removing duplicate times "<<told<<std::endl;
+    for (auto& a : elements_list_)
+    {
+      auto& myvector=	a.second.index_times_;
+      auto     it = find (myvector.begin(), myvector.end(), i);
+      if (it != myvector.end())
+      {
+        auto     itold = find (myvector.begin(), myvector.end(), i-1);
+        if (itold==myvector.end())
+        {
+          // on n'avait pas le temps d'avant
+          throw;
+        }
+        else
+        {
+          //a.second.offset_rel_time_[a.second.offset_rel_time_.begin()+(it-myvector.begin())]+=offset_a_time_[i]-offset_a_time_[i-1];
+          //a.second.offset_rel_time_[(itold-myvector.begin())]=a.second.offset_rel_time_[(it-myvector.begin())]+offset_a_time_[i]-offset_a_time_[i-1];
+          a.second.offset_rel_time_.erase(a.second.offset_rel_time_.begin()+(it-myvector.begin()));
+          myvector.erase(it);
+        }
+
+      }
+    }
+    for (auto& a : elements_list_)
+    {
+      std::vector<int>& myvector=	a.second.index_times_;
+
+      for (auto& c : myvector)
+      {
+        if (c>int(i)) c--;
+      }
+    }
+    Times_glob_.erase(Times_glob_.begin()+i);
+    offset_a_time_.erase(offset_a_time_.begin()+i);
+    fix_bad_times();
+  }
+  for (unsigned int e=0; e<getTimes().size(); e++)
+  {
+    bool found =false;
+    for (auto& a : elements_list_)
+    {
+      auto& myvector=	a.second.index_times_;
+      auto     it = find (myvector.begin(), myvector.end(), e);
+      if (it != myvector.end())
+      {
+        if (verbosity_>5) std::cout << "time "<<e <<" found in "<<a.first<<std::endl;
+        found = true;
+        break;
+      }
+      if (found) break;
+
+    }
+    if (!found)
+      std::cout<< "time "<<e <<" no found " <<std::endl;
+  }
+}
+
+const ReaderFORT21::ElementInfo& ReaderFORT21::getElementInfo(const std::string& name_stack) const
+{
+  for (auto search = elements_list_.find(name_stack); search != elements_list_.end(); search++)
+  {
+    return search->second;
+  }
+  throw std::invalid_argument(name_stack+" not found");
+}
+std::vector<double> ReaderFORT21::getTimesStack(const std::string& name_stack) const
+{
+  std::vector<double> times;
+  const ElementInfo& eleminfo = getElementInfo(name_stack);
+  for (int i : eleminfo.index_times_)
+  {
+    times.push_back(Times_glob_[i]);
+  }
+  return times;
+}
+/*
+std::vector<int> ReaderFORT21::getTimesIndexStack(const std::string& name_stack) const
+{
+
+  const ElementInfo& eleminfo = getElementInfo(name_stack);
+  return  eleminfo.index_times_;
+}
+*/
+std::vector<std::string> ReaderFORT21::getElementNames() const
+{
+  std::vector<std::string> res;
+  for (auto& e : elements_list_)
+    res.push_back(e.first);
+
+  return res;
+}
+std::string ReaderFORT21::getElementType(const std::string& name_stack) const
+{
+  const ElementInfo& eleminfo = getElementInfo(name_stack);
+  return eleminfo.type_;
+}
+const ReaderFORT21::FieldInfo& ReaderFORT21::getVarFieldInfo(const std::string& name_stack, const std::string& name_field) const
+{
+  return getVarFieldInfo(getElementInfo(name_stack), name_field);
+}
+const ReaderFORT21::FieldInfo& ReaderFORT21::getConstFieldInfo(const std::string& name_stack, const std::string& name_field) const
+{
+  return getConstFieldInfo(getElementInfo(name_stack), name_field);
+}
+const ReaderFORT21::FieldInfo& ReaderFORT21::getVarFieldInfo(const ElementInfo& eleminfo, const std::string& name_field) const
+{
+  for (auto f = eleminfo.VarFields_.find(name_field); f != eleminfo.VarFields_.end(); f++)
+  {
+    return f->second;
+  }
+  throw std::invalid_argument(name_field+ " No such var");
+}
+const ReaderFORT21::FieldInfo& ReaderFORT21::getConstFieldInfo(const ElementInfo& eleminfo, const std::string& name_field) const
+{
+  for (auto f = eleminfo.ConstFields_.find(name_field); f != eleminfo.ConstFields_.end(); f++)
+  {
+    return f->second;
+  }
+  throw std::invalid_argument(name_field + " No such const");
+}
+std::vector<std::string> ReaderFORT21::getVarFieldNames(const std::string& name_stack) const
+{
+  const ElementInfo& eleminfo = getElementInfo(name_stack);
+  std::vector<std::string> res;
+  for (auto& e : eleminfo.VarFields_)
+    res.push_back(e.first);
+  return res;
+}
+std::vector<std::string> ReaderFORT21::getConstFieldNames(const std::string& name_stack) const
+{
+  const ElementInfo& eleminfo = getElementInfo(name_stack);
+  std::vector<std::string> res;
+  for (auto& e : eleminfo.ConstFields_)
+    res.push_back(e.first);
+  return res;
+}
+file_pos_t ReaderFORT21::getOffsetVarField(const std::string& name_stack, const std::string& name_field, const int& id_time_field) const
+{
+
+  const ElementInfo& eleminfo = getElementInfo(name_stack);
+  const FieldInfo& fieldinfo = getVarFieldInfo(eleminfo, name_field);
+  int id_time = eleminfo.index_times_.at(id_time_field);
+  file_pos_t fp = offset_a_time_.at(id_time) + eleminfo.offset_rel_time_.at(id_time_field) + fieldinfo.offset_rel_stack_;
+  return fp;
+}
+
+template <typename _TYPE_> void ReaderFORT21::getValuesVarField(const std::string& name_stack, const std::string& name_field, std::vector<_TYPE_>& data, const int& id_time_field) const
+{
+  const ElementInfo& eleminfo = getElementInfo(name_stack);
+  const FieldInfo& fieldinfo = getVarFieldInfo(eleminfo, name_field);
+  data.resize(fieldinfo.size_*fieldinfo.nb_parts());
+  /* int aSize = (myIsSimpleReal && aSizeOfReal == 4) ? 4 : 8;
+   int typi = fieldinfo.type;
+     ...
+
+  if (aSize!=4) {
+      throw std::invalid_argument("not implemented");
+  }
+  */
+  if (fieldinfo.type_of_field()== T_INT)
+  {
+    if(!std::is_same<_TYPE_, int>::value) {
+      throw std::invalid_argument("field int , data no");
+    }
+  }
+  else if (fieldinfo.type_of_field()== T_REAL)
+  {
+    if(!std::is_same<_TYPE_, float>::value) {
+      throw std::invalid_argument("field float , data no");
+    }
+  }
+  else
+    throw std::invalid_argument("field type not implemented");
+
+  size_t aSizeOfRecordLength = fieldinfo.size() * sizeof(_TYPE_);
+  file_pos_t fp = getOffsetVarField(name_stack,name_field,id_time_field) ; //offset_a_time_.at(id_time) + eleminfo.offset_rel_time_.at(id_time_field) + fieldinfo.offset_rel_stack_;
+  set_file_pos(myField.getFile(), fp, SEEK_SET);
+  if (fread(data.data(), aSizeOfRecordLength, 1, myField.getFile()) != 1)
+    throw std::invalid_argument("error reading");
+  for (int p=2; p<=fieldinfo.nb_parts(); p++)
+  {
+    std::string nn = name_field+"_p"+std::to_string(p);
+    file_pos_t fp2 = getOffsetVarField(name_stack,nn,id_time_field) ; //offset_a_time_.at(id_time) + eleminfo.offset_rel_time_.at(id_time_field) + fieldinfo.offset_rel_stack_;
+    set_file_pos(myField.getFile(), fp2, SEEK_SET);
+    //std::cout<<p << " "<<(p-1)*fieldinfo.size()<< "iuuu  "<<data.data()[(p-1)*data.size()]<< std::endl;
+    if (fread(data.data()+(p-1)*fieldinfo.size(), aSizeOfRecordLength, 1, myField.getFile()) != 1)
+      throw std::invalid_argument("error reading");
+  }
+}
+
+template <typename _TYPE_> 
+void ReaderFORT21::getInterpolatedValuesVarField(const std::string& name_stack, const std::string& name_field, std::vector<_TYPE_>& data, const int& global_id_time) const
+{
+ 
+ std::vector<double> stak_times = getTimesStack(name_stack); 
+ double global_time = Times_glob_[global_id_time];
+ std::vector<double>::iterator it = std::find_if(stak_times.begin(),stak_times.end(),[global_time](double b) { return global_time<=b; });  
+ int index = int( std::distance(stak_times.begin(), it));
+ getValuesVarField(name_stack, name_field,data, index);
+}
+
+template <typename _TYPE_> void ReaderFORT21::getValuesConstField(const std::string& name_stack, const std::string& name_field, std::vector<_TYPE_>& data) const
+{
+  const ElementInfo& eleminfo = getElementInfo(name_stack);
+  const FieldInfo& fieldinfo = getConstFieldInfo(eleminfo, name_field);
+  if (fieldinfo.nb_parts()!=1)
+    throw std::invalid_argument("nb_parts!=1 not implemented for const field "+ name_field);
+  data.resize(fieldinfo.size_);
+  file_pos_t fp = fieldinfo.offset_rel_stack_;
+  /* int aSize = (myIsSimpleReal && aSizeOfReal == 4) ? 4 : 8;
+
+  if (aSize!=4) {
+      throw std::invalid_argument("not implemented");
+  }
+  */
+  if (fieldinfo.type_of_field()== T_INT)
+  {
+    if(!std::is_same<_TYPE_, int>::value) {
+      throw std::invalid_argument("field int , data no");
+    }
+  }
+  else if (fieldinfo.type_of_field()== T_REAL)
+  {
+    if(!std::is_same<_TYPE_, float>::value) {
+      throw std::invalid_argument("field float , data no");
+    }
+  }
+  else
+    throw std::invalid_argument("field type not implemented");
+
+  set_file_pos(myField.getFile(), fp, SEEK_SET);
+  size_t aSizeOfRecordLength = data.size() * sizeof(_TYPE_);
+  if (fread(data.data(), aSizeOfRecordLength, 1, myField.getFile()) != 1)
+    throw std::invalid_argument("error reading");
+}
+
+//=======================================================================
+// function : readRecord
+// purpose  :
+//=======================================================================
+
+bool ReaderFORT21::readRecord()
+{
+  if (!readHeader())
+    return false;
+
+  if (!readDescr())
+    return false;
+  //  unsigned int nbVarias = 0;
+  while (readVaria());
+  //  nbVarias++;
+
+  return myStatus == Done;
+}
+
+//=======================================================================
+// function : readHeader
+// purpose  :
+//=======================================================================
+
+bool ReaderFORT21::readHeader()
+{
+  // read first field - TYPE
+  if (myField.size() == 0)
+  {
+    if (!myField.read(24))
+    {
+      myStatus = Fail;
+      return false;
+    }
+  }
+
+  char* aData = myField.getData();
+  if (strncmp(aData, "TYPE$$$$", 8) != 0)
+  {
+    // std::cout<<aData<<std::endl;
+    myStatus = Fail;
+    return false;
+  }
+
+  // get real variable type (SIMPLE or DOUBLE)
+  aData += 16;
+  aData[6] = 0;
+  if (strcmp(aData, "SIMPLE") == 0)
+  {
+    myIsSimpleReal = true;
+    myRealSize = 4;
+  }
+  else if (strcmp(aData, "DOUBLE") == 0)
+  {
+    myIsSimpleReal = false;
+    myRealSize = 8;
+  }
+  else
+  {
+    myStatus = Fail;
+    return false;
+  }
+
+  // skip a next field
+  if (!myField.read(24))
+  {
+    myStatus = Fail;
+    return false;
+  }
+
+  // read IDENT field
+  if (!myField.read(184))
+  {
+    myStatus = Fail;
+    return false;
+  }
+
+  // get date of calculation
+  aData = myField.getData() + 8;
+  char aDate[18];
+  strncpy(aDate, aData, 8);
+
+  // get CATHARE version
+  char aBuf[100];
+  strncpy(aBuf, aData + 8, 80);
+  TruncTailWS(aBuf, 80);
+
+  // IsC3()
+  std::string aStr(aBuf);
+  myIsC3 = find(aStr, "c3") >= 0;
+
+  // get title of calculation
+  strncpy(aBuf, aData + 88, 80);
+  TruncTailWS(aBuf, 80);
+
+  // get time of calculation
+  strncpy(aDate + 9, aData + 168, 8);
+  aDate[8] = ' ';
+  aDate[17] = 0;
+  // change spaces to '0'
+  char* p = aDate;
+  while (*p != 0)
+  {
+    if (*p == ' ')
+      *p = '0';
+    p++;
+  }
+  aDate[8] = ' ';
+
+  myField.clear();
+  return true;
+}
+
+//=======================================================================
+// function : readDescr
+// purpose  :
+//=======================================================================
+
+bool ReaderFORT21::readDescr()
+{
+  // read DESCR field
+  if (myField.size() == 0)
+  {
+    if (!myField.read(8))
+    {
+      myStatus = Fail;
+      return false;
+    }
+  }
+  char* aData = myField.getData();
+  if (strncmp(aData, "DESCR$$$", 8) != 0)
+  {
+    myStatus = Fail;
+    return false;
+  }
+#ifdef DEB_PRINT
+  cout << "Objects description:" << endl;
+#endif
+  myField.clear();
+
+  // skip DESSTACK blocks
+  // while(readDesStack(true))
+  while (readDesStack(false))
+  {
+    // to do: exit from loop
+  }
+
+  return myStatus == Done;
+}
+
+//=======================================================================
+// function : readVaria
+// purpose  :
+//=======================================================================
+
+bool ReaderFORT21::readVaria()
+{
+  // read VARIA field
+  if (myField.size() == 0)
+  {
+    if (!myField.read())
+      return false;
+  }
+
+  char* aData = myField.getData();
+  if (strncmp(aData, "VARIA$$$", 8) != 0)
+    return false;
+
+  // read timestamp
+  if (!myField.read(16))
+  {
+    myStatus = Fail;
+    return false;
+  }
+  // double aTime = *(double*) (myField.getData() + 8);
+
+  const bool isBigEndian = IsBigEndian(myField.getPlatform()) ? true : false;
+
+  tbuff aBuff;
+  memcpy(&aBuff, myField.getData() + 8, 8);
+  double aTime = ToReal(aBuff, 8, isBigEndian);
+  // int nb_fields_read_sa=nb_fields_read;
+
+  // try first DESSTACK block to check if timestamp is not empty
+  if (!myField.read(8))
+    return true;
+
+  aData = myField.getData();
+  if (strncmp(aData, "DESSTACK", 8) != 0)
+    return true;
+
+  // save timestamp
+  Times_glob_.push_back(aTime);
+  file_pos_t aPos0 = get_file_pos(myField.getFile());
+  offset_a_time_.push_back(aPos0);
+
+  // read all DESSTACK blocks for the current timestamp
+  while (readDesStack(false))
+  {
+  }
+
+  return true;
+}
+
+//=======================================================================
+// function : readDesStack
+// purpose  :
+//=======================================================================
+bool ReaderFORT21::readDesStack(bool theSkip)
+{
+  int aNameSize = myIsC3 ? 16 : 8;
+
+  // read DESSTACK field
+  if (myField.size() == 0)
+  {
+    if (!myField.read())
+      return false;
+  }
+
+  int aSizeOfRecordLength = getSizeOfRecordLength(myField.getPlatform());
+  const int aSizeOfLong = getSizeOfLong(myField.getPlatform());
+  const int aSizeOfReal = getSizeOfReal(myField.getPlatform());
+
+  const bool isBigEndian = IsBigEndian(myField.getPlatform()) ? true : false;
+
+  if (!myIsSimpleReal && aSizeOfReal > 4)  // not supported
+    return false;
+
+  char* aData = myField.getData();
+  if (strncmp(aData, "DESSTACK", 8) != 0)
+  {
+    return false;
+  }
+
+  file_pos_t aPos0 = get_file_pos(myField.getFile());
+  // read name and type of object
+  // Record length = Name(8 or 16) + Type(8 or 16) + 4*LongValue
+  if (!myField.read(aNameSize * 2 + aSizeOfLong * 4))
+  {
+    myStatus = Fail;
+    return false;
+  }
+  file_pos_t decpos = get_file_pos(myField.getFile()) - aPos0;
+
+  aData = myField.getData();
+  char aName[MAX_NAME_SIZE + 1];
+  char aTypeC[MAX_NAME_SIZE + 1];
+
+  strncpy(aName, aData, aNameSize);
+  TruncTailWS(aName, aNameSize);
+  std::string anAsciiName(aName);
+  // anAsciiName.uppercase();
+  std::transform(anAsciiName.begin(), anAsciiName.end(), anAsciiName.begin(), ::toupper);
+  bool constPart = true;
+
+  /*    if (elements_list_.count(anAsciiName)==0)
+      {
+          elements_list_[anAsciiName]=ElementInfo();
+      }
+      */
+  ElementInfo& eleminfo = elements_list_[anAsciiName];
+  int current_index_time = int(Times_glob_.size()) - 1;
+  file_pos_t offsetelem = -1;
+  if (current_index_time >= 0)
+  {
+    constPart = false;
+    // stack info already read ?
+    eleminfo.index_times_.push_back(current_index_time);
+    offsetelem = aPos0;
+    eleminfo.offset_rel_time_.push_back(aPos0 - offset_a_time_[current_index_time]);
+    /*
+    for (auto& search=element_sizeblock_.find(anAsciiName); search != element_sizeblock_.end();search++)
+    {
+     set_file_pos(myField.getFile() , search->second-(decpos),SEEK_CUR);
+        //file_pos_t aPos1 = get_file_pos( myField.getFile() );
+    */
+    if (eleminfo.sizeblock_ != -1)
+    {
+      set_file_pos(myField.getFile(), eleminfo.sizeblock_ - (decpos), SEEK_CUR);
+      myField.clear();
+      return true;
+    }
+  }
+
+  strncpy(aTypeC, aData + aNameSize, aNameSize);
+  TruncTailWS(aTypeC, aNameSize);
+  std::string aType(aTypeC);
+  eleminfo.type_ = aType;
+  /*
+    int aTypeId = 0;
+    hid_t aGrpId = getObjGrp( anAsciiName, aType );
+    if ( aGrpId <= 0 )
+      return false;
+  */
+  // numeration from one
+  // int aTimeStep =  myTimes.size() > 0 ? myTimes.size() : 1;
+
+  // open or craete group
+
+  // get numbers of variables of each type among
+  // pointers, integers, reals and characters
+  int aNbVar[4], nbVars;
+  int i;
+  for (i = 0; i < 4; i++)
+  {
+    tbuff aBuff;
+    memcpy(&aBuff, aData + aNameSize * 2 + i * aSizeOfLong, 8);
+    aNbVar[i] = ToInt(aBuff, aSizeOfLong, isBigEndian);
+  }
+
+  nbVars = aNbVar[0] + aNbVar[1] + aNbVar[2] + aNbVar[3];
+
+  // read dimensions of variables
+  if (!myField.read(8 + nbVars * aSizeOfLong))
+  {
+    myStatus = Fail;
+    return false;
+  }
+
+  aData = myField.getData();
+
+  int aDimVar[MAX_NUM_VARS];
+  for (i = 0; i < nbVars; i++)
+  {
+    tbuff aBuff;
+    memcpy(&aBuff, aData + 8 + i * aSizeOfLong, 8);
+    aDimVar[i + 1] = ToInt(aBuff, aSizeOfLong, isBigEndian);
+  }
+
+  char aQNameC[MAX_NAME_SIZE + 1];
+  // read variables
+  int ct;
+  long posdata = -1;
+  for (i = 1, ct = 0; ct < 4; ct++)
+  {
+    std::string loc ( "UNKONWN");
+    LocalisationField locfield = LocalisationField::L_UNDEF;
+    std::string add("");
+    FieldInfo fieldinfo;
+    CathareType catType = (CathareType)ct;
+
+    for (int n = aNbVar[catType]; n > 0; n--, i++)
+    {
+      posdata = ftell(myField.getFile()) + aNameSize + aSizeOfRecordLength;
+      //	std::cout<<"aPos0 "<< ftell( myField.getFile())+aNameSize+aSizeOfRecordLength<< std::endl;
+      if (!myField.read())
+      {
+        myStatus = Fail;
+        return false;
+      }
+
+      if (theSkip)
+        continue;
+
+      /*if (catType != T_INT && catType != T_REAL)
+        continue;
+      */
+
+      aData = myField.getData();
+      strncpy(aQNameC, aData, aNameSize);
+      TruncTailWS(aQNameC, aNameSize);
+      std::string aQName(aQNameC);
+      fieldinfo.type_of_field_ = catType;
+      int nbPnt = aDimVar[i];
+      if (nbPnt==1)
+      {
+        if (aQName=="GLOBAL")
+        {
+          loc=aQName;
+	  locfield=LocalisationField::L_GLOBAL;
+          continue;
+	}
+	if ((aQName=="SCALAR")||(aQName=="SUBVOL")||(aQName=="VECTZ")||(aQName=="ZS")||(aQName=="ZSW"))
+        {
+          loc=aQName;
+	  locfield=LocalisationField::L_ELEM;
+          continue;
+        }
+        // cas particulier ZV marqueur et variable !!!!
+        if ((aQName=="ZV"))
+        {
+          loc=aQName;
+	  locfield=LocalisationField::L_DUAL;
+          continue;
+        }
+        if ((aQName=="VECTZ"))
+        {
+          loc=aQName;
+	  locfield=LocalisationField::L_DUAL;
+          continue;
+        }
+        if (aQName=="SUBVOLINF")
+        {
+          //add="_INF";
+          loc=aQName;
+	  locfield=LocalisationField::L_ELEM;
+          continue;
+        }
+        if (aQName=="SUBVOLSUP")
+        {
+          //add="_SUP";
+          loc=aQName;
+	  locfield=LocalisationField::L_ELEM;
+          continue;
+        }
+      }
+      /*
+      if (fieldinfo.type_of_field_==T_INT)
+      {
+        aQName+="_INT";
+      }
+      */
+      aQName+=add;
+      if (nbPnt == 0)
+        throw;
+      fieldinfo.size_ = nbPnt;
+      fieldinfo.nb_parts_=1;
+      fieldinfo.localisation_of_field_= locfield;
+      if (constPart)
+      {
+        fieldinfo.offset_rel_stack_ = posdata ;
+        if (eleminfo.ConstFields_.count(aQName)>0)
+        {
+          std::cout << aQName<< " already a const field of "<<anAsciiName << std::endl;
+          throw;
+        }
+        eleminfo.ConstFields_[aQName] = fieldinfo;
+      }
+      else
+      {
+        fieldinfo.offset_rel_stack_ = posdata - offsetelem;
+        if (eleminfo.VarFields_.count(aQName)>0)
+        {
+
+          int nbpartsold=eleminfo.VarFields_[aQName].nb_parts_;
+          if (nbpartsold==1)
+          {
+            // on ajoute  p1
+            std::string aQNamep1= aQName + std::string("_p1");
+            eleminfo.VarFields_[aQNamep1]=eleminfo.VarFields_[aQName];
+
+          }
+          eleminfo.VarFields_[aQName].nb_parts_++;
+
+          aQName+= std::string("_p")+std::to_string(nbpartsold+1);
+          if (verbosity_ > 3)
+            std::cout<< aQName<< " already a var field of "<<anAsciiName << std::endl;
+        }
+        eleminfo.VarFields_[aQName] = fieldinfo;
+      }
+    }
+  }
+  myField.clear();
+  file_pos_t aPos1 = get_file_pos(myField.getFile());
+  if (!constPart)
+  {
+    eleminfo.sizeblock_ = aPos1 - aPos0;
+    if (verbosity_ > 5)
+      std::cout << anAsciiName << " taille bloc " << eleminfo.sizeblock_ << std::endl;
+  }
+
+  return true;
+}
+
+//=======================================================================
+// function : Field::Read
+// purpose  :
+//=======================================================================
+
+bool ReaderFORT21::Field::read(int theSize)
+{
+  if (myFile == 0)
+    return false;
+  mySize = 0;
+  // read size
+  tbuff aBuff;
+
+  int aSizeOfRecordLength = getSizeOfRecordLength(myPlatform);
+  const bool isBigEndian = IsBigEndian(myPlatform) ? true : false;
+
+  if (fread(&aBuff, aSizeOfRecordLength, 1, myFile) != 1)
+    return false;
+
+  myFPos += aSizeOfRecordLength;
+
+  int aSize = ToInt(aBuff, aSizeOfRecordLength, isBigEndian);
+  // size_t aSize = ToInt( aBuff, mySizeOfRecordLength, myIsBigEndian );
+  // additional safety control against garbage data,
+  // if the size is known beforehand
+  if ((theSize > 0 && aSize != theSize) || aSize < 0 || aSize > myMaxSizeInt)
+  {
+    std::cout << " KO " << theSize << std::endl;
+    return false;
+  }
+  if (aSize > myCapacity)
+  {
+    // resize myData
+    if (myData != 0)
+      delete[] myData;
+    myCapacity = 0;
+    myData = new char[aSize + 4];
+    if (myData == 0)
+      return false;
+    myCapacity = aSize;
+    myData[myCapacity] = 0;
+  }
+  if (int(fread(myData, 1, aSize, myFile)) != aSize)
+    return false;
+
+  myFPos += aSize;
+
+  if (fread(&aBuff, aSizeOfRecordLength, 1, myFile) != 1)
+    return false;
+
+  myFPos += aSizeOfRecordLength;
+
+  mySize = ToInt(aBuff, aSizeOfRecordLength, isBigEndian);
+
+  // fread(&mySize, mySizeOfLength, 1, myFile);
+  // control check (hz may be should be removed)
+  if (aSize != mySize)
+  {
+    std::cout << " KO2 " << theSize << std::endl;
+    mySize = 0;
+    return false;
+  }
+  // std::cout<<" OK "<<theSize<<std::endl;
+  return true;
+}
+
+ReaderFORT21::BasicMesh::BasicMesh()
+  : type_mesh_(MESH_Unknown)
+  , mesh_dim_(0)
+  , space_dim_(0)
+  , nbnodes_(0)
+  , nodes_per_elem_(0)
+  , nb_elems_(0)
+  , connectivity_(0)
+  , coords_(0)
+{
+}
+
+ReaderFORT21::BasicMesh::~BasicMesh()
+{
+  clear();
+}
+
+void ReaderFORT21::BasicMesh::clear()
+{
+  connectivity_.resize(0);
+  coords_.resize(0);
+}
+
+void ReaderFORT21::BasicMesh::save(std::ostream& os) const
+{
+  //os << std::setprecision(12);
+  os << (int)type_mesh_ << std::endl;
+  os << mesh_dim_ << std::endl;
+  os << space_dim_ << std::endl;
+  os << nbnodes_ << std::endl;
+  os << nodes_per_elem_ << std::endl;
+  os << nb_elems_ << std::endl;
+
+  for (int i = 0; i < nb_elems_; i++)
+  {
+    for (int j = 0; j < nodes_per_elem_; j++)
+      os << " " << connectivity_[i * nodes_per_elem_ + j];
+    os << std::endl;
+  }
+
+  for (int i = 0; i < nbnodes_; i++)
+  {
+    for (int j = 0; j < space_dim_; j++)
+      os << " " << coords_[i * space_dim_ + j];
+    os << std::endl;
+  }
+}
+
+void ReaderFORT21::BasicMesh::restore(std::istream& in)
+{
+  std::string name;
+  in >> name;
+  int int_type_mesh;
+  in >> int_type_mesh;
+  type_mesh_=(MeshType)int_type_mesh;
+  in >> mesh_dim_;
+  in >> space_dim_;
+  in >> nbnodes_;
+  in >> nodes_per_elem_;
+  in >> nb_elems_;
+
+  connectivity_.resize(nodes_per_elem_ * nb_elems_);
+  for (int i = 0; i < nb_elems_; i++)
+  {
+    for (int j = 0; j < nodes_per_elem_; j++)
+      in >> connectivity_[i * nodes_per_elem_ + j];
+  }
+  coords_.resize(nbnodes_ * space_dim_);
+  for (int i = 0; i < nbnodes_; i++)
+  {
+    for (int j = 0; j < space_dim_; j++)
+      in >> coords_[i * space_dim_ + j];
+  }
+}
+
+void ReaderFORT21::BasicMesh::dummy_geom()
+{
+  type_mesh_ = MESH_Unknown;
+  mesh_dim_ = 2;
+  space_dim_ = 2;
+  nbnodes_ = 4;
+  nodes_per_elem_ = 4;
+  nb_elems_ = 1;
+  connectivity_.resize(nb_elems_ * nodes_per_elem_);
+  connectivity_[0] = 0;
+  connectivity_[1] = 1;
+  connectivity_[2] = 2;
+  connectivity_[3] = 3;
+  coords_.resize(nbnodes_ * space_dim_);
+  coords_[0] = 0;
+  coords_[1] = 0;
+  coords_[2] = 1;
+  coords_[3] = 0;
+  coords_[4] = 1;
+  coords_[5] = 1;
+  coords_[6] = 0;
+  coords_[7] = 1;
+}
+
+/// @brief Return the image of a point at (x0 + dx, y0 + dy) due to a rotation expressed as \p cos and \p sin around the
+/// center at (x0, y0)
+void rotate(const double& dx, const double& dy, const double& x0, const double& y0,
+            const double& cos, const double& sin, double& xn, double& yn)
+{
+  xn = x0 + cos * dx + sin * dy;
+  yn = y0 - sin * dx + cos * dy;
+}
+ReaderFORT21::BasicMesh ReaderFORT21::getMeshStack(const std::string& name_stack) const
+{
+  const ElementInfo& eleminfo = getElementInfo(name_stack);
+  ReaderFORT21::BasicMesh mesh;
+#define nodes_(i,j) mesh.coords_[(i)*mesh.space_dim_+j]
+#define elements_(i,j) mesh.connectivity_[(i)*mesh.nodes_per_elem_ + j]
+  if (eleminfo.type_ == "AXIALRAV")
+  {
+    const FieldInfo& fieldinfo = getConstFieldInfo(eleminfo, "ZV");
+    mesh.nb_elems_ = fieldinfo.size_ - 1;
+    std::vector<float> data;
+    getValuesConstField(name_stack,  "ZV",  data) ;
+    // for (float x : data)
+    // std::cout<<"ZV " << x<<std::endl;
+    std::vector<float>           gs,spf,zv;
+    float gz;
+    getValuesConstField(name_stack,  "GSREF",gs);
+    getValuesConstField(name_stack,  "SPF",spf);
+    getValuesConstField(name_stack,  "ZV",zv);
+    if (eleminfo.ConstFields_.count("GZ")>0)
+    {
+      std::vector<float> tmp;
+      getValuesConstField(name_stack,  "GZ",tmp);
+      gz=std::abs(tmp[0]);
+    }
+    else
+      gz=9.81f;
+
+
+    int NT=int (zv.size());
+    int nbelem=NT-1;
+    mesh.nb_elems_=nbelem;
+    mesh.space_dim_ = 2;
+    mesh.mesh_dim_=2;
+    mesh.nbnodes_=4*nbelem;
+    mesh.coords_.resize(4*nbelem*2);
+    mesh.connectivity_.resize(nbelem*4);
+    mesh.space_dim_ =2;
+    mesh.nodes_per_elem_ = 4;
+    mesh.type_mesh_=MESH_Polygone;
+    double xold = 0;
+    double yold = zv[0];  // has to be 0.0
+    int n0=0;
+    for (int ele = 0; ele < nbelem; ele++)
+    {
+      const double dx0 = std::sqrt(spf[ele] / 3.1415926f);
+      const double dx1 = std::sqrt(spf[ele + 1] / 3.1415926f);
+      // std::cout << ele << " ZV " << ZV(ele) << " " << COSIN(ele) << " " << dx0 << " " << dx1 << std::endl;
+      const double cos = std::max(std::min(double(gs[ele]/gz),1.),-1.);
+      const double sin = std::sqrt(1. - cos * cos);
+      //
+      // for each cell:
+      //         ^ z
+      //  (2)    |(B)
+      //    +----+----+ (1)
+      //    |    .    |        1, 2, 3, 4: cell's contour
+      //    |    |    |        A: "old" which is the center of rotation
+      //   |     .     |       B: "old2" created after rotation, middle between (1) and (2), will become "old"
+      //   |     |(A)  |
+      //   +-----+-----+ (0)
+      //  (3)    |
+      //
+
+      rotate(dx0, 0., xold, yold, cos, sin,nodes_(n0+0,0),nodes_(n0+0,1));
+      rotate(dx1, zv[ele+1] - zv[ele], xold, yold, cos, sin,nodes_(n0+1,0),nodes_(n0+1,1));
+
+      rotate(-dx1, zv[ele+1] - zv[ele], xold, yold, cos, sin,nodes_(n0+2,0),nodes_(n0+2,1));
+      rotate(-dx0, 0., xold, yold, cos, sin,nodes_(n0+3,0),nodes_(n0+3,1));
+      // le nouveau old est entre 1 et 2
+      const double xold2 = (nodes_(n0+1,0)+nodes_(n0+2,0)) * 0.5f;
+      const double yold2 = (nodes_(n0+1,1)+nodes_(n0+2,1)) * 0.5f;
+
+      {
+        // control lenght of the cell (curvilinear axis): after rotation vs Cathare original data
+        const double ds_x = xold2 - xold;
+        const double ds_y = yold2 - yold;
+        if (std::abs(ds_x * ds_x + ds_y * ds_y - (zv[ele+1] - zv[ele]) * (zv[ele+1] - zv[ele])) > 1e-5)
+        {
+          std::cout << "Soucis coherence..." << ds_x * ds_x + ds_y * ds_y << " " << (zv[ele+1] - zv[ele]) * (zv[ele+1] - zv[ele])
+                    << " "<<std::abs(ds_x * ds_x + ds_y * ds_y - (zv[ele+1] - zv[ele]) * (zv[ele+1] - zv[ele]))
+                    << std::endl;
+          //abort();
+        }
+      }
+
+      xold = xold2;
+      yold = yold2;
+
+
+      elements_(ele,0)=n0;
+      elements_(ele,1)=n0+1;
+      elements_(ele,2)=n0+2;
+      elements_(ele,3)=n0+3;
+      n0+=4;
+    }
+  }
+  else if (eleminfo.type_ == "VOLUMRAV")
+  {
+    std::vector<float> cotes,diam;
+    getValuesConstField(name_stack,  "COTE",cotes);
+    getValuesConstField(name_stack,  "DIAMETER",diam);
+    int NT = int(diam.size());
+    mesh.nb_elems_=1;
+    mesh.space_dim_ = 2;
+    mesh.mesh_dim_=2;
+    mesh.nbnodes_=2*NT;
+    mesh.coords_.resize(2*NT*2,-1000.);
+    mesh.connectivity_.resize(1*2*NT,-1);
+    mesh.space_dim_ =2;
+    mesh.nodes_per_elem_ = 2*NT;
+    mesh.type_mesh_=MESH_Polygone;
+    for (int c = 0; c < NT; c++)
+    {
+      nodes_(c,0)= diam[c] * 0.5f;
+      nodes_(c,1)= cotes[c];
+      nodes_(2*NT- c - 1,0) = -nodes_(c,0);
+      nodes_(2*NT- c - 1,1) = nodes_(c,1);
+    }
+    for (int c = 0; c < 2*NT; c++)
+      elements_(0,c)=c;
+  }
+  else if  ((eleminfo.type_ == "WALVORAV")|| (eleminfo.type_ == "WALAXRAV"))
+  {
+
+    std::vector<float>  R;
+    std::vector<std::vector<float>> ri;
+    int nr=1;
+    while(1)
+    {
+      std::string ris("RAYON");
+      ris+=std::to_string(nr);
+      try {
+        getValuesConstField(name_stack,  ris,R);
+        ri.push_back(R);
+        nr++;
+
+      }
+      catch(...) {
+        break;
+      }
+    }
+    nr--;
+      std::vector<int> iwhyd;
+      getValuesConstField(name_stack,  "IWHYD",iwhyd);
+      int ncellhyd=int(iwhyd.size());
+      std::vector<float> zvw;
+    if  (eleminfo.type_ == "WALVORAV")
+    {
+      std::vector<float> zpmin,zpmax;
+      getValuesConstField(name_stack,  "ZPMIN",zpmin);
+      getValuesConstField(name_stack,  "ZPMAX",zpmax);
+      zvw.resize(ncellhyd+1);
+     for (int i=0;i<ncellhyd+1;i++) zvw[i]=zpmin[0]+float(i)*(zpmax[0]-zpmin[0])/float(ncellhyd+1);
+    }
+    else
+	 {
+      getValuesConstField(name_stack,  "ZVW",zvw);
+	 }
+    /*
+
+      int NT=nr-1;
+      mesh.nb_elems_=NT;
+      mesh.space_dim_ = 2;
+      mesh.mesh_dim_=2;
+      mesh.nbnodes_=4*NT;
+      mesh.coords_.resize(4*NT*2,-1000.);
+      mesh.connectivity_.resize(4*NT,-1);
+      mesh.nodes_per_elem_ = 4;
+      mesh.type_mesh_=MESH_Polygone;
+      for (int c = 0; c < NT; c++)
+      {
+        nodes_(4*c,0)= ri[c+1][0];
+        nodes_(4*c,1)= zpmin[0];
+        nodes_(4*c+1,0)= ri[c+1][0];
+        nodes_(4*c+1,1)= zpmax[0];
+        nodes_(4*c+2,0)= ri[c][0];
+        nodes_(4*c+2,1)= zpmax[0];
+        nodes_(4*c+3,0)= ri[c][0];
+        nodes_(4*c+3,1)= zpmin[0];
+        for (int i=0; i<4; i++)
+          elements_(c,i)=4*c+i;
+      }
+    }
+    else
+    {
+    */
+    {
+      int NT=(nr-1)*ncellhyd;
+      mesh.nb_elems_=NT;
+      mesh.space_dim_ = 2;
+      mesh.mesh_dim_=2;
+      mesh.nbnodes_=4*NT;
+      mesh.coords_.resize(4*NT*2,-1000.);
+      mesh.connectivity_.resize(4*NT,-1);
+      mesh.nodes_per_elem_ = 4;
+      mesh.type_mesh_=MESH_Polygone;
+      for (int m = 0; m < ncellhyd; m++)
+        for (int r = 0; r < nr-1; r++)
+        {
+          int m2=iwhyd[m]-1;
+          m2=m;
+          double sens=1;
+          //if (m>1) if (iwhyd[m]==iwhyd[m-1]) sens=-1;
+          int c=(r*ncellhyd+m);
+          nodes_(4*c,0)= sens*ri[r+1][m];
+          nodes_(4*c,1)= zvw[m2];
+          nodes_(4*c+1,0)= nodes_(4*c,0);
+          nodes_(4*c+1,1)= zvw[m2+1];
+          nodes_(4*c+2,0)= sens*ri[r][m];
+          nodes_(4*c+2,1)= nodes_(4*c+1,1);
+          nodes_(4*c+3,0)= nodes_(4*c+2,0);
+          nodes_(4*c+3,1)= nodes_(4*c,1);
+          for (int i=0; i<4; i++)
+            elements_(c,i)=4*c+i;
+        }
+    }
+
+  }
+  else if (eleminfo.type_ == "bidon")
+  {
+    // pour declencher instanciation des methodes
+    std::vector<float> data;
+    getValuesVarField(name_stack,  "ZV",  data,0) ;
+    std::vector<int> idata;
+    getValuesVarField(name_stack,  "ZV",  idata,0) ;
+  }
+  else
+  {
+    if (verbosity_ > 5)
+      std::cout<< eleminfo.type_ << " not implemented"<<std::endl;
+    mesh.dummy_geom();
+  }
+  return mesh;
+}
+
+template void ReaderFORT21::getInterpolatedValuesVarField(const std::string& name_stack, const std::string& name_field, std::vector<float>& data, const int& id_time_field) const;
diff --git a/Utilities/VisItBridge/databases/readers/Lata/ReaderFORT21.h b/Utilities/VisItBridge/databases/readers/Lata/ReaderFORT21.h
new file mode 100644
index 00000000..dc0bc268
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/ReaderFORT21.h
@@ -0,0 +1,366 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef ReaderFORT21_HeaderFile
+#define ReaderFORT21_HeaderFile
+
+#include <iostream>
+#include <fstream>
+#include <list>
+#include <map>
+#include <stdio.h>
+#include <string>
+#include <vector>
+
+#ifdef WNT
+  #define file_pos_t __int64
+  #define open_file fopen
+  #define get_file_pos _ftelli64
+  #define set_file_pos _fseeki64
+#elif defined( __APPLE__)
+  #define set_file_pos fseeko
+  #define open_file fopen
+  #define file_pos_t __int64_t
+  #define get_file_pos ftello
+#else
+  #define open_file fopen64
+  #define file_pos_t __off64_t
+  #define get_file_pos ftello64
+  #define set_file_pos fseeko64
+#endif
+
+/*
+static inline int findFromEnd( const std::string& theStr, const std::string& theWhat )
+{
+  size_t pos = theStr.find_last_of( theWhat );
+  if ( pos == std::string::npos )
+    pos = -1;
+  return int(pos);
+}
+*/
+
+static inline int find(const std::string& theStr, const std::string& theWhat)
+{
+  size_t pos = theStr.find(theWhat);
+  if (pos == std::string::npos)
+    return -1;
+  return int(pos);
+}
+
+//! Platform where FORT21 file has been generated. It is similar to GUTHAREplatforms.
+enum Platform
+{
+  Windows_Linux_32 = 0,  // 32-bits Windows/Linux (Intel/AMD architecture)         r = 4 l = 4 d = 4
+  Linux_64f90 = 1,       // 64-bits Linux (f90, f95)                               r = 4 l = 8 d = 4
+  Linux_64gcc = 2,       // 64-bits Linux (gcc, g77, gnu)                          r = 8 l = 4 d = 4
+  Tru64_64f90 = 3,       // Tru64 UNIX (f90)                                       r = 4 l = 8 d = 4
+  Unix_64f77 = 4,        // Tru64 UNIX (f77)                                       r = 4 l = 8 d = 8
+  SGI_32 = 5,            // 32-bits SGI (big ebdian)                               r = 4 l = 4 d = 4
+  IBM_Tech = 6,          // 32-bits IBM RS6000 (OS: AIX)                           r = 4 l = 4 d = 4
+  Linux_Tech = 7         // 32-bits IBM Blade server (OS: Red Hat Enterprise AS4)  r = 4 l = 4 d = 8
+};
+
+
+/*! @brief Mesh data stored internally as a BasicMesh object.
+ *
+ *  This structure contains all the necessary information
+ *  for constructing MEDCouplingFieldDouble (with the addition of the MPI
+ *  communicator).
+ */
+
+//! This class provides services for parsing FORT21 file
+class ReaderFORT21
+{
+public:
+  //! CATHARE data types
+  enum CathareType
+  {
+    T_PTR = 0x00,
+    T_INT = 0x01,
+    T_REAL = 0x02,
+    T_CHAR = 0x04,
+    T_UNDEF = 0x08
+  };
+  enum LocalisationField
+  {
+    L_UNDEF = 0x01,
+    L_ELEM = 0x02,
+    L_DUAL = 0x04,
+    L_GLOBAL = 0x0F,
+    L_TWALL = 0x10
+  };
+
+
+  //! Sets information about platform where file was written
+  enum Status
+  {
+    NotDone = -1,
+    Done,
+    Fail
+  };
+
+public:
+  // ---------- PUBLIC METHODS ----------
+
+  //! Empty constructor
+  explicit ReaderFORT21(int verbosity = 0);
+
+  //! Destructor
+  ~ReaderFORT21();
+
+  //! Sets the file to parse
+  void setFile(const std::string& theName);
+
+  //! parses the file
+  void parse();
+  void fix_bad_times();
+
+  //! Returns the status of parsing, see below enum
+  ReaderFORT21::Status getStatus() const;
+
+  //! Set platform where FORT21 file has been generated
+  void setPlatform(const Platform thePlatform);
+
+protected:
+  //! Represents a field in the file; it is written as:
+  //!   size - integer, the size of field
+  //!   char[size] - field data
+  //!   size - once more the same size
+  //! The instance of this class is resized as needed to store
+  //! the next portion of the file
+  class Field
+  {
+  public:
+    Field()
+      : myFile(0)
+      , myData(0)
+      , myCapacity(0)
+      , mySize(0)
+    {
+      setPlatform(Windows_Linux_32);
+    }
+
+    ~Field()
+    {
+      if (myData != 0)
+        delete[] myData;
+      setFile(0);
+    }
+
+    void setFile(FILE* theFile)
+    {
+      if (myFile != 0)
+        fclose(myFile);
+      myFile = theFile;
+
+      myFPos = myFile ? get_file_pos(myFile) : 0;
+    }
+
+    void setMaxFileInt(int theMaxSizeInt)
+    {
+      myMaxSizeInt = theMaxSizeInt;
+    }
+
+    FILE* getFile() const
+    {
+      return myFile;
+    }
+
+    file_pos_t getFilePos() const
+    {
+      return myFPos;
+    }
+
+    bool read(int theSize = 0);
+
+    int size() const
+    {
+      return mySize;
+    }
+
+    char* getData() const
+    {
+      return myData;
+    }
+
+    void clear()
+    {
+      mySize = 0;
+    }
+
+    void setPlatform(const Platform thePlatform)
+    {
+      myPlatform = thePlatform;
+    }
+
+    Platform getPlatform() const
+    {
+      return myPlatform;
+    }
+
+  private:
+    FILE* myFile;
+    file_pos_t myFPos;
+    char* myData;
+    int myCapacity;
+    int mySize;
+    int myMaxSizeInt;
+
+    Platform myPlatform;
+  };
+
+  bool readRecord();
+  bool readHeader();
+  bool readDescr();
+  bool readVaria();
+  bool readDesStack(bool theSkip);
+
+public:
+  //!  Codes for meaning of variables in FORT21 file.
+  enum MeshType
+  {
+    MESH_Unknown = 0,  //!< Fictive mesh (port, reactor, circuit)
+    MESH_Polygone = 1,   //!< for volum, axial
+    MESH_Hexa   =2  //!< for threed
+  };
+
+  //! Get meaning of CATHARE variable.
+
+private:
+  Status myStatus;
+  int myRealSize;
+  int myMaxSizeInt;
+  Field myField;
+  std::string myInFile;
+
+  bool myIsC3;
+  bool myIsSimpleReal;
+
+  std::vector<double> Times_glob_;
+  std::vector<file_pos_t> offset_a_time_;
+
+public:
+  class FieldInfo
+  {
+    friend ReaderFORT21;
+
+  public:
+    int size() const
+    {
+      return size_;
+    }
+    int nb_parts() const
+    {
+      return nb_parts_;
+    }
+    // mettre un enum
+    CathareType type_of_field() const
+    {
+      return type_of_field_;
+    }
+    LocalisationField localisation_of_field() const
+    {
+      return localisation_of_field_;
+    }
+
+  private:
+    int size_;
+    CathareType type_of_field_;
+    LocalisationField localisation_of_field_;
+    file_pos_t offset_rel_stack_;
+    int nb_parts_;
+  };
+
+private:
+  class ElementInfo
+  {
+  public:
+    std::string type_;
+    file_pos_t offset_const_;
+    std::vector<int> index_times_;
+    std::vector<file_pos_t> offset_rel_time_;
+    std::map<std::string, FieldInfo> ConstFields_;
+    std::map<std::string, FieldInfo> VarFields_;
+    file_pos_t sizeblock_ = -1;
+  };
+  std::map<std::string, ElementInfo> elements_list_;
+  int verbosity_;
+
+  const ElementInfo& getElementInfo(const std::string& name_stack) const;
+  const FieldInfo& getVarFieldInfo(const ElementInfo& eleminfo, const std::string& name_field) const;
+  const FieldInfo& getConstFieldInfo(const ElementInfo& eleminfo, const std::string& name_field) const;
+
+public:
+  const FieldInfo& getVarFieldInfo(const std::string& name_stack, const std::string& name_field) const;
+  const FieldInfo& getConstFieldInfo(const std::string& name_stack, const std::string& name_field) const;
+  std::vector<double> getTimes() const
+  {
+    return Times_glob_;
+  }
+  std::vector<double> getTimesStack(const std::string& name_stack) const;
+  // std::vector<int> getTimesIndexStack(const std::string& name_stack) const;
+  std::vector<std::string> getElementNames() const;
+  std::string getElementType(const std::string& name_stack) const;
+  std::vector<std::string> getVarFieldNames(const std::string& name_stack) const;
+  template <typename _TYPE_> void getValuesVarField(const std::string& name_stack, const std::string& name_field, std::vector<_TYPE_>& data, const int& id_time_field) const;
+  template <typename _TYPE_> void getInterpolatedValuesVarField(const std::string& name_stack, const std::string& name_field, std::vector<_TYPE_>& data, const int& global_id_time) const;
+
+
+  file_pos_t getOffsetVarField(const std::string& name_stack, const std::string& name_field, const int& id_time_field) const;
+  std::vector<std::string> getConstFieldNames(const std::string& name_stack) const;
+  template <typename _TYPE_> void getValuesConstField(const std::string& name_stack, const std::string& name_field, std::vector<_TYPE_>& data) const;
+  class BasicMesh
+  {
+  public:
+    /*! @brief Builds an empty mesh.
+     */
+    BasicMesh();
+
+    /*! @brief Destructor.
+     */
+    ~BasicMesh();
+
+    /*! @brief clear and reset all internal data structures.
+     *
+     * After the call to clear(), all pointers are null
+     * Arrays are deleted if necessary
+     */
+    void clear();
+
+    /*! @brief Used to simulate a 0D geometry (Cathare/Trio for example).
+     */
+    void dummy_geom();
+
+    /*! @brief Save mesh to a .mesh file
+     */
+    void save(std::ostream& os) const;
+
+    /*! @brief Restore mesh from a .mesh file
+     */
+    void restore(std::istream& in);
+
+  public:
+    MeshType type_mesh_;                  ///< 0 polygone 1 quadri ....
+    int mesh_dim_;                   ///< Mesh dimension
+    int space_dim_;                  ///< Space dimension
+    int nbnodes_;                    ///< Number of nodes
+    int nodes_per_elem_;             ///< Number of nodes for a single element
+    int nb_elems_;                   ///< Number of elements
+    std::vector<int> connectivity_;  ///< Nodal connectivity array
+    std::vector<double> coords_;     ///< Coordinate array
+  };
+  BasicMesh getMeshStack(const std::string& name_stack) const;
+};
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Rebuild_virtual_layer.cpp b/Utilities/VisItBridge/databases/readers/Lata/Rebuild_virtual_layer.cpp
new file mode 100644
index 00000000..4b1bfd6f
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Rebuild_virtual_layer.cpp
@@ -0,0 +1,124 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <LataFilter.h>
+#include <Connectivite_som_elem.h>
+#include <Operator.h>
+#include <Static_Int_Lists.h>
+#include <Rebuild_virtual_layer.h>
+
+void find_virtual_layer(DomainUnstructured& domain, BigTIDTab& virtual_elements, BigTIDTab& joints_virtual_elements, double tolerance)
+{
+  Journal(4) << "Searching virtual elements for domain " << domain.id_.name_ << endl;
+  // Step 1 : find duplicate nodes
+  BigArrOfTID nodes_renumber;
+  Reconnect::search_duplicate_nodes(domain.nodes_, nodes_renumber, tolerance, 0);
+
+  // Build reconnected elements
+  Reconnect::apply_renumbering(nodes_renumber, domain.elements_);
+
+  Static_Int_Lists_64 som_elem;
+  construire_connectivite_som_elem<trustIdType>(domain.nb_nodes(), domain.elements_, som_elem, 0 /* include virtual */);
+
+  virtual_elements.resize(0, 1);
+
+  // Step 2 : for each sub_zone, add to virtual_elements list all elements
+  // touching the zone and not included in the zone
+  const BigTIDTab& joints_sommets = domain.get_joints(LataField_base::SOM);
+  const BigTIDTab& joints_elements = domain.get_joints(LataField_base::ELEM);
+  const int nprocs = (int)joints_sommets.dimension(0);
+  joints_virtual_elements.resize(nprocs, 2);
+  BigArrOfTID tmp;
+  for (int i_proc = 0; i_proc < nprocs; i_proc++)
+    {
+      trustIdType first_elem_zone = joints_elements(i_proc, 0);
+      trustIdType end_elems_zone = first_elem_zone + joints_elements(i_proc, 1);
+      trustIdType first_node_zone = joints_sommets(i_proc, 0);
+      trustIdType end_nodes_zone = first_node_zone + joints_sommets(i_proc, 1);
+      const trustIdType first_virtual_element = virtual_elements.dimension(0);
+      tmp.resize_array(0);
+      for (trustIdType i_node = first_node_zone; i_node < end_nodes_zone; i_node++)
+        {
+          const trustIdType renum_node = nodes_renumber[i_node];
+          const trustIdType nb_elems_voisins = som_elem.get_list_size(renum_node);
+          for (trustIdType i = 0; i < nb_elems_voisins; i++)
+            {
+              const trustIdType elem = som_elem(renum_node, i);
+              if (elem < first_elem_zone || elem >= end_elems_zone)
+                tmp.append_array(elem);
+            }
+        }
+      // Retirer les doublons
+      tmp.ordonne_array();
+      const trustIdType n = tmp.size_array();
+      trustIdType last = -1;
+      for (trustIdType i = 0; i < n; i++)
+        {
+          const trustIdType elem = tmp[i];
+          if (elem != last)
+            {
+              const trustIdType idx = virtual_elements.dimension(0);
+              virtual_elements.resize(idx + 1, 1);
+              virtual_elements(idx, 0) = elem;
+              last = elem;
+            }
+        }
+      joints_virtual_elements(i_proc, 0) = first_virtual_element;
+      joints_virtual_elements(i_proc, 1) = virtual_elements.dimension(0) - first_virtual_element;
+      Journal(5) << "Zone " << i_proc << " has " << joints_virtual_elements(i_proc, 1) << " virtual elements" << endl;
+    }
+}
+
+int rebuild_virtual_layer(LataDB& lataDB, Domain_Id id, double reconnect_tolerance)
+{
+  Journal(4) << "rebuilt_virtual_layer domain " << id.name_ << " " << id.timestep_ << endl;
+  if (lataDB.field_exists(id.timestep_, id.name_, "VIRTUAL_ELEMENTS"))
+    {
+      Journal(4) << " Virtual elements data already exist. Skip" << endl;
+      return 1;
+    }
+  if (!lataDB.field_exists(id.timestep_, id.name_, "JOINTS_ELEMENTS"))
+    {
+      Journal(4) << " Domain has no processor splitting information. Skip" << endl;
+      return 0;
+    }
+  // Load all domain, without faces:
+  id.block_ = -1;
+  DomainUnstructured dom;
+  dom.fill_domain_from_lataDB(lataDB, id, 0 /* no faces */);
+  // Compute virtual zones:
+  BigTIDTab joints_virtual_elements;
+  BigTIDTab virtual_elements;
+  find_virtual_layer(dom, virtual_elements, joints_virtual_elements, reconnect_tolerance);
+  // Write data to disk
+  const LataDBField& joints = lataDB.get_field(id.timestep_, id.name_, "JOINTS_ELEMENTS", "*");
+  LataDBField fld(joints);
+  // Append virtual_elements data to JOINTS_ELEMENTS, same format, etc
+  fld.name_ = "JOINTS_VIRTUAL_ELEMENTS";
+  fld.uname_ = Field_UName(fld.geometry_, fld.name_, "");
+  fld.nb_comp_ = 2;
+  fld.datatype_.file_offset_ = 0;
+  fld.filename_ += ".ghostdata";
+  lataDB.add_field(fld);
+  lataDB.write_data(id.timestep_, fld.uname_, joints_virtual_elements);
+  fld.name_ = "VIRTUAL_ELEMENTS";
+  fld.uname_ = Field_UName(fld.geometry_, fld.name_, "");
+  fld.nb_comp_ = 1;
+  fld.datatype_.file_offset_ = 1; // append
+  fld.size_ = virtual_elements.dimension(0);
+  lataDB.add_field(fld);
+  lataDB.write_data(id.timestep_, fld.uname_, virtual_elements);
+  return 1;
+}
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Rebuild_virtual_layer.h b/Utilities/VisItBridge/databases/readers/Lata/Rebuild_virtual_layer.h
new file mode 100644
index 00000000..52a75667
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Rebuild_virtual_layer.h
@@ -0,0 +1,28 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Rebuild_virtual_layer_H
+#define LataLoader_H
+
+#include <TRUSTTab.h>
+
+class DomainUnstructured;
+class Domain_Id;
+class LataDB;
+
+void find_virtual_layer(DomainUnstructured& domain, BigTIDTab& virtual_elements, BigTIDTab& joints_virtual_elements, double tolerance);
+int rebuild_virtual_layer(LataDB& lataDB, Domain_Id id, double reconnect_tolerance);
+
+#endif /* LataLoader_H */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Schema_Comm.h b/Utilities/VisItBridge/databases/readers/Lata/Schema_Comm.h
new file mode 100644
index 00000000..bcbfd999
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Schema_Comm.h
@@ -0,0 +1,149 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Schema_Comm_included
+#define Schema_Comm_included
+
+#include <TRUSTArray.h>
+#include <TRUST_Ref.h>
+
+class Comm_Group;
+
+// Ces objets stockent un graphe de conversation entre
+// processeurs : chaque proc. possede une liste de processeurs a qui
+// envoyer et une liste de processeurs de qui recevoir.
+//
+// Le groupe est l'ensemble des processeurs sur lesquels on GARANTIT
+// que les methodes suivantes seront appelees SIMULTANEMENT sur tous
+// les processeurs du groupe :
+// - begin_comm()
+// - set_send_recv_pe_list(...)
+// - echange_taille_et_messages()
+// - end_comm()
+//
+// En particulier : Il est interdit d'utiliser ces methodes a
+// l'interieur d'une boucle qui n'est pas executee le meme nombre de
+// fois par tous les processeurs du groupe, ni a l'interieur d'un
+// "if() { }" dont le deroulement n'est pas identique sur tous les
+// processeurs du groupe.
+//
+// Il est interdit de commencer une nouvelle communication pendant
+// qu'une autre est en cours (une communication finit toujours par
+// "end_comm()")
+// Interdiction en particulier d'utiliser "envoyer", "recevoir" et les
+// fichiers disques partages entre le premier appel a schema.send_buffer()
+// et "terminer()". Faire tres attention a toutes les methodes qu'on utilise
+// entre ces deux appels !
+//
+// Sur un PE donne, une sequence d'echange doit etre construite comme suit:
+// schema.begin_comm()
+// schema.send_buffer(pe1) << data_to_send;
+// schema.send_buffer(pe2) << data_to_send;
+// ...
+// schema.echanger_taille_et_messages();
+// schema.recv_buffer(pe2) >> data_to_recv;
+// schema.recv_buffer(pe3) >> data_to_recv;
+// ...
+// schema.end_comm();
+//
+// La communication n'est pas forcement symetrique : un processeur peut envoyer
+// un message a un processeur et recevoir d'un autre.
+// En revanche, l'utilisateur garantit que les listes de processeurs fournies dans
+//  send_pe_list et recv_pe_list verifient le principe "tu m'ecoutes quand je te parle !"
+//  (c'est a dire qu'un processeur A appartient a send_pe_list sur le processeur B
+//   si et seulement si le processeur B appartient a recv_pe_list sur le processeur A).
+
+// Modif BM 20/06/2013: j'ajoute set_all_to_allv_flag. Si le drapeau est mis, le schema de
+//  communication utilise MPI_alltoallv au lieu de ISend IRecv. Pour tenter de resoudre
+//  les problemes rencontres sur supermuc dans la routine de lecture ecriture fichiers
+//  (schema tout le monde ecrit au processeur 0 => erreur d'allocation des MPI_requests).
+
+class OutputCommBuffer;
+class InOutCommBuffers;
+class InputCommBuffer;
+class Comm_Group;
+class Entree;
+class Sortie;
+
+class Schema_Comm
+{
+public:
+  Schema_Comm();
+  Schema_Comm(const Schema_Comm&);
+  ~Schema_Comm();
+
+  void set_group(const Comm_Group& group);  // Obsolete
+  const Comm_Group& get_group() const;
+
+  const Schema_Comm& operator= (const Schema_Comm&);
+  void set_send_recv_pe_list(const ArrOfInt& send_pe_list, const ArrOfInt& recv_pe_list, const int me_to_me = 0);
+
+  void begin_comm() const;                 // Statut passe a WRITING
+  // Autorise si status_ == WRITING:
+  Sortie& send_buffer(int num_PE) const;
+  void echange_taille_et_messages() const; // Statut passe a EXCHANGED
+  void echange_messages(const ArrOfInt& recv_size) const;  // Statut passe a EXCHANGED
+  // Autorise si status_ == EXCHANGED:
+  Entree& recv_buffer(int num_PE) const;
+  void end_comm() const;                   // Statut passe a RESET
+  // Accesseurs:
+  const ArrOfInt& get_send_pe_list() const;
+  const ArrOfInt& get_recv_pe_list() const;
+
+  void set_all_to_allv_flag(int x) { use_all_to_allv_ = x; }
+
+protected:
+  void echange_taille(const ArrOfInt& send_size, ArrOfInt& recv_size) const;
+  void echange_messages(const ArrOfInt& send_size, const ArrOfInt& recv_size) const;
+  // Statut passe a EXCHANGED
+  void check_send_recv_pe_list() const;
+
+  // Un seul statut pour tous les echanges : on ne supporte pas les
+  // acces concurrents a la classe car on veut limiter le nombre
+  // de buffers et le nombre d'"outstanding requests".
+  // Donc : interdiction de commencer une nouvelle comm si les buffers
+  // sont en cours d'utilisation.
+  enum Static_Status { UNINITIALIZED, RESET, WRITING, EXCHANGED };
+  static Static_Status status_;
+  static OutputCommBuffer& obuffer(int pe);
+  static InputCommBuffer&   ebuffer(int pe);
+
+  ArrOfInt send_pe_list_; // Liste des processeurs a qui envoyer
+  ArrOfInt recv_pe_list_; // Liste des processeurs de qui recevoir
+  int   me_to_me_;     // Drapeau: est-ce qu'on autorise a s'envoyer des messages a soi ?
+  OBS_PTR(Comm_Group) ref_group_;// Groupe de processeurs qui vont discuter
+
+  int use_all_to_allv_; // Drapeau, quel type de communication faut-il utiliser ?
+private:
+  // Les pointeurs sont ranges dans une classe specifique (destructeur
+  // des membres statiques appele automatiquement a la fin de l'execution
+  // pour liberer la memoire).
+  static InOutCommBuffers buffers_;
+  static int n_buffers_;
+};
+
+class Schema_Comm_statique : public Schema_Comm
+{
+public:
+  //void echange_taille();
+  //void echange_messages() const;           // Statut passe a EXCHANGED
+  const ArrOfInt& get_send_size() const;
+  const ArrOfInt& get_recv_size() const;
+protected:
+  ArrOfInt send_size_;    // Taille des messages a envoyer en bytes
+  ArrOfInt recv_size_;    // Taille des messages a recevoir en bytes
+};
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Schema_Comm_Vecteurs.h b/Utilities/VisItBridge/databases/readers/Lata/Schema_Comm_Vecteurs.h
new file mode 100644
index 00000000..e16a25ae
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Schema_Comm_Vecteurs.h
@@ -0,0 +1,277 @@
+/****************************************************************************
+* Copyright (c) 2025, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Schema_Comm_Vecteurs_included
+#define Schema_Comm_Vecteurs_included
+
+#include <TRUSTArray.h>
+
+class Schema_Comm_Vecteurs_Static_Data;
+
+/*! @brief Classe outil utilisee notamment par les methodes MD_Vector::echange_espace_virtuel()
+ *
+ * Permet d'echanger avec d'autres processeurs des blocs d'ints ou de double
+ * accessibles par des tableaux dans lesquels on lit et on ecrit directement
+ *   (contrairement a Schema_Comm qui utilise readOn et printOn, plus lent).
+ *   Pour des raisons de performances, la communication est separee en deux parties
+ *   - definition des tailles de buffers (permet d'allouer a l'avance les bufffers
+ *      begin_init()
+ *      add_send/recv_area_int/double(processeur, size)
+ *       (declaration des types, tailles et processeurs destinataire des blocs que l'on va envoyer,
+ *        on peut envoyer plusieurs blocs de types identiques ou differents a chaque processeur)
+ *      end_init()
+ *   - echange de donnees (autant de fois qu'on veut):
+ *      begin_comm()
+ *      for(each bloc to send) {
+ *       ArrOfInt/Double & buf = get_next_area_int/double(pe, size);
+ *       for (i=0; i<size; i++)
+ *         buf[i] = ...
+ *      }
+ *      exchange();
+ *      for (each bloc to recv) {
+ *        ... get_next_area_int/double(...)
+ *      end_comm();
+ *
+ */
+extern bool check_comm_vector;
+class Schema_Comm_Vecteurs
+{
+public:
+  Schema_Comm_Vecteurs();
+  ~Schema_Comm_Vecteurs();
+  void begin_init();
+
+  template <typename _TYPE_>
+  inline void add_send_area_template(int pe, int size);
+
+  template <typename _TYPE_>
+  inline void add_recv_area_template(int pe, int size);
+
+  template <typename _TYPE_>
+  inline TRUSTArray<_TYPE_>& get_next_area_template(int pe, int array_size);
+
+  void end_init();
+  void begin_comm(bool bufferOnDevice=false);
+  void exchange(bool bufferOnDevice=false);
+  void end_comm();
+
+protected:
+  inline void add(int pe, int size, ArrOfInt& procs, ArrOfInt& buf_sizes, int align_size);
+  int check_buffers_full() const;
+  int check_next_area(int pe, int byte_size) const;
+
+  // Pour chaque processeur de send_proc ou recv_proc_, taille totale des buffers en "bytes"
+  // Pendant la phase begin_init(), ces deux tableaux sont de taille nproc(), valeur nulle
+  //  pour les processeurs a qui on ne parle pas.
+  // ensuite, il sont de la meme taille que send_procs_ et recv_procs_
+  ArrOfInt send_buf_sizes_;
+  ArrOfInt recv_buf_sizes_;
+  // Liste des proceseurs a qui on envoie des donnees
+  ArrOfInt send_procs_;
+  ArrOfInt recv_procs_;
+  // A l'issue de la phase d'initialisation, les processeurs sont-ils dans l'ordre croissant ?
+  int sorted_ = 1;
+  // Taille du buffer requis pour ce schema
+  int min_buf_size_ = -1;
+  // Support GPU par MPI:
+  bool use_gpu_aware_mpi_ = false;
+
+  enum Status { RESET, BEGIN_INIT, END_INIT, BEGIN_COMM, EXCHANGED };
+  Status status_;
+
+  // Le buffer global est-il en cours d'utilisation ?
+  static bool buffer_locked_;
+  // Zones temporaires de lecture/ecriture, renvoyees par get_next... et qui pointent dans buffer_
+  static ArrOfDouble tmp_area_double_;
+  static ArrOfFloat tmp_area_float_;
+  static ArrOfInt tmp_area_int_;
+#if INT_is_64_ == 2
+  static ArrOfTID tmp_area_tid_;
+#endif
+
+  // Classe contenant des tableaux malloc (pour destruction automatique en fin d'execution)
+  static Schema_Comm_Vecteurs_Static_Data sdata_;
+};
+
+/*! @brief Donnees statiques communes a toutes les classes Schema_Comm_Vecteur, avec destructeur pour liberer la memoire en fin d'execution
+ *
+ */
+class Schema_Comm_Vecteurs_Static_Data
+{
+public:
+  Schema_Comm_Vecteurs_Static_Data();
+  ~Schema_Comm_Vecteurs_Static_Data();
+  void init(int size, bool bufferOnDevice);
+
+  char  *buffer_base_;
+  int buffer_base_size_;
+  int buffer_base_device_size_;
+  int buf_pointers_size_;
+  // Pour chaque processeur entre 0 et nproc(), adresse des prochaines donnees a lire/ecrire
+  // de ce proc dans le tableau buffer
+  char **buf_pointers_;
+};
+
+// Taille en bytes d'un bloc de sz ints, arrondi aux 8 octets superieurs
+#ifdef INT_is_64_
+#if INT_is_64_ == 1
+#define BLOCSIZE_INT(sz) (sz<<3)   // == sz*8
+#else
+#define BLOCSIZE_INT(sz) (sz<<2)   // == sz*4
+#define BLOCSIZE_TID(sz) (sz<<3)   // == sz*8
+#endif
+#else
+#define BLOCSIZE_INT(sz) (sz<<2)   // == sz*4
+#endif
+
+#define BLOCSIZE_DOUBLE(sz) (sz<<3)
+#define BLOCSIZE_FLOAT(sz) (sz<<2)
+#define ALIGN_SIZE(ptr,sz) ptr=sdata_.buffer_base_+((ptr-sdata_.buffer_base_+(sz-1))&(~(sz-1)))
+
+inline void Schema_Comm_Vecteurs::add(int pe, int size, ArrOfInt& procs, ArrOfInt& buf_sizes, int align_size)
+{
+  assert(status_ == BEGIN_INIT);
+  assert(size >= 0);
+  int& x = buf_sizes[pe];
+  if (x == 0 && size > 0)
+    {
+      const int n = procs.size_array();
+      if (n > 0 && procs[n - 1] > pe)
+        sorted_ = 0;
+      procs.append_array(pe);
+    }
+  x = ((x + align_size - 1) & (~(align_size - 1))) + size; // Padding before block
+}
+
+template<>
+inline void Schema_Comm_Vecteurs::add_send_area_template<int>(int pe, int size)
+{
+  add(pe, BLOCSIZE_INT(size), send_procs_, send_buf_sizes_, sizeof(int));
+}
+
+template<>
+inline void Schema_Comm_Vecteurs::add_send_area_template<double>(int pe, int size)
+{
+  add(pe, BLOCSIZE_DOUBLE(size), send_procs_, send_buf_sizes_, sizeof(double));
+}
+
+template<>
+inline void Schema_Comm_Vecteurs::add_send_area_template<float>(int pe, int size)
+{
+  add(pe, BLOCSIZE_FLOAT(size), send_procs_, send_buf_sizes_, sizeof(float));
+}
+
+template<>
+inline void Schema_Comm_Vecteurs::add_recv_area_template<int>(int pe, int size)
+{
+  add(pe, BLOCSIZE_INT(size), recv_procs_, recv_buf_sizes_, sizeof(int));
+}
+
+template<>
+inline void Schema_Comm_Vecteurs::add_recv_area_template<double>(int pe, int size)
+{
+  add(pe, BLOCSIZE_DOUBLE(size), recv_procs_, recv_buf_sizes_, sizeof(double));
+}
+
+template<>
+inline void Schema_Comm_Vecteurs::add_recv_area_template<float>(int pe, int size)
+{
+  add(pe, BLOCSIZE_FLOAT(size), recv_procs_, recv_buf_sizes_, sizeof(float));
+}
+
+#if INT_is_64_ == 2
+template<>
+inline void Schema_Comm_Vecteurs::add_send_area_template<trustIdType>(int pe, int size)
+{
+  add(pe, BLOCSIZE_TID(size), send_procs_, send_buf_sizes_, sizeof(trustIdType));
+}
+
+template<>
+inline void Schema_Comm_Vecteurs::add_recv_area_template<trustIdType>(int pe, int size)
+{
+  add(pe, BLOCSIZE_TID(size), recv_procs_, recv_buf_sizes_, sizeof(trustIdType));
+}
+#endif
+
+/*! @brief renvoie un tableau contenant les "size" valeurs suivantes recues du processeur pe lors de la communication en cours.
+ *
+ *   Attention:
+ *   Le tableau renvoye est une reference a un tableau interne qui n'est valide que
+ *   jusqu'au prochain appel a une methode get_next_xxx.
+ *
+ */
+template<>
+inline ArrOfInt& Schema_Comm_Vecteurs::get_next_area_template<int>(int pe, int size)
+{
+  ALIGN_SIZE(sdata_.buf_pointers_[pe], sizeof(int));
+  assert(check_next_area(pe, BLOCSIZE_INT(size)));
+  int *bufptr = (int *) (sdata_.buf_pointers_[pe]);
+  // attention a l'arithmetique de pointeurs, ajout d'une taille en octets
+  sdata_.buf_pointers_[pe] += BLOCSIZE_INT(size);
+  tmp_area_int_.ref_data(bufptr, size);
+  return tmp_area_int_;
+}
+
+#if INT_is_64_ == 2
+template<>
+inline ArrOfTID& Schema_Comm_Vecteurs::get_next_area_template<trustIdType>(int pe, int size)
+{
+  ALIGN_SIZE(sdata_.buf_pointers_[pe], sizeof(trustIdType));
+  assert(check_next_area(pe, BLOCSIZE_TID(size)));
+  trustIdType *bufptr = (trustIdType *) (sdata_.buf_pointers_[pe]);
+  // attention a l'arithmetique de pointeurs, ajout d'une taille en octets
+  sdata_.buf_pointers_[pe] += BLOCSIZE_TID(size);
+  tmp_area_tid_.ref_data(bufptr, size);
+  return tmp_area_tid_;
+}
+#endif
+
+template<>
+inline ArrOfDouble& Schema_Comm_Vecteurs::get_next_area_template<double>(int pe, int size)
+{
+  ALIGN_SIZE(sdata_.buf_pointers_[pe], sizeof(double));
+  assert(check_next_area(pe, BLOCSIZE_DOUBLE(size)));
+  double *bufptr = (double *) (sdata_.buf_pointers_[pe]);
+  // attention a l'arithmetique de pointeurs, ajout d'une taille en octets
+  sdata_.buf_pointers_[pe] += BLOCSIZE_DOUBLE(size);
+  tmp_area_double_.ref_data(bufptr, size);
+  if (check_comm_vector)
+    {
+#ifndef NDEBUG
+      // en debug, mettre des valeurs bidon dans le tableau
+      if (status_ != EXCHANGED)
+        tmp_area_double_ = DMAXFLOAT * 0.999;
+#endif
+    }
+  return tmp_area_double_;
+}
+
+template<>
+inline ArrOfFloat& Schema_Comm_Vecteurs::get_next_area_template<float>(int pe, int size)
+{
+  ALIGN_SIZE(sdata_.buf_pointers_[pe], sizeof(float));
+  assert(check_next_area(pe, BLOCSIZE_FLOAT(size)));
+  float *bufptr = (float *) (sdata_.buf_pointers_[pe]);
+  // attention a l'arithmetique de pointeurs, ajout d'une taille en octets
+  sdata_.buf_pointers_[pe] += BLOCSIZE_FLOAT(size);
+  tmp_area_float_.ref_data(bufptr, size);
+  return tmp_area_float_;
+}
+
+#undef BLOCSIZE_INT
+#undef BLOCSIZE_DOUBLE
+#undef BLOCSIZE_FLOAT
+
+#endif /* Schema_Comm_Vecteurs_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Separateur.h b/Utilities/VisItBridge/databases/readers/Lata/Separateur.h
new file mode 100644
index 00000000..fa82eeb1
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Separateur.h
@@ -0,0 +1,41 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Separateur_included
+#define Separateur_included
+/*! @brief Separateur pour les fichiers.
+ *
+ * Ce sont des objets speciaux que l'on peut inserer dans une sortie
+ *     comme ceci:
+ *       sortie << "coucou" << space << x << finl;
+ *     et qui sont traites differemment en fonction du type de fichier
+ *     (binaire ou ascii).
+ *
+ * @sa Sortie
+ */
+
+class Separateur
+{
+public:
+  enum Type { ENDL, SPACE };
+  Separateur(Type t) : type_(t) {};
+  const Type& get_type() const
+  {
+    return type_;
+  };
+private:
+  Type type_;
+};
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Sortie.h b/Utilities/VisItBridge/databases/readers/Lata/Sortie.h
new file mode 100644
index 00000000..3f84e870
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Sortie.h
@@ -0,0 +1,126 @@
+/****************************************************************************
+* Copyright (c) 2025, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Sortie_included
+#define Sortie_included
+
+#include <AbstractIO.h>
+#include <iostream>
+#include <assert.h>
+#include <arch.h>
+#include <string>
+#include <memory>
+
+using std::ostream;
+using std::flush;
+using std::endl;
+using std::cerr;
+using std::ends;
+using std::cout;
+using std::ios;
+using std::cin;
+
+template <typename T> class TRUST_Ref;
+class TRUST_Ref_Objet_U;
+class Separateur;
+class Objet_U;
+
+/*! @brief Classe de base des flux de sortie.
+ *
+ * Elle sait ecrire des types simples (entiers, flottants) et des Objet_U (via printOn de l'objet_U)
+ *    Attention, certains classes derivees sont paralleles: dans ce cas, il faut appeler
+ *    syncfile() periodiquement sur tous les processeurs. Voir class EcrFicPartage
+ *    Attention: pour ecrire correctement un flux a la fois en ASCII et BINAIRE,
+ *     il faut utiliser un Separateur (finl ou space) pour separer les objets ecrits.
+ *
+ * @sa Entree
+ */
+
+class Sortie: public AbstractIO
+{
+public:
+  Sortie();
+  Sortie(ostream& os);
+  Sortie(const Sortie& os);
+  virtual ~Sortie() {}
+
+  Sortie& operator=(ostream& os);
+  Sortie& operator=(Sortie& os);
+
+  void set_bin(bool bin) override;
+
+  inline ostream& get_ostream() { return *ostream_; }
+  inline const ostream& get_ostream() const { return *ostream_; }
+  inline void set_col_width(int w) { col_width_ = w; }
+
+  Sortie& operator <<(ostream& (*f)(ostream&));
+  Sortie& operator <<(Sortie& (*f)(Sortie&));
+  Sortie& operator <<(ios& (*f)(ios&));
+
+  virtual Sortie& flush();
+  virtual Sortie& lockfile();
+  virtual Sortie& unlockfile();
+  virtual Sortie& syncfile();
+  virtual void setf(IOS_FORMAT);
+  virtual void precision(int);
+
+  template <typename T>
+  Sortie& operator<<(const TRUST_Ref<T>& ) { std::cerr << __func__ << " :: SHOULD NOT BE CALLED ! Use -> !! " << std::endl ; throw; }
+
+  Sortie& operator<<(const TRUST_Ref_Objet_U& ) { std::cerr << __func__ << " :: SHOULD NOT BE CALLED ! Use -> !! " << std::endl ; throw; }
+
+  virtual Sortie& operator<<(const Separateur& );
+  virtual Sortie& operator<<(const Objet_U&    ob);
+  virtual Sortie& operator<<(const True_int    ob);
+  virtual Sortie& operator<<(const unsigned ob);
+  virtual Sortie& operator<<(const long      ob);
+  virtual Sortie& operator<<(const long long      ob);
+  virtual Sortie& operator<<(const unsigned long      ob);
+  virtual Sortie& operator<<(const float     ob);
+  virtual Sortie& operator<<(const double    ob);
+  virtual Sortie& operator<<(const char      * ob);
+  virtual Sortie& operator<<(const std::string& str);
+
+  virtual int add_col(const double ob);
+  virtual int add_col(const char * ob);
+
+  // The put methods can potentially write long stream of data (std::streamsize == ptrdiff_t == long)
+  // but in many derived classes only used after the Scatter (e.g. LecFicDiffuse) we downcast to int inside impl.
+  virtual int put(const unsigned* ob, std::streamsize n, std::streamsize nb_colonnes=1);
+  virtual int put(const True_int* ob, std::streamsize n, std::streamsize nb_colonnes=1);
+  virtual int put(const float * ob, std::streamsize n, std::streamsize nb_colonnes=1);
+  virtual int put(const double* ob, std::streamsize n, std::streamsize nb_colonnes=1);
+  virtual int put(const long  * ob, std::streamsize n, std::streamsize nb_colonnes=1);
+  virtual int put(const long long * ob, std::streamsize n, std::streamsize nb_colonnes=1);
+
+  inline bool has_ostream() const { return ostream_ != nullptr; }
+
+protected:
+  int col_width_;
+
+  /*! A smart pointer to a std::ostream object, or any of its derived class.
+   * Explicit construction might be done in derived classes of Sortie.
+   */
+  std::unique_ptr<ostream> ostream_;
+
+private:
+  template <typename _TYPE_>
+  int put_template(const _TYPE_* ob, std::streamsize n, std::streamsize nb_col);
+
+  template <typename _TYPE_>
+  Sortie& operator_template(const _TYPE_& );
+};
+
+#endif /* Sortie_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Static_Int_Lists.cpp b/Utilities/VisItBridge/databases/readers/Lata/Static_Int_Lists.cpp
new file mode 100644
index 00000000..d2ee9860
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Static_Int_Lists.cpp
@@ -0,0 +1,200 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+#include <Static_Int_Lists.h>
+#include <TRUSTArrays.h>
+
+/*! @brief detruit toutes les listes
+ */
+template <typename _SIZE_>
+void Static_Int_Lists_32_64<_SIZE_>::reset()
+{
+  index_.resize_array(0);
+  valeurs_.resize_array(0);
+}
+
+/*! @brief detruit les listes existantes et en cree de nouvelles.
+ *
+ * On cree autant de listes que d'elements dans le tableau sizes.
+ *   La i-ieme liste a une taille sizes[i]
+ *   Les valeurs sizes doivent etre positives ou nulles.
+ *
+ */
+template <typename _SIZE_>
+void Static_Int_Lists_32_64<_SIZE_>::set_list_sizes(const ArrOfInt_t& sizes)
+{
+  reset();
+
+  const int_t nb_listes = sizes.size_array();
+  index_.resize_array(nb_listes + 1);
+  // Construction du tableau d'index
+  index_[0];
+  for (int_t i = 0; i < nb_listes; i++)
+    {
+      assert(sizes[i] >= 0);
+      index_[i+1] = index_[i] + sizes[i];
+    }
+  const int_t somme_sizes = index_[nb_listes];
+  valeurs_.resize_array(somme_sizes);
+}
+
+/*! @brief remplace les valeurs stockes par toutes les listes par celles du tableau data.
+ *
+ * data doit avoir pour taille la somme des tailles de toutes
+ *   les listes.
+ *
+ */
+template <typename _SIZE_>
+void Static_Int_Lists_32_64<_SIZE_>::set_data(const ArrOfInt_t& data)
+{
+  assert(data.size_array() == valeurs_.size_array());
+  valeurs_.inject_array(data);
+}
+
+#ifndef NDEBUG
+// Verifie la coherence du tableau index et data
+template <typename _SIZE_>
+static bool check_index_data(const ArrOfInt_T<_SIZE_>& index, const ArrOfInt_T<_SIZE_>& data)
+{
+  if (index.size_array() < 1)
+    return false;
+  if (index[0] != 0)
+    return false;
+  const _SIZE_ n = index.size_array() - 1; // nombre de listes
+  for (_SIZE_ i = 0; i < n; i++)
+    if (index[i+1] < index[i])
+      return false;
+  if (index[n] != data.size_array())
+    return false;
+  return true;
+}
+#endif
+
+/*! @brief remplace index et data.
+ *
+ */
+template <typename _SIZE_>
+void Static_Int_Lists_32_64<_SIZE_>::set_index_data(const ArrOfInt_t& index, const ArrOfInt_t& data)
+{
+  assert(check_index_data(index, data));
+  index_ = index;
+  valeurs_ = data;
+}
+
+/*! @brief tri par ordre croissant des valeurs de la i-ieme liste.
+ *
+ * Si num_liste < 0, on trie toutes les listes.
+ *
+ */
+template <typename _SIZE_>
+void Static_Int_Lists_32_64<_SIZE_>::trier_liste(int_t num_liste)
+{
+  const int_t i_debut = (num_liste < 0) ? 0 : num_liste;
+  const int_t i_fin   = (num_liste < 0) ? index_.size_array() - 1 : num_liste + 1;
+
+  ArrOfInt_t valeurs_liste;
+  for (int_t i = i_debut; i < i_fin; i++)
+    {
+      const int_t index = index_[i];
+      const int_t size  = index_[i+1] - index;
+      valeurs_liste.ref_array(valeurs_, index, size);
+      valeurs_liste.ordonne_array();
+    }
+}
+
+/*! @brief copie la i-ieme liste dans le tableau fourni Le tableau array doit etre resizable.
+ *
+ */
+template <typename _SIZE_>
+void Static_Int_Lists_32_64<_SIZE_>::copy_list_to_array(int_t i, ArrOfInt_t& array) const
+{
+  const int_t n = get_list_size(i);
+  array.resize_array(n, RESIZE_OPTIONS::NOCOPY_NOINIT);
+  const int_t index = index_[i];
+  array.inject_array(valeurs_, n, 0 /* destination index */, index /* source index */);
+}
+
+template <typename _SIZE_>
+Sortie& Static_Int_Lists_32_64<_SIZE_>::printOn(Sortie& os) const
+{
+#ifndef LATATOOLS
+  os << index_   << tspace;
+  os << valeurs_ << tspace;
+#endif
+  return os;
+}
+
+template <typename _SIZE_>
+Entree& Static_Int_Lists_32_64<_SIZE_>::readOn(Entree& is)
+{
+  reset();
+#ifndef LATATOOLS
+  is >> index_;
+  is >> valeurs_;
+#endif
+  return is;
+}
+
+template <typename _SIZE_>
+Sortie& Static_Int_Lists_32_64<_SIZE_>::ecrire(Sortie& os) const
+{
+#ifndef LATATOOLS
+  os << "nb lists       : " << get_nb_lists() << finl;
+  os << "sizes of lists : ";
+  for (int_t i=0; i<get_nb_lists(); ++i)
+    {
+      os << get_list_size(i) << " ";
+    }
+  os << finl;
+
+  for (int_t i=0; i<get_nb_lists(); ++i)
+    {
+      os << "{ " ;
+      const int_t sz = get_list_size(i);
+      for (int_t j=0; j<sz; ++j)
+        os <<  valeurs_[(index_[i]+j)] << " ";
+      os << "}" << finl;
+    }
+#endif
+  return os;
+}
+
+template <typename _SIZE_>
+void Static_Int_Lists_32_64<_SIZE_>::set(const ArrsOfInt_t& src)
+{
+  const int nb_lists = src.size();
+  index_.resize_array(nb_lists + 1, RESIZE_OPTIONS::NOCOPY_NOINIT);
+  int_t idx = 0;
+  index_[0] = 0;
+  for (int i = 0; i < nb_lists; i++)
+    {
+      idx += src[i].size_array();
+      index_[i+1] = idx;
+    }
+
+  valeurs_.resize_array(idx, RESIZE_OPTIONS::NOCOPY_NOINIT);
+  idx = 0;
+  for (int i = 0; i < nb_lists; i++)
+    {
+      const ArrOfInt_t& a = src[i];
+      int_t sz = a.size_array();
+      valeurs_.inject_array(a, sz, idx /* dest index */, 0 /* source index */);
+      idx += sz;
+    }
+}
+
+template class Static_Int_Lists_32_64<int>;
+#if INT_is_64_ == 2
+template class Static_Int_Lists_32_64<trustIdType>;
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Static_Int_Lists.h b/Utilities/VisItBridge/databases/readers/Lata/Static_Int_Lists.h
new file mode 100644
index 00000000..b326dee6
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Static_Int_Lists.h
@@ -0,0 +1,119 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+#ifndef Static_Int_Lists_included
+#define Static_Int_Lists_included
+
+#include <TRUSTTabs_forward.h>
+#include <TRUSTArray.h>
+
+/*! @brief Cette classe permet de stocker des listes d'entiers accessibles en temps constant.
+ *
+ * La taille des listes ne peut pas changer sans
+ *   perdre le contenu (ce sont des listes statiques).
+ *   Exemple:
+ *    Static_Int_List l;
+ *    ArrOfInt tailles(3);
+ *    tailles[0] = 2; tailles[1] = 3; tailles[2] = 0;
+ *    // On reserve la memoire pour trois listes de taille 2, 3 et 0:
+ *    l.set_list_sizes(tailles);
+ *    // On affecte une valeur au deuxieme element de la premiere liste:
+ *    l.set_value(0,1,765);
+ *    // Affiche la valeur
+ *    Cout << l(0,1);
+ *
+ */
+template <typename _SIZE_>
+class Static_Int_Lists_32_64
+{
+public:
+  using int_t = _SIZE_;
+  using ArrOfInt_t = ArrOfInt_T<_SIZE_>;
+  using ArrsOfInt_t = ArrsOfInt_T<_SIZE_>;
+
+  void set_list_sizes(const ArrOfInt_t& sizes);
+  void reset();
+
+  void copy_list_to_array(int_t i_liste, ArrOfInt_t& array) const;
+
+  inline void   set_value(int_t i_liste, int_t i_element, int_t valeur);
+  inline int_t operator() (int_t i_liste, int_t i_element) const;
+  inline int_t get_list_size(int_t i_liste) const;
+  inline int_t get_nb_lists() const;
+  const ArrOfInt_t& get_index() const  { return index_;    }
+  const ArrOfInt_t& get_data() const   { return valeurs_;  }
+  void set_data(const ArrOfInt_t& data);
+  void set_index_data(const ArrOfInt_t& index, const ArrOfInt_t& data);
+  void trier_liste(int_t i);
+  void set(const ArrsOfInt_t& src);
+
+  Sortie& printOn(Sortie& os) const;
+  Entree& readOn(Entree& is);
+  Sortie& ecrire(Sortie& os) const;
+
+private:
+  // Les listes d'entiers sont stockees de facon contigue
+  // dans le tableau valeurs_.
+  // Le premier element de la liste i est valeurs_[index_[i]]
+  // et le dernier element est valeurs_[index_[i+1]-1]
+  // (c'est comme le stockage morse des matrices).
+  ArrOfInt_t index_;
+  ArrOfInt_t valeurs_;
+};
+
+/*! @brief affecte la "valeur" au j-ieme element de la i-ieme liste avec 0 <= i < get_nb_lists()  et  0 <= j < get_list_size(i)
+ *
+ */
+template <typename _SIZE_>
+inline void Static_Int_Lists_32_64<_SIZE_>::set_value(int_t i, int_t j, int_t valeur)
+{
+  const int_t index = index_[i] + j;
+  assert(index < index_[i+1]);
+  valeurs_[index] = valeur;
+}
+
+/*! @brief renvoie le j-ieme element de la i-ieme liste avec 0 <= i < get_nb_lists()  et  0 <= j < get_list_size(i)
+ *
+ */
+template <typename _SIZE_>
+inline typename Static_Int_Lists_32_64<_SIZE_>::int_t Static_Int_Lists_32_64<_SIZE_>::operator() (int_t i, int_t j) const
+{
+  const int_t index = index_[i] + j;
+  assert(index < index_[i+1]);
+  const int_t val = valeurs_[index];
+  return val;
+}
+
+/*! @brief renvoie le nombre d'elements de la liste i
+ *
+ */
+template <typename _SIZE_>
+inline typename Static_Int_Lists_32_64<_SIZE_>::int_t Static_Int_Lists_32_64<_SIZE_>::get_list_size(int_t i) const
+{
+  return index_[i+1] - index_[i];
+}
+
+/*! @brief renvoie le nombre de listes stockees
+ *
+ */
+template <typename _SIZE_>
+inline typename Static_Int_Lists_32_64<_SIZE_>::int_t Static_Int_Lists_32_64<_SIZE_>::get_nb_lists() const
+{
+  return index_.size_array() - 1;
+}
+
+using Static_Int_Lists = Static_Int_Lists_32_64<int>;
+using Static_Int_Lists_64 = Static_Int_Lists_32_64<trustIdType>;
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Statistiques.h b/Utilities/VisItBridge/databases/readers/Lata/Statistiques.h
new file mode 100644
index 00000000..f5551e79
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Statistiques.h
@@ -0,0 +1,306 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Statistiques_included
+#define Statistiques_included
+
+#include <assert.h>
+#include <string>
+class Stat_Counter_Id;
+class Stat_Results;
+class Stat_Internals;
+class Time;
+
+
+static const int JUMP_3_FIRST_STEPS = 0; ///< If equal to 1, counters will start after the 3 first time steps
+
+static const int GET_COMM_DETAILS = 1; ///< If equal to 1, enable to track the communications of the wanted functions
+
+class Statistiques
+{
+public:
+
+  Statistiques();
+  ~Statistiques();
+  /*!@brief Function that change the debug level
+   *
+   *This function have to be called simultanely on each processor
+   * @param level the new debug level
+   * During the printing of the performance, the debug level is set to 0
+   */
+  void set_debug_level(int level);
+
+  /*!@brief Create a new counter in the Statistiques object
+   *
+   * This function has to be called simultaneously on every processor
+   * @param level If level <= debug_level, then the statistics of this counter will be printed at the end.
+   * @param decsription String used as the counter name/short description
+   * @param familly Parameter to regroup counter together (if they have the same family number) in order to create aggregated stats ; if equal to zero, then no aggregation
+   * @param comm If equal to 1, then the counter is a communication counter, otherwise, it is a "basic" counter. Set to 0 by default
+   */
+  Stat_Counter_Id new_counter(int level,
+                              const char * const description,
+                              const char * const familly = 0,
+                              int comm = 0);
+
+  /*! @brief Start the count of a counter
+   *
+   * @param counter_id The ID of the counter that the user want to start. It is a global variable that is declare in stats_counters.cpp
+   * @param track_comm Indicate if the user want to record the communication associated with the counter, set to true by default
+   */
+  inline void begin_count(const Stat_Counter_Id& counter_id, bool track_comm = true);
+
+  /*! @brief End the count of a counter and update values in the Stat_Internals object of the Statistiques object
+   *
+   * @param counter_id The ID of the counter that the user want to start. It is a global variable that is declare in stats_counters.cpp
+   * @param quantity A user defined quantity which depends on the counter (can be a number of iteration, a buffer size,.... It is set to zero by default
+   * @count Parameter that count the number of time the counter has been used between begin_count and end_count. By default equal to 1.
+   * @param track_comm Indicate if the user want to record the communication associated with the counter, set to true by default
+   */
+  inline void end_count(const Stat_Counter_Id& counter_id, int quantity = 0, int count = 1, bool track_comm = true);
+
+
+  /*! @brief Give the last interval of time the counter has been used
+   *
+   * If the counter is still running, return the time since the last begin_count
+   * If the counter is stopped, return the interval of time of the last count
+   * @param counter_id The ID of the counter that the user want to start. It is a global variable that is declare in stats_counters.cpp
+   */
+  double last_time(const Stat_Counter_Id& counter_id);
+
+  /*! @brief Function that create the file CASE_NAME_log_perf.csv
+   *
+   * This function prints the global and detailed performance log, depending on the debug_level.
+   * It has to be called on every processor simultaneously
+   * During this function, all counters are stop and then restart
+   * @param message_info String that state the overall step of calculation we are in : initialization, resolution or post-processing
+   */
+  void dump(const char * message_info, int mode_append);
+
+  /*! @brief Reset all counters
+   *
+   * Some variables are kept even after the reset : counters_avg_min_max_var_per_step and communication_tracking_info
+   */
+  void reset_counters();
+
+  /*! @brief Reset the counter related to the counter_id
+   *
+   * Some variables are kept even after the reset : counters_avg_min_max_var_per_step and communication_tracking_info
+   */
+  void reset_counter(int counter_id);
+
+  void stop_counters(); //< Stop all counters, has to be called on every processor simultaneously
+
+  void restart_counters(); //< Restart all counters, has to be called on every processor simultaneously
+
+  /*! @brief Get back the stats of a counter and store them in a Stat_Resluts type object
+   *
+   * @param counter_id Global variable link to a specific counter. It is declare in stats_counters.cpp
+   * @param result A Stat_Results type object used to store the stats concerning the wanted counter
+   */
+
+  void get_stats(const Stat_Counter_Id& counter_id, Stat_Results& result);
+
+  /*! @brief Get back and agregate the stats of a set of counters and store them in a Stat_Resluts type object
+   *
+   * @param familly Name of a set of counter for which we want aggregated stats. It is declare in stats_counters.cpp
+   * @param result A Stat_Results type object used to store the stats concerning the wanted counter
+   */
+
+  void get_stats_familly(const char * familly, Stat_Results& result);
+
+  /*! @brief Aggregate stats of the counter associated with counter ID to the stats in a Stat_Results type object
+   *
+   * @param counter_id Global variable link to a specific counter. It is declare in stats_counters.cpp
+   * @param result A Stat_Results type object used to store the stats concerning the wanted counter
+   */
+  void cumulate_stats(int counter_id, Stat_Results& result);
+
+  /// Get the protected variable total_time of a Statistics type object
+  inline double get_total_time()
+  {
+    return total_time_;
+  };
+
+  static double get_time_now(); ///< Return the clock time
+
+  /*! Compute the average, minimum, maximum and variance of the elapsed time on an iteration for each counter
+   *
+   * @param tstep Number of time step of the calculation
+   */
+  void compute_avg_min_max_var_per_step(int tstep);
+
+  /// Create the table of communication stats after the declaration of all of the counters
+  int allocate_communication_tracking_times();
+
+  /// Delete the table of communication stats at the end of the calculation
+  int delete_communication_tracking_times();
+
+  /*! @brief Start communication tracking
+   *
+   * Counters stats are saved in the table communication_tracking_info
+   * Update the entire table communication_tracking_info : the total time of communication for all communication counter and the communication time per domain j for each counter
+   * /!\ reset the counter associated with cid
+   * comm_domaines_on becomes true
+   */
+  void begin_communication_tracking(int cid);
+
+  /*! @brief Update communications info regarding counter cid and stop the count
+   *
+   * Update the variable communication_tracking_info[i][cid+1] with the communication tracking associated with counter cid.
+   * comm_domaines_on become flase
+   */
+  void end_communication_tracking(int cid);
+
+  /*! Print communication stats
+   *
+   * For each declared communication domain/function, print the average time spend for each type of communication on each processor
+   * And for each time of communication, print the average time spend on each domain/function on each processor
+   */
+  void print_communciation_tracking_details(const char * message, int mode_append);
+
+  const char* get_counter_family(int id);
+
+  int get_counter_id_from_index_in_comm_tracking_info(int index) const;
+
+  int get_index_in_comm_tracking_info_from_counter_id(int id) const;
+
+  int get_nb_comm_counters() const;
+
+  Stat_Results get_communication_tracking_info(int i, int j) const;
+
+  inline void set_three_first_steps_elapsed(bool b)
+  {
+    three_first_steps_elapsed_ = b;
+  }
+
+  int get_counter_id_from_description(const char* desc) const;
+
+protected:
+  // Les deux fonctions suivantes peuvent etre appelees sur un seul processeur
+  void begin_count_(const int id_);
+  void end_count_(const int id_, int quantity, int count);
+  int debug_level_;
+  Stat_Internals * stat_internals;
+  double total_time_;
+  bool three_first_steps_elapsed_;  ///< If TRUE, the 3 first time steps are elapsed
+
+};
+
+
+
+// Ceci est l'identifiant fourni a l'utilisateur pour acceder au compteur
+// qu'il a cree.
+class Stat_Counter_Id
+{
+public:
+  Stat_Counter_Id() : id_(-1), level_(-1) {};
+  int initialized() const
+  {
+    return id_ >= 0;
+  };
+  inline int id() const
+  {
+    return id_;
+  };
+protected:
+  Stat_Counter_Id(int i, int level) : id_(i), level_(level) {};
+  friend class Statistiques;
+  int id_;
+  int level_;
+  // Le niveau de debug est stocke ici pour un acces rapide
+  // lors de l'appel a begin et end, il est aussi stocke dans
+  // Stat_Internals...
+};
+
+// La definition de ce pointeur est dans Statistiques.cpp
+// NE PAS UTILISER CE POINTEUR DIRECTEMENT !
+// Utiliser la methode d'acces statistiques()
+class Statistiques;
+extern Statistiques * les_statistiques_trio_U_nom_long_pour_decourager_l_utilisation_directe;
+
+inline Statistiques& statistiques()
+{
+  assert(les_statistiques_trio_U_nom_long_pour_decourager_l_utilisation_directe);
+  return *les_statistiques_trio_U_nom_long_pour_decourager_l_utilisation_directe;
+}
+
+// Les details d'implementation de Stat sont separes de Stat pour ne pas avoir
+// a tout recompiler si on change Stat.
+class Stat_Internals;
+
+/*! @brief An object that is used to store counter data
+ *
+ */
+class Stat_Results
+{
+public:
+  Stat_Results() : time(0.0), min_time(0.0), max_time(0.0), avg_time(0.0),
+    count(0.0), min_count(0.0), max_count(0.0), avg_count(0.0),
+    quantity(0.0), min_quantity(0.0), max_quantity(0.0), avg_quantity(0.0) {};
+
+  // Cumul de temps, min max et moyenne sur les differents processeurs
+  double time, min_time, max_time, avg_time;
+  // Nombre de comptages
+  double count, min_count, max_count, avg_count;
+  // Cumul des quantites comptees
+  double quantity, min_quantity, max_quantity, avg_quantity;
+
+  void compute_min_max_avg();  //calcule le min, le max et la moyenne des temps sur les procs
+
+  inline void reset();
+
+};
+
+inline void Statistiques::begin_count(const Stat_Counter_Id& counter_id, bool track_comm)
+{
+  assert(counter_id.initialized());
+  if (counter_id.level_ <= debug_level_)
+    {
+      begin_count_(counter_id.id_);
+      if(track_comm) begin_communication_tracking(counter_id.id_);
+    }
+}
+
+/*! @brief Arret du compteur counter_id.
+ *
+ * On ajoute quantity a la somme des 'quantity' (par defaut 0) stockees pour ce compteur
+ *   et on ajoute 'count' (par defaut 1) au compteur d'appels a end_count pour ce compteur
+ *   (quantity sert a sommer par exemple la taille des donnees traitees pendant ce comptage
+ *   et count sert a compter combien de fois on a appele ce compteur)
+ *
+ */
+inline void Statistiques::end_count(const Stat_Counter_Id& counter_id,
+                                    int quantity,
+                                    int count,
+                                    bool track_comm)
+{
+  assert(counter_id.initialized());
+  if (counter_id.level_ <= debug_level_)
+    {
+      end_count_(counter_id.id_, quantity, count);
+      if(track_comm) end_communication_tracking(counter_id.id_);
+    }
+}
+
+inline void Stat_Results::reset()
+{
+
+  time=0.0, min_time=0.0, max_time=0.0, avg_time=0.0;
+  count=0.0, min_count=0.0, max_count=0.0, avg_count=0.0;
+  quantity=0.0, min_quantity=0.0, max_quantity=0.0, avg_quantity=0.0;
+}
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUSTArray.cpp b/Utilities/VisItBridge/databases/readers/Lata/TRUSTArray.cpp
new file mode 100644
index 00000000..456cda74
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUSTArray.cpp
@@ -0,0 +1,492 @@
+/****************************************************************************
+* Copyright (c) 2025, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <arch.h>
+#include <TRUSTArray.h>
+#include <string.h>
+#include <DeviceMemory.h>
+
+// Ajout d'un flag par appel a end_gpu_timer peut etre couteux (creation d'une string)
+#ifdef _OPENMP_TARGET
+static bool timer=true;
+#else
+static bool timer=false;
+#endif
+
+// TRUSTArray kernels for device moved in .cpp file to avoid multiple definition during link
+template <typename _TYPE_, typename _SIZE_>
+Sortie& TRUSTArray<_TYPE_, _SIZE_>::printOn(Sortie& os) const
+{
+#ifndef LATATOOLS
+  this->ensureDataOnHost();
+  _SIZE_ sz = size_array();
+  os << sz << finl;
+  if (sz > 0)
+    {
+      const _TYPE_* v = span_.data();
+      os.put(v,sz,sz);
+    }
+#endif
+  return os;
+}
+
+template <typename _TYPE_, typename _SIZE_>
+Entree&  TRUSTArray<_TYPE_, _SIZE_>::readOn(Entree& is)
+{
+#ifndef LATATOOLS
+  _SIZE_ sz;
+  is >> sz;
+  if (sz >= 0)
+    {
+      // Appel a la methode sans precondition sur le type derive (car readOn est virtuelle, les autres proprietes seront initialisees correctement)
+      resize_array_(sz);
+      if (sz > 0)
+        {
+          _TYPE_* v = span_.data();
+          is.get(v,sz);
+        }
+    }
+  else
+    {
+      Cerr << "Error in TRUSTArray:readOn : size = " << sz << finl;
+      Process::exit();
+    }
+#endif
+  return is;
+}
+
+
+/** Protected method for resize. Used by derived classes.
+ * Same as resize_array() with less checks.
+ *
+ * This is also where we deal with the STORAGE::TEMP_STORAGE capability, i.e. the Trav arrays.
+ * There memory is taken from a shared pool (TRUSTTravPool). This kind of array should never be
+ * used in 64bits, since Trav are meaningful when inside the timestepping (so the 32bit world after the
+ * Scatter isntruction).
+ */
+template <typename _TYPE_, typename _SIZE_>
+void TRUSTArray<_TYPE_, _SIZE_>::resize_array_(_SIZE_ new_size, RESIZE_OPTIONS opt)
+{
+  assert(new_size >= 0);
+
+  if (mem_ == nullptr)
+    {
+      if (!span_.empty()) // ref_data! We may pass here if just changing the shape of a tab
+        {
+          assert(size_array() == new_size);
+          return;  // Nothing to do ...
+        }
+      // We avoid allocating for empty arrays ... those are typically situations where we will resize (with a non
+      // null size) just after, so the real allocation will be made at that point.
+      if(new_size == 0) return;
+
+      // First allocation - memory space should really be malloc'd:
+      if(storage_type_ == STORAGE::TEMP_STORAGE)
+        mem_ = TRUSTTravPool<_TYPE_>::GetFreeBlock((int)new_size);
+      else
+        mem_ = std::make_shared<Vector_>(Vector_(new_size));
+
+      span_ = Span_(*mem_);
+
+      // We should never have to worry about device allocation here:
+      if (isAllocatedOnDevice(mem_->data()))
+        {
+          if (opt == RESIZE_OPTIONS::COPY_INIT)
+            data_location_ = std::make_shared<DataLocation>(DataLocation::Device);
+          else
+            data_location_ = std::make_shared<DataLocation>(DataLocation::Host);
+        }
+      else
+        data_location_ = std::make_shared<DataLocation>(DataLocation::HostOnly);
+
+      if(opt == RESIZE_OPTIONS::COPY_INIT)
+        operator=((_TYPE_)0); // To initialize on device or host
+      //std::fill(mem_->begin(), mem_->end(), (_TYPE_) 0);
+    }
+  else
+    {
+      // Array is already allocated, we want to resize:
+      // array must not be shared! (also checked in resize_array()) ... but, still, we allow passing here (i.e. no assert)
+      // only if we keep the same size_array(). This is for example invoked by TRUSTTab when just changing the overall shape of
+      // the array without modifying the total number of elems ...
+      _SIZE_ sz_arr = size_array();
+      if(new_size != sz_arr) // Yes, we compare to the span's size
+        {
+          assert(ref_count() == 1);  // from here on, we *really* should not be shared
+
+          if (storage_type_ == STORAGE::TEMP_STORAGE)
+            {
+              // No 64b Trav:
+              assert( (std::is_same<trustIdType, int>::value || !std::is_same<_SIZE_, trustIdType>::value) );
+
+              // Resize of a Trav: if the underlying mem_ is already big enough, just update the span, and possibly fill with 0
+              // else, really increase memory allocation using the TRUSTTravPool.
+              _SIZE_ mem_sz = (_SIZE_)mem_->size();
+              if (new_size <= mem_sz)
+                {
+                  // Cheat, simply update the span (up or down)
+                  span_ = Span_(span_.begin(), span_.begin()+new_size);
+                  // Possibly set to 0 extended part:
+                  if (new_size > sz_arr && opt == RESIZE_OPTIONS::COPY_INIT)
+                    {
+                      ensureDataOnHost();
+                      std::fill(span_.begin() + sz_arr, span_.end(), (_TYPE_) 0);
+                    }
+                }
+              else  // Real size increase of the underlying std::vector
+                {
+                  // ResizeBlock
+                  mem_ = TRUSTTravPool<_TYPE_>::ResizeBlock(mem_, (int)new_size);
+                  span_ = Span_(*mem_);
+                  if (opt == RESIZE_OPTIONS::COPY_INIT)
+                    {
+                      ensureDataOnHost();
+                      std::fill(span_.begin() + sz_arr, span_.end(), (_TYPE_) 0);
+                    }
+                }
+            }
+          else  // Normal (non Trav) arrays
+            {
+              _TYPE_ * prev_ad = span_.data(); // before resize!
+              Span_ prev_span = span_;
+              mem_->resize(new_size);
+              span_ = Span_(*mem_);
+              // Possibly set to 0 extended part, since we have a custom Vector allocator not doing it by default (TVAlloc):
+              if (new_size > sz_arr)
+                {
+                  if (get_data_location() == DataLocation::HostOnly)
+                    {
+                      if (opt == RESIZE_OPTIONS::COPY_INIT)
+                        std::fill(span_.begin()+sz_arr, span_.end(), (_TYPE_) 0);
+                    }
+                  else
+                    {
+                      if (prev_ad != span_.begin())
+                        {
+                          // Delete former block before allocating a new one !
+                          ensureDataOnHost(); // Force copie sur le host
+                          deleteOnDevice(prev_ad, sz_arr);
+                          set_data_location(DataLocation::HostOnly);
+                          // Allocate new (bigger) block on device:
+                          allocateOnDevice(*this);
+                          // Copy data (use a dummy TRUSTArray just because of inject_array API)
+                          TRUSTArray dummy_src;
+                          dummy_src.span_ = prev_span;
+                          inject_array(dummy_src, sz_arr);
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+
+/**  Copie les elements source[first_element_source + i] dans les elements  (*this)[first_element_dest + i] pour 0 <= i < nb_elements
+*    Les autres elements de (*this) sont inchanges.
+
+* @param  const ArrOfDouble& m: le tableau a utiliser, doit etre different de *this !
+* @param _SIZE_ nb_elements: nombre d'elements a copier, nb_elements >= -1. Si nb_elements==-1, on copie tout le tableau m. Valeurs par defaut: -1
+* @param _SIZE_ first_element_dest. Valeurs par defaut: 0
+* @param _SIZE_ first_element_source. Valeurs par defaut: 0
+* @return ArrOfDouble& : *this
+* @throw Sort en erreur si la taille du tableau m est plus grande que la taille de tableau this.
+*/
+template <typename _TYPE_, typename _SIZE_>
+TRUSTArray<_TYPE_, _SIZE_>& TRUSTArray<_TYPE_, _SIZE_>::inject_array(const TRUSTArray& source, _SIZE_ nb_elements, _SIZE_ first_element_dest, _SIZE_ first_element_source)
+{
+  assert(&source != this && nb_elements >= -1);
+  assert(first_element_dest >= 0 && first_element_source >= 0);
+
+  if (nb_elements < 0) nb_elements = source.size_array();
+
+  assert(first_element_source + nb_elements <= source.size_array());
+  assert(first_element_dest + nb_elements <= size_array());
+
+  if (nb_elements > 0)
+    {
+      bool kernelOnDevice = checkDataOnDevice(source);
+      if (timer) start_gpu_timer(__KERNEL_NAME__);
+      if (kernelOnDevice)
+        {
+#ifndef LATATOOLS
+          const auto addr_source = source.view_ro();
+          auto addr_dest = view_rw();
+          Kokkos::parallel_for(__KERNEL_NAME__, nb_elements, KOKKOS_LAMBDA(const _SIZE_ i) { addr_dest[first_element_dest+i] = addr_source[first_element_source+i]; });
+#endif
+        }
+      else
+        {
+          // PL: On utilise le memcpy car c'est VRAIMENT plus rapide (10% +vite sur RNR_G20)
+          const _TYPE_ * addr_source = source.span_.data() + first_element_source;
+          _TYPE_ * addr_dest = span_.data() + first_element_dest;
+          memcpy(addr_dest, addr_source, nb_elements * sizeof(_TYPE_));
+#ifdef _OPENMP_TARGET
+          if (DeviceMemory::warning(nb_elements) && Process::je_suis_maitre())
+            Cerr << "[Host] Filling a large TRUSTArray (" << nb_elements << " items) which is slow during a GPU run! Set a breakpoint to fix." << finl;
+#endif
+        }
+      if (timer) end_gpu_timer(kernelOnDevice, __KERNEL_NAME__);
+    }
+  return *this;
+}
+
+template<typename _TYPE_, typename _SIZE_>
+template<typename _TAB_>
+void TRUSTArray<_TYPE_, _SIZE_>::ref_conv_helper_(_TAB_& out) const
+{
+  out.detach_array();
+  // Same as 'attach_array()', but since we are crossing templates parameters, we can not call it directly:
+  out.mem_ = mem_;
+  out.span_ = span_;
+  out.data_location_ = data_location_;
+  out.storage_type_ = storage_type_;
+}
+
+/*! Conversion methods - from a small array (_SIZE_=int) of TID (_TYPE_=trustIdType), return a big one (_SIZE_=trustIdType).
+ * No data copied! This behaves somewhat like a ref_array. Used in LATA stuff notably.
+ */
+#if INT_is_64_ == 2
+template<>
+void TRUSTArray<int, int>::ref_as_big(TRUSTArray<int, int>& out) const
+{
+  ref_conv_helper_(out);
+}
+#endif
+
+template<>
+void TRUSTArray<trustIdType, int>::ref_as_big(TRUSTArray<trustIdType,trustIdType>& out) const
+{
+  ref_conv_helper_(out);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+void TRUSTArray<_TYPE_,_SIZE_>::ref_as_big(TRUSTArray<_TYPE_,_TYPE_>& out) const
+{
+  // Should no be used for anything else than specialisations listed above.
+  assert(false);
+  Process::exit("TRUSTArray<>::ref_as_big() should not be used with those current template types.");
+}
+
+/*! Conversion methods - from a big array (_SIZE_=trustIdType), return a small one (_SIZE_=int).
+ * Overflow is detected in debug if array is too big to be fit into _SIZE_=int.
+ * No data copied! This behaves somewhat like a ref_array. Used in LATA stuff and FT notably.
+ */
+template<>
+void TRUSTArray<float, trustIdType>::ref_as_small(TRUSTArray<float, int>& out) const
+{
+  // Check size fits in 32bits:
+  assert(size_array() < std::numeric_limits<int>::max());
+  ref_conv_helper_(out);
+}
+
+template<>
+void TRUSTArray<int, trustIdType>::ref_as_small(TRUSTArray<int, int>& out) const
+{
+  // Check size fits in 32bits:
+  assert(size_array() < std::numeric_limits<int>::max());
+  ref_conv_helper_(out);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+void TRUSTArray<_TYPE_,_SIZE_>::ref_as_small(TRUSTArray<_TYPE_, int>& out) const
+{
+  // Should no be used for anything else than specialisations listed above.
+  assert(false);
+  Process::exit("TRUSTArray<>::ref_as_big() should not be used with those current template types.");
+}
+
+/*! Conversion from a BigArrOfTID to an ArrOfInt. Careful, it always does a copy! It is your responsibility
+ * to invoke it only when necessary (typically you should avoid this when trustIdType == int ...)
+ */
+template<>
+void TRUSTArray<trustIdType,trustIdType>::from_tid_to_int(TRUSTArray<int, int>& out) const
+{
+  // Not too big?
+  assert(size_array() < std::numeric_limits<int>::max());
+  int sz_int = (int)size_array(); // we may cast!
+  out.resize_array_(sz_int);  // the one with '_' skipping the checks, so we can be called from Tab too
+  // All values within int range?
+  assert((   *std::min_element(span_.begin(), span_.end()) > std::numeric_limits<int>::min()  ));
+  assert((   *std::max_element(span_.begin(), span_.end()) < std::numeric_limits<int>::max()  ));
+  // Yes, copy:
+  std::copy(span_.begin(), span_.end(), out.span_.begin());
+}
+
+template<typename _TYPE_, typename _SIZE_>
+void TRUSTArray<_TYPE_,_SIZE_>::from_tid_to_int(TRUSTArray<int, int>& out) const
+{
+  // Should no be used for anything else than specialisations listed above.
+  assert(false);
+  Process::exit("TRUSTArray<>::from_tid_to_int() should not be used with those current template types.");
+}
+
+
+/** Remplit le tableau avec la x en parametre (x est affecte a toutes les cases du tableau)
+ */
+template <typename _TYPE_, typename _SIZE_>
+TRUSTArray<_TYPE_, _SIZE_>& TRUSTArray<_TYPE_, _SIZE_>::operator=(_TYPE_ x)
+{
+  const _SIZE_ size = size_array();
+  bool kernelOnDevice = checkDataOnDevice();
+  if (timer) start_gpu_timer(size>100 ? __KERNEL_NAME__ : "");
+  if (kernelOnDevice)
+    {
+#ifndef LATATOOLS
+      auto data = view_rw();
+      Kokkos::parallel_for(__KERNEL_NAME__, size, KOKKOS_LAMBDA(const int i) { data[i] = x; });
+#endif
+    }
+  else
+    {
+      _TYPE_ *data = span_.data();
+      for (_SIZE_ i = 0; i < size; i++) data[i] = x;
+    }
+  if (timer) end_gpu_timer(kernelOnDevice, size>100 ? __KERNEL_NAME__ : "");
+  return *this;
+}
+
+/** Addition case a case sur toutes les cases du tableau : la taille de y doit etre au moins egale a la taille de this
+ */
+template <typename _TYPE_, typename _SIZE_>
+TRUSTArray<_TYPE_, _SIZE_>& TRUSTArray<_TYPE_, _SIZE_>::operator+=(const TRUSTArray& y)
+{
+  assert(size_array()==y.size_array());
+  _SIZE_ size = size_array();
+  bool kernelOnDevice = checkDataOnDevice(y);
+  if (timer) start_gpu_timer(__KERNEL_NAME__);
+  if (kernelOnDevice)
+    {
+#ifndef LATATOOLS
+      const auto dy = y.view_ro();
+      auto dx = view_rw();
+      Kokkos::parallel_for(__KERNEL_NAME__, size, KOKKOS_LAMBDA(const _SIZE_ i) { dx[i] += dy[i]; });
+#endif
+    }
+  else
+    {
+      const _TYPE_* dy = y.span_.data();
+      _TYPE_* dx = span_.data();
+      for (_SIZE_ i = 0; i < size; i++) dx[i] += dy[i];
+    }
+  if (timer) end_gpu_timer(kernelOnDevice, __KERNEL_NAME__);
+  return *this;
+}
+
+/** Ajoute la meme valeur a toutes les cases du tableau
+ */
+template <typename _TYPE_, typename _SIZE_>
+TRUSTArray<_TYPE_, _SIZE_>& TRUSTArray<_TYPE_, _SIZE_>::operator+=(const _TYPE_ dy)
+{
+  _SIZE_ size = size_array();
+  bool kernelOnDevice = checkDataOnDevice();
+  if (timer) start_gpu_timer(__KERNEL_NAME__);
+  if (kernelOnDevice)
+    {
+#ifndef LATATOOLS
+      auto data = view_rw();
+      Kokkos::parallel_for(__KERNEL_NAME__, size, KOKKOS_LAMBDA(const _SIZE_ i) { data[i] += dy; });
+#endif
+    }
+  else
+    {
+      _TYPE_ *data = span_.data();
+      for(_SIZE_ i = 0; i < size; i++) data[i] += dy;
+    }
+  if (timer) end_gpu_timer(kernelOnDevice, __KERNEL_NAME__);
+  return *this;
+}
+
+/** Soustraction case a case sur toutes les cases du tableau : tableau de meme taille que *this
+ */
+template <typename _TYPE_, typename _SIZE_>
+TRUSTArray<_TYPE_, _SIZE_>& TRUSTArray<_TYPE_, _SIZE_>::operator-=(const TRUSTArray& y)
+{
+  assert(size_array() == y.size_array());
+  _SIZE_ size = size_array();
+  bool kernelOnDevice = checkDataOnDevice(y);
+  if (timer) start_gpu_timer(__KERNEL_NAME__);
+  if (kernelOnDevice)
+    {
+#ifndef LATATOOLS
+      auto data = view_rw();
+      const auto data_y = y.view_ro();
+      Kokkos::parallel_for(__KERNEL_NAME__, size, KOKKOS_LAMBDA(const _SIZE_ i) { data[i] -= data_y[i]; });
+#endif
+    }
+  else
+    {
+      _TYPE_ * data = span_.data();
+      const _TYPE_ * data_y = y.span_.data();
+      for (_SIZE_ i = 0; i < size; i++) data[i] -= data_y[i];
+    }
+  if (timer) end_gpu_timer(kernelOnDevice, __KERNEL_NAME__);
+  return *this;
+}
+
+/** soustrait la meme valeur a toutes les cases
+ */
+template <typename _TYPE_, typename _SIZE_>
+TRUSTArray<_TYPE_, _SIZE_>& TRUSTArray<_TYPE_, _SIZE_>::operator-=(const _TYPE_ dy)
+{
+  operator+=(-dy);
+  return *this;
+}
+
+/** muliplie toutes les cases par dy
+ */
+template <typename _TYPE_, typename _SIZE_>
+TRUSTArray<_TYPE_, _SIZE_>& TRUSTArray<_TYPE_, _SIZE_>::operator*= (const _TYPE_ dy)
+{
+  _SIZE_ size = size_array();
+  bool kernelOnDevice = checkDataOnDevice();
+  if (timer) start_gpu_timer(__KERNEL_NAME__);
+  if (kernelOnDevice)
+    {
+#ifndef LATATOOLS
+      auto data = view_rw();
+      Kokkos::parallel_for(__KERNEL_NAME__, size, KOKKOS_LAMBDA(const _SIZE_ i) { data[i] *= dy; });
+#endif
+    }
+  else
+    {
+      _TYPE_ *data = span_.data();
+      for(_SIZE_ i=0; i < size; i++) data[i] *= dy;
+    }
+  if (timer) end_gpu_timer(kernelOnDevice, __KERNEL_NAME__);
+  return *this;
+}
+
+/** divise toutes les cases par dy (pas pour TRUSTArray<int>)
+ */
+template <typename _TYPE_, typename _SIZE_>
+TRUSTArray<_TYPE_, _SIZE_>& TRUSTArray<_TYPE_, _SIZE_>::operator/= (const _TYPE_ dy)
+{
+  if (std::is_integral<_TYPE_>::value) throw;  // division should not be called on integral types.
+  operator*=(1/dy);
+  return *this;
+}
+
+// Pour instancier les methodes templates dans un .cpp
+template class TRUSTArray<double, int>;
+template class TRUSTArray<int, int>;
+template class TRUSTArray<float, int>;
+
+#if INT_is_64_ == 2
+template class TRUSTArray<double, trustIdType>;
+template class TRUSTArray<int, trustIdType>;
+template class TRUSTArray<trustIdType, trustIdType>;
+template class TRUSTArray<trustIdType, int>;
+template class TRUSTArray<float, trustIdType>;
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUSTArray.h b/Utilities/VisItBridge/databases/readers/Lata/TRUSTArray.h
new file mode 100644
index 00000000..e99c6b9b
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUSTArray.h
@@ -0,0 +1,350 @@
+/****************************************************************************
+* Copyright (c) 2025, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef TRUSTArray_included
+#define TRUSTArray_included
+
+#include <Array_base.h>
+#include <TVAlloc.h>     // Custom allocator
+#include <Double.h>
+#include <span.hpp>
+#include <memory>
+#include <climits>
+#include <vector>
+#include <TRUSTTabs_forward.h>
+
+#include <Device.h>
+#include <View_Types.h>  // Kokkos stuff
+
+//Booleans for checking if an execution space is host or device
+//Checking if device: for GPU or CPU compilation, we only have to check if EXEC_SPACE=Device
+#ifndef LATATOOLS
+
+template <typename EXEC_SPACE >
+constexpr bool is_default_exec_space = std::is_same<EXEC_SPACE, Kokkos::DefaultExecutionSpace>::value;
+//Checking if host: For GPU compilation Device != Host, so we check if Exec_SPACE=Host. For CPU compilation, Device=Host, so we are always on the host
+template <typename EXEC_SPACE >
+constexpr bool is_host_exec_space = std::is_same<EXEC_SPACE, Kokkos::DefaultHostExecutionSpace>::value &&
+                                    !std::is_same<Kokkos::DefaultHostExecutionSpace, Kokkos::DefaultExecutionSpace>::value;
+#endif
+/*! @brief Represents a an array of int/int64/double/... values.
+ *
+ * The two main members are mem_ and span_:
+ * - 'mem_' is the (shared) pointer to the actual underlying data. The block of data itself is a std::vector. This
+ *    block of data can be shared among several arrays (see below) or can be null if we reference external data (ref_data)
+ * - 'span_' is a view on the actual data, and can point to a sub-part of *mem_.
+ *
+ * We can have 3 states for the array:
+ *   - "detached": meaning mem_==nullptr, span_.empty() == true (state obtained with the default ctor and detach_array())
+ *   - "normal" : in this case mem_ is a non-null shared pointer to a std::vector holding the data. 'span_' then typically represents the entire span of the vector.
+ *    The array is always initialised with 0.
+ *    When the array is destroyed, the shared_ptr 'mem_' is destroyed too, and if this was the last reference to the underlying data, the std::vector itself
+ *    is freed.
+ *    The memory space of the array can be shared among several TRUSTArray ('mem_' has the same underlying value in several instances).
+ *    This is typically produced by ref_array().
+ *    Note that when this happens, we have two instances pointing to the same underlying block of data, but *none* of them has precedence over the other one (none
+ *    of them is 'the' owner of the data). Ownership is shared, and when the last owner is destroyed, memory is released.
+ *   - "ref_data" : this is used to point to an exterior existing memory zone (not managed by TRUSTArray - for example data provided by an external Fortran func)
+ *    In this case, mem_ remains nullptr, just the span_ is correctly filled, and no memory is released when the array is destroyed.
+ *
+ * Finally, in case of a "XXTrav" array, the memory allocation is special:
+ *  - a Trav array is allocated once, but when released, memory is kept in a pool so that another request for a new Trav might re-use it without having
+ *  to perform the allocation again.
+ *  - a Trav may not be ref_data or ref_array.
+ *  - see implementation details of this mechanism in the TRUSTTravPool class.
+ *
+ *  In the template parameters below, _TYPE_ is the value type (what it contains), _SIZE_ is the extent type (how many items).
+ */
+template <typename _TYPE_, typename _SIZE_>
+class TRUSTArray : public Array_base
+{
+protected:
+  unsigned taille_memoire() const override { return sizeof(TRUSTArray<_TYPE_, _SIZE_>); }
+
+  int duplique() const override
+  {
+    TRUSTArray* xxx = new  TRUSTArray(*this);
+    if(!xxx) Process::exit("Not enough memory ");
+    return xxx->numero();
+  }
+  Sortie& printOn(Sortie& os) const override;
+  Entree& readOn(Entree& is) override;
+
+public:
+  using Value_type_ = _TYPE_;
+  using int_t = _SIZE_;
+  using Iterator_ = typename tcb::span<_TYPE_>::iterator;
+  using Vector_ = std::vector<_TYPE_, TVAlloc<_TYPE_> >;
+  using Span_ = tcb::span<_TYPE_>;
+
+  // Tests can inspect whatever they want:
+  friend class TestTRUSTArray;
+
+  // One instanciation with given template parameter may see all other template versions (useful in ref_as_big())
+  template<typename _TYPE2_, typename _SIZE2_> friend class TRUSTArray;
+
+  // Iterators
+  inline Iterator_ begin() { return span_.begin(); }
+  inline Iterator_ end() { return span_.end(); }
+
+  inline virtual ~TRUSTArray();
+
+  TRUSTArray() : TRUSTArray(0) { }
+
+  TRUSTArray(_SIZE_ n) : storage_type_(STORAGE::STANDARD)
+  {
+    if (n)
+      {
+        // Initialize underlying std::vector<> with 0:
+        mem_ = std::make_shared<Vector_>(Vector_(n, (_TYPE_)0));
+        span_ = Span_(*mem_);
+        data_location_ = std::make_shared<DataLocation>(DataLocation::HostOnly);
+      }
+  }
+
+  /**
+   * Copy ctor. Performs a deep copy.
+   *
+   * It is forbidden to deep copy a ref_data.
+   */
+  TRUSTArray(const TRUSTArray& A) :
+    Array_base(), storage_type_(A.storage_type_)
+  {
+    assert(A.mem_ != nullptr || A.span_.empty());
+    const _SIZE_ size = A.size_array();
+    if (size > 0)
+      {
+        // storage_type_ must be set properly before invoking this! So that Trav mechanism works:
+        resize_array_(size, RESIZE_OPTIONS::NOCOPY_NOINIT);
+        if (A.get_data_location() != DataLocation::HostOnly)   // Only allocate *this on device if A is on the device
+          // Not a Trav already allocated on device (avoid double alloc on device for Trav)
+          if(!(storage_type_ == STORAGE::TEMP_STORAGE && isAllocatedOnDevice(mem_->data())))
+            allocateOnDevice(*this);
+        // Set new location AFTER possible allocation
+        data_location_ = std::make_shared<DataLocation>(A.get_data_location());
+        inject_array(A);
+      }
+  }
+
+  // Resizing methods
+  inline void resize(_SIZE_ new_size, RESIZE_OPTIONS opt=RESIZE_OPTIONS::COPY_INIT) { resize_array(new_size, opt); }
+  inline void resize_array(_SIZE_ new_size, RESIZE_OPTIONS opt=RESIZE_OPTIONS::COPY_INIT);
+
+  // Conversion method - from a small array (_SIZE_=int) of TID (_TYPE_=trustIdType), return a big one (_SIZE_=long).
+  // No data copied! This behaves somewhat like a ref_array:
+  void ref_as_big(TRUSTArray<_TYPE_, _TYPE_>& out) const;
+
+  // The other way around compared to ref_as_big! From big to small. In debug, size limit is checked.
+  void ref_as_small(TRUSTArray<_TYPE_, int>& out) const;
+
+  // Conversion from a BigArrOfTID to an ArrOfInt - see also similar method in TRUSTTab
+  void from_tid_to_int(TRUSTArray<int, int>& out) const;
+
+  /*! Memory allocation type - TEMP arrays (i.e. Trav) have a different allocation mechanism - see TRUSTTravPool.h) */
+  inline void set_mem_storage(const STORAGE storage);
+  inline STORAGE get_mem_storage() const { return storage_type_; }
+
+  inline std::shared_ptr<Vector_> get_mem() {return mem_;}
+
+  inline TRUSTArray& operator=(const TRUSTArray&);
+
+  inline _TYPE_& operator[](_SIZE_ i);
+  inline const _TYPE_& operator[](_SIZE_ i) const;
+
+  inline _TYPE_& operator()(_SIZE_ i) { return operator[](i); }
+  inline const _TYPE_& operator()(_SIZE_ i) const { return operator[](i); }
+
+  // Ces methodes renvoient un pointeur vers le premier element du tableau pour une utilisation sur le host
+  inline _TYPE_ * addr();
+  inline const _TYPE_ * addr() const;
+  // Les memes methodes pour une utilisation sur le device
+  inline _TYPE_ *data();
+
+  inline const _TYPE_ *data() const;
+
+  /*! Return the size of the span on the data (not the full underlying allocated size)   */
+  inline _SIZE_ size_array() const;
+
+  /*! Returns the number of owners of the data, i.e. the number of Arrays pointing to the same underlying data */
+  inline int ref_count() const;
+
+  /*! Add a slot at the end of the array and store it valeur -> similar to vector<>::push_back */
+  inline void append_array(_TYPE_ valeur);
+
+  /*! Assign 'x' to all slots in the array */
+  TRUSTArray& operator=(_TYPE_ x);
+
+  /*! Addition case a case sur toutes les cases du tableau : la taille de y doit etre au moins egale a la taille de this */
+  TRUSTArray& operator+=(const TRUSTArray& y);
+
+  /*! ajoute la meme valeur a toutes les cases du tableau */
+  TRUSTArray& operator+=(const _TYPE_ dy);
+
+  /*! Soustraction case a case sur toutes les cases du tableau : tableau de meme taille que *this */
+  TRUSTArray& operator-=(const TRUSTArray& y);
+
+  /*! soustrait la meme valeur a toutes les cases */
+  TRUSTArray& operator-=(const _TYPE_ dy);
+
+  /*! muliplie toutes les cases par dy */
+  TRUSTArray& operator*= (const _TYPE_ dy);
+
+  /*! divise toutes les cases par dy (pas pour TRUSTArray<int>) */
+  TRUSTArray& operator/= (const _TYPE_ dy);
+
+  TRUSTArray& inject_array(const TRUSTArray& source, _SIZE_ nb_elements=-1,  _SIZE_ first_element_dest=0, _SIZE_ first_element_source=0);
+
+  inline TRUSTArray& copy_array(const TRUSTArray& a)
+  {
+    operator=(a);
+    return *this;
+  }
+
+  inline void ordonne_array();
+  inline void array_trier_retirer_doublons();
+
+  // methodes virtuelles
+
+  /*! Construction de tableaux qui pointent vers des donnees existantes !!! Utiliser ref_data avec precaution */
+  inline virtual void ref_data(_TYPE_* ptr, _SIZE_ size);
+  /*! Remet le tableau dans l'etat obtenu avec le constructeur par defaut (libere la memoire mais conserve le mode d'allocation memoire actuel) */
+  inline virtual void reset() { detach_array(); }
+  inline virtual void ref_array(TRUSTArray&, _SIZE_ start=0, _SIZE_ sz=-1);
+  inline virtual void resize_tab(_SIZE_ n, RESIZE_OPTIONS opt=RESIZE_OPTIONS::COPY_INIT);
+
+  // Host/Device methods:
+  inline DataLocation get_data_location() {  return data_location_ == nullptr ? DataLocation::HostOnly : *data_location_;   }
+  inline DataLocation get_data_location() const { return data_location_ == nullptr ? DataLocation::HostOnly : *data_location_; }
+  inline void set_data_location(DataLocation flag) { if (data_location_ != nullptr) *data_location_ = flag; }
+  inline void set_data_location(DataLocation flag) const { if (data_location_ != nullptr) *data_location_ = flag; }
+  inline int size_mem() { return mem_ == nullptr ? 0 : (int)mem_->size(); };
+
+  inline void ensureDataOnHost();
+  inline void ensureDataOnHost() const;
+  inline bool isDataOnDevice() const;
+  inline bool checkDataOnDevice();
+  inline bool checkDataOnDevice() const;
+  inline bool checkDataOnDevice(const TRUSTArray& arr);
+
+  inline virtual Span_ get_span() { return span_; }
+  inline virtual Span_ get_span_tot() { return span_; }
+  inline virtual const Span_ get_span() const { return span_; }
+  inline virtual const Span_ get_span_tot() const { return span_; }
+
+#ifdef KOKKOS
+  // Kokkos accessors (brace yourself!)
+
+  // Read-only
+  template <typename EXEC_SPACE = Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ConstViewArr<_TYPE_> >
+  view_ro() const;
+
+  template <typename EXEC_SPACE = Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, ConstHostViewArr<_TYPE_> >
+  view_ro() const;
+
+  // Write-only
+  template <typename EXEC_SPACE=Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ViewArr<_TYPE_> >
+  view_wo();
+
+  template <typename EXEC_SPACE=Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, HostViewArr<_TYPE_> >
+  view_wo();
+  // Read-write
+  template <typename EXEC_SPACE=Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ViewArr<_TYPE_> >
+  view_rw();
+
+  template <typename EXEC_SPACE=Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, HostViewArr<_TYPE_> >
+  view_rw();
+
+#endif
+
+  inline void sync_to_host() const;              // Synchronize back to host
+  inline void modified_on_host() const;         // Mark data as being modified on host side
+
+protected:
+  inline void attach_array(const TRUSTArray& a, _SIZE_ start=0, _SIZE_ size=-1);
+  inline bool detach_array();
+
+  void resize_array_(_SIZE_ n, RESIZE_OPTIONS opt=RESIZE_OPTIONS::COPY_INIT);
+
+  // Kokkos members
+  inline void init_view_arr() const;
+
+
+#ifdef KOKKOS
+  mutable DualViewArr<_TYPE_> dual_view_arr_;
+#endif
+
+private:
+  /*! Shared pointer to the actual underlying memory block:
+   *   - shared_ptr because data can be shared between several owners -> see ref_array()
+   *   - std::vector<> because we want contiguous data, with a smart allocation mechanism
+   * WARNING: allocation mechanism for a Trav array is special.
+   */
+  std::shared_ptr<Vector_> mem_;
+
+  /*! Actual view on the data. See comments at the top of the class */
+  Span_ span_;
+
+  /*! Drapeau indiquant si l'allocation memoire a lieu avec un new classique ou dans le pool de memoire temporaire de TRUST */
+  STORAGE storage_type_;
+
+  // Drapeau du statut du data sur le Device:
+  // HostOnly  : Non alloue sur le device encore
+  // Host      : A jour sur le host pas sur le device
+  // Device    : A jour sur le device pas sur le host
+  // HostDevice: A jour sur le host et le device
+  // PartialHostDevice : Etat temporaire: certaines valeurs sont plus a jour sur le host que le device (ex: faces frontieres ou items distants)
+  // In a shared_ptr because this state has the same status as mem_ (same sharing properties)
+  mutable std::shared_ptr<DataLocation> data_location_;
+
+private:
+
+  template<typename _TAB_> void ref_conv_helper_(_TAB_& out) const;
+};
+
+using ArrOfDouble = TRUSTArray<double, int>;
+using ArrOfFloat = TRUSTArray<float, int>;
+using ArrOfInt = TRUSTArray<int, int>;
+using ArrOfTID = TRUSTArray<trustIdType, int>;
+
+template <typename _TYPE_>
+using BigTRUSTArray = TRUSTArray<_TYPE_, trustIdType>;
+
+using BigArrOfDouble = BigTRUSTArray<double>;
+using BigArrOfInt = BigTRUSTArray<int>;
+using BigArrOfTID = BigTRUSTArray<trustIdType>;
+
+
+/* *********************************** *
+ * FONCTIONS NON MEMBRES DE TRUSTArray *
+ * *********************************** */
+
+#include <TRUSTArray_tools.tpp> // external templates function specializations ici ;)
+
+/* ******************************* *
+ * FONCTIONS MEMBRES DE TRUSTArray *
+ * ******************************* */
+
+#include <TRUSTArray_device.tpp> // OMP stuff
+#include <TRUSTArray_kokkos.tpp> // Kokkos stuff
+
+#include <TRUSTArray.tpp> // The rest here!
+
+#endif /* TRUSTArray_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUSTArray.tpp b/Utilities/VisItBridge/databases/readers/Lata/TRUSTArray.tpp
new file mode 100644
index 00000000..df2fcb4b
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUSTArray.tpp
@@ -0,0 +1,303 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef TRUSTArray_TPP_included
+#define TRUSTArray_TPP_included
+
+#include <string.h>
+#include <algorithm>
+#include <TRUSTTravPool.h>
+
+
+/*! Destroy array, potentially making block available again if this was a Trav
+ */
+template <typename _TYPE_, typename _SIZE_>
+inline TRUSTArray<_TYPE_, _SIZE_>::~TRUSTArray()
+{
+  detach_array(); // release all resources properly (esp. Trav!!)
+}
+
+/**
+ * Change the size of the array.
+ *
+ * This updates the underlying std::vector size.
+ *
+ * Conditions:
+ *  - if the size changes, type must not be a derived class of TRUSTArray.
+ *  - the array can not be resized if data is shared (ref_array)
+ *  - the array can not be resized if it is a 'ref_data'.
+ */
+template <typename _TYPE_, typename _SIZE_>
+inline void TRUSTArray<_TYPE_, _SIZE_>::resize_array(_SIZE_ new_size, RESIZE_OPTIONS opt)
+{
+  // Si le tableau change de taille, il doit etre du type TRUSTArray
+  assert(  ( mem_ == nullptr || (int)mem_->size() == new_size ) ||
+           std::string(typeid(*this).name()).find("TRUSTArray") != std::string::npos );
+  // ref_arrays can not be resized, except if they keep the same size
+  assert( size_array() == new_size || ref_count() <= 1 );
+  // ref_data can not be resized:
+  assert( span_.empty() || mem_ != nullptr );
+  resize_array_(new_size, opt);
+}
+
+/**  Methode virtuelle (dans Array_base) identique a resize_array(), permet de traiter
+ *   de facon generique les ArrOf, Vect et Tab. Si l'objet est de type TRUSTArray, appel a resize_array(n)
+ *
+ *   Prerequis: le tableau doit etre "resizable" (voir resize_array()). S'il est d'un type derive (Vect ou Tab),
+ *    il ne doit pas avoir de descripteur parallele si la taille est effectivement modifiee.
+ */
+template <typename _TYPE_, typename _SIZE_>
+inline void TRUSTArray<_TYPE_, _SIZE_>::resize_tab(_SIZE_ n, RESIZE_OPTIONS opt)
+{
+  resize_array(n, opt);
+}
+
+//  Change le mode d'allocation memoire lors des resize (voir VTRUSTdata et TRUST_ptr_trav)
+//   Exemple pour creer un tableau avec allocation temporaire:
+//    DoubleTab tab; // Creation d'un tableau vide
+//    tab.set_mem_storage(TEMP_STORAGE); // Changement de mode d'allocation
+//    tab.resize(n); // Allocation memoire
+template <typename _TYPE_, typename _SIZE_>
+inline void TRUSTArray<_TYPE_, _SIZE_>::set_mem_storage(const STORAGE storage)
+{
+  storage_type_ = storage;
+}
+
+
+/** Make the array point to the memory zone indicated by data_. The array is detached from its current underlying
+ * data ('mem_' is released).
+ *
+ * Warning: virtual method. In derived classes this method initializes the structures to create a sequential array.
+ * To create a ref on a parallel array, see DoubleVect::ref()
+ */
+template <typename _TYPE_, typename _SIZE_>
+inline void TRUSTArray<_TYPE_, _SIZE_>::ref_data(_TYPE_* ptr, _SIZE_ size)
+{
+  assert(ptr != 0 || size == 0);
+  assert(size >= 0);
+  assert(storage_type_ != STORAGE::TEMP_STORAGE);  // Not a Trav!
+  detach_array(); // ToDo OpenMP revenir en arriere sur TRUSTArray.h
+  span_ = Span_(ptr, size);
+}
+
+/** Make the current array point to the data of another existing array. Ownership of the data is hence shared.
+ *
+ * The current array is first detached (see detach_array()), and then attached to the provided data (see attach_array())
+ * Wanring: virtual -> in derived classes this method initializes structures to create a sequential array.
+ */
+template <typename _TYPE_, typename _SIZE_>
+inline void TRUSTArray<_TYPE_, _SIZE_>::ref_array(TRUSTArray& m, _SIZE_ start, _SIZE_ size)
+{
+  assert(&m != this);
+  assert(storage_type_ != STORAGE::TEMP_STORAGE);  // Not a Trav!
+  detach_array();
+  attach_array(m, start, size);
+}
+
+/** Copy the data from another array, potentially resizing.
+ * The storage type is not copied.
+ */
+template <typename _TYPE_, typename _SIZE_>
+inline TRUSTArray<_TYPE_,_SIZE_>& TRUSTArray<_TYPE_, _SIZE_>::operator=(const TRUSTArray& m)
+{
+  if (&m != this)
+    {
+      const _SIZE_ new_size = m.size_array();
+      // On utilise la methode resize_array() qui teste le type derive de l'objet (resize interdit sur un type derive)
+      resize_array(new_size, RESIZE_OPTIONS::NOCOPY_NOINIT);
+      inject_array(m);
+    }
+  return *this;
+}
+
+/**  operateur [] retourne le ieme element du tableau
+* Parametre: _SIZE_ i
+*    Signification: indice dans l'intervalle 0 <= i < size_array()
+* Exception: assert si i n'est pas dans l'intervalle
+*/
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_& TRUSTArray<_TYPE_, _SIZE_>::operator[](_SIZE_ i)
+{
+#ifdef _OPENMP_TARGET
+  this->ensureDataOnHost();
+#endif
+  assert(i >= 0 && i < size_array());
+  return span_[i];
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline const _TYPE_& TRUSTArray<_TYPE_, _SIZE_>::operator[](_SIZE_ i) const
+{
+#ifdef _OPENMP_TARGET
+  this->ensureDataOnHost();
+#endif
+  assert(i >= 0 && i < size_array());
+  // [ABN] We can not perform this check here, since we might be *setting* the value from an un-initialized state.
+  //       And an uninitialized state might well be completly off the bounds!
+  //  assert(span_[i] > -DMAXFLOAT && span_[i] < DMAXFLOAT);
+  return span_[i];
+}
+
+/** Returns a pointer on the first element of the array. nullptr will be returned if array is detached.
+ * Careful, address might change after a resize_array(), ref_data(), etc.
+ */
+template <typename _TYPE_, typename _SIZE_>
+inline _TYPE_* TRUSTArray<_TYPE_, _SIZE_>::addr()
+{
+  ensureDataOnHost();
+  return span_.data();
+}
+
+template <typename _TYPE_, typename _SIZE_>
+inline const _TYPE_* TRUSTArray<_TYPE_, _SIZE_>::addr() const
+{
+  ensureDataOnHost();
+  return span_.data();
+}
+
+template <typename _TYPE_, typename _SIZE_>
+inline _TYPE_ *TRUSTArray<_TYPE_, _SIZE_>::data()
+{
+  return span_.data();
+}
+
+template <typename _TYPE_, typename _SIZE_>
+inline const _TYPE_ *TRUSTArray<_TYPE_, _SIZE_>::data() const
+{
+  return span_.data();
+}
+
+/** Returns the size of the array.
+ */
+template <typename _TYPE_, typename _SIZE_>
+inline _SIZE_ TRUSTArray<_TYPE_, _SIZE_>::size_array() const
+{
+  return (_SIZE_)span_.size();
+}
+
+/** Returns the number of shared owners of the data underlying the array. If -1 detached array.
+  * This is simply the ref count of the shared pointer 'mem_'
+  */
+template <typename _TYPE_, typename _SIZE_>
+inline int TRUSTArray<_TYPE_, _SIZE_>::ref_count() const
+{
+  return mem_ ? (int)mem_.use_count() : -1;
+}
+
+/**  Ajoute une case en fin de tableau et y stocke la "valeur"
+ * Precondition:
+ *  Le tableau ne doit pas etre "ref_data",
+ *  et il ne doit pas y avoir plus d'une reference a la zone de memoire pointee (meme precondition que resize_array())
+ *  Le tableau doit etre de type TRUSTArray (pas un type derive)
+ */
+template <typename _TYPE_, typename _SIZE_>
+inline void TRUSTArray<_TYPE_, _SIZE_>::append_array(_TYPE_ valeur)
+{
+  this->ensureDataOnHost();
+  // Call the official resize, with all its checks and management of Trav:
+  const _SIZE_ sz = size_array();
+  resize_array_(sz+1, RESIZE_OPTIONS::NOCOPY_NOINIT);
+  operator[](sz) = valeur;
+}
+
+/**  Tri des valeurs du tableau dans l'ordre croissant. La fonction utilisee est qsort de stdlib (elle est en n*log(n)).
+ */
+template <typename _TYPE_, typename _SIZE_>
+inline void TRUSTArray<_TYPE_,_SIZE_>::ordonne_array()
+{
+  ensureDataOnHost();
+  std::sort(span_.begin(), span_.end());
+}
+
+/**  Tri des valeurs du tableau dans l'ordre croissant et suppresion des doublons La fonction utilisee est qsort de stdlib (elle est en n*log(n)).
+ */
+template <typename _TYPE_, typename _SIZE_>
+inline void TRUSTArray<_TYPE_, _SIZE_>::array_trier_retirer_doublons()
+{
+  ensureDataOnHost();
+  const _SIZE_ size_ = size_array();
+  if (size_ <= 0) return;
+
+  // Sort ascending
+  ordonne_array();
+
+  auto new_end = std::unique(span_.begin(), span_.end());
+
+  _SIZE_ new_size_ = (_SIZE_)std::distance(span_.begin(), new_end);
+  resize_array(new_size_);
+}
+
+/** Attach the array to (part of) an existing block of data stored in another array.
+ * The data is then shared between that other array and this.
+ *
+ * If size < 0, we take the data from the specified start till the end of the block.
+ * Array must be detached first before invoking this method.
+ * It is forbidden to attach to a ref_data.
+ */
+template <typename _TYPE_, typename _SIZE_>
+inline void TRUSTArray<_TYPE_, _SIZE_>::attach_array(const TRUSTArray& m, _SIZE_ start, _SIZE_ size)
+{
+  // Array must be detached
+  assert(span_.empty() && mem_ == nullptr);
+  // we might attach to an already detached array ... make sure that start and size are coherent
+  assert(m.mem_ != nullptr || (start == 0 && size <= 0));
+  // we don't attach to ourself:
+  assert(&m != this);
+  // we don't attach to a ref_data:
+  assert(! (m.mem_ == nullptr && !m.span_.empty()) );
+
+  if (size < 0)
+    size = m.size_array() - start;
+
+  assert(start >= 0 && size >=0 && start + size <= m.size_array());
+
+  // shared_ptr copy! One more owner for the underlying data - note we migth copy nullptr here ...
+  mem_ = m.mem_;
+
+  // Copy (shared) data location from m - locations will be synchronized automatically between ref arrays
+  data_location_ = m.data_location_;
+
+  // Copy storage type! A Tab might become a Trav ... (but not the other way around, see ref_*() methods and asserts)
+  storage_type_ = m.storage_type_;
+
+  // stupid enough, but we might have ref'ed a detached array ...
+  if (mem_ != nullptr)
+    span_ = Span_((_TYPE_ *)(m.span_.begin()+start), size);
+  else
+    span_ = Span_();
+}
+
+/** Bring the current array in a detached state, i.e. both 'mem_' and 'span_' are cleared, whatever the current state.
+*/
+template <typename _TYPE_, typename _SIZE_>
+inline bool TRUSTArray<_TYPE_, _SIZE_>::detach_array()
+{
+  if (mem_ != nullptr && ref_count() == 1)
+    {
+      if (storage_type_ == STORAGE::TEMP_STORAGE)
+        // Give it back to the pool of free blocks - this means a shared_ptr copy, memory will be preserved
+        TRUSTTravPool<_TYPE_>::ReleaseBlock(mem_);
+      else if (isAllocatedOnDevice(*this))
+        deleteOnDevice(*this); // Delete block memory on GPU
+    }
+
+  mem_ = nullptr;
+  span_ = Span_();
+  data_location_ = nullptr;
+
+  return true;
+}
+
+#endif /* TRUSTArray_TPP_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUSTArray_device.tpp b/Utilities/VisItBridge/databases/readers/Lata/TRUSTArray_device.tpp
new file mode 100644
index 00000000..c79760fd
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUSTArray_device.tpp
@@ -0,0 +1,106 @@
+/****************************************************************************
+ * Copyright (c) 2024, CEA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#ifndef TRUSTArr_device_TPP_included
+#define TRUSTArr_device_TPP_included
+
+#include <TRUSTArray.h>
+
+// Methodes de verification que le tableau est a jour sur le host:
+// ToDo OpenMP :Appels couteux (car non inlines?) depuis operator()[int] mais comment faire mieux ?
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTArray<_TYPE_,_SIZE_>::ensureDataOnHost() const
+{
+#if defined(_OPENMP_TARGET) && !defined(TRUST_USE_UVM)
+  if (get_data_location()==DataLocation::Device)
+    copyFromDevice(*this, "const detected with ensureDataOnHost()");
+#endif
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTArray<_TYPE_,_SIZE_>::ensureDataOnHost()
+{
+#if defined(_OPENMP_TARGET) && !defined(TRUST_USE_UVM)
+  const DataLocation& loc = get_data_location();
+  if (loc==DataLocation::Host || loc==DataLocation::HostOnly || loc==DataLocation::PartialHostDevice) return;
+  else if (loc==DataLocation::Device)
+    copyFromDevice(*this, "non-const detected with ensureDataOnHost()");
+  // On va modifier le tableau (non const) sur le host:
+  set_data_location(DataLocation::Host);
+#endif
+}
+
+// Fonction pour connaitre la localisation du tableau
+template<typename _TYPE_, typename _SIZE_>
+inline bool TRUSTArray<_TYPE_,_SIZE_>::isDataOnDevice() const
+{
+  DataLocation loc = get_data_location();
+  return loc == DataLocation::Device || loc == DataLocation::HostDevice;
+}
+
+// Fonctions checkDataOnDevice pour lancement conditionnel de kernels sur le device:
+// -Si les tableaux passes en parametre sont sur a jour sur le device
+// -Si ce n'est pas le cas, les tableaux sont copies sur le host via ensureDataOnHost
+template<typename _TYPE_, typename _SIZE_>
+inline bool TRUSTArray<_TYPE_,_SIZE_>::checkDataOnDevice() const
+{
+#ifdef _OPENMP_TARGET
+  bool flag = isDataOnDevice() && computeOnDevice;
+  if (!flag)
+    ensureDataOnHost();
+  //else
+  //  set_data_location(Device); // non const array will be computed on device
+  return flag;
+#else
+  return false;
+#endif
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline bool TRUSTArray<_TYPE_,_SIZE_>::checkDataOnDevice()
+{
+#ifdef _OPENMP_TARGET
+  bool flag = isDataOnDevice() && computeOnDevice;
+  if (!flag)
+    ensureDataOnHost();
+  else
+    set_data_location(DataLocation::Device); // non const array will be computed on device
+  return flag;
+#else
+  return false;
+#endif
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline bool TRUSTArray<_TYPE_,_SIZE_>::checkDataOnDevice(const TRUSTArray& tab_const)
+{
+#ifdef _OPENMP_TARGET
+  bool flag = isDataOnDevice() && tab_const.isDataOnDevice() && computeOnDevice;
+  // Si un des deux tableaux n'est pas a jour sur le device alors l'operation se fera sur le host:
+  if (!flag)
+    {
+      this->ensureDataOnHost();
+      tab_const.ensureDataOnHost();
+    }
+  else
+    set_data_location(DataLocation::Device); // non const array will be computed on device
+  return flag;
+#else
+  return false;
+#endif
+}
+
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUSTArray_kokkos.tpp b/Utilities/VisItBridge/databases/readers/Lata/TRUSTArray_kokkos.tpp
new file mode 100644
index 00000000..ac19f2a6
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUSTArray_kokkos.tpp
@@ -0,0 +1,191 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef TRUSTArr_kokkos_TPP_included
+#define TRUSTArr_kokkos_TPP_included
+
+#include <TRUSTArray.h>
+#ifdef KOKKOS
+// Create internal DualView member, and populate it with current host data
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTArray<_TYPE_,_SIZE_>::init_view_arr() const
+{
+  long ze_dim = this->size_array();
+
+  // change of alloc or resize triggers re-init (for now - resize could be done better)
+  if(dual_view_arr_.h_view.is_allocated() &&
+      dual_view_arr_.h_view.data() == this->data() &&
+      dual_view_arr_.view_device().data() == addrOnDevice(*this) &&
+      (long) dual_view_arr_.extent(0) == ze_dim)
+    return ;
+
+  using t_host = typename DualViewArr<_TYPE_>::t_host;  // Host type
+  using t_dev = typename DualViewArr<_TYPE_>::t_dev;    // Device type
+  //using size_type = typename DualViewArr<_TYPE_>::size_type;
+
+  //const std::string& nom = this->le_nom().getString();
+
+  // Re-use already TRUST allocated data:
+  t_host host_view = t_host(const_cast<_TYPE_ *>(this->data()), ze_dim);
+  // Empty view on device - just a memory allocation:
+  //t_dev device_view = t_dev(nom, ze_dim);
+  t_dev device_view;
+#ifdef _OPENMP_TARGET
+  // Device memory is allocated with OpenMP: ToDo replace by allocate ?
+  mapToDevice(*this, "Kokkos init_view_arr()");
+  device_view = t_dev(const_cast<_TYPE_ *>(addrOnDevice(*this)), ze_dim);
+#else
+  device_view = create_mirror_view_and_copy(Kokkos::DefaultExecutionSpace::memory_space(), host_view);
+#endif
+
+  // Dual view is made as an assembly of the two views:
+  dual_view_arr_ = DualViewArr<_TYPE_>(device_view, host_view);
+
+  // Mark data modified on host so it will be sync-ed to device later on:
+  dual_view_arr_.template modify<host_mirror_space>();
+}
+
+
+//////////// Read-Only ////////////////////////////
+// Device version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ConstViewArr<_TYPE_> >
+TRUSTArray<_TYPE_,_SIZE_>::view_ro() const
+{
+  // Init if necessary
+  init_view_arr();
+#ifdef _OPENMP_TARGET
+  mapToDevice(*this, "Kokkos TRUSTArray::view_ro()");
+#else
+  // Copy to device if needed (i.e. if modify() was called):
+  dual_view_arr_.template sync<memory_space>();
+#endif
+  // return *device* view:
+  return dual_view_arr_.view_device();
+}
+
+// Host version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, ConstHostViewArr<_TYPE_> >
+TRUSTArray<_TYPE_,_SIZE_>::view_ro() const
+{
+  return ConstHostViewArr<_TYPE_>(addr(), size_array());
+}
+
+//////////// Write-only ////////////////////////////
+// Device version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ViewArr<_TYPE_> >
+TRUSTArray<_TYPE_,_SIZE_>::view_wo()
+{
+  // Init if necessary
+  init_view_arr();
+#ifdef _OPENMP_TARGET
+  computeOnTheDevice(*this, "Kokkos TRUSTArray<_TYPE_,_SIZE_>::view_wo()"); // ToDo allouer sans copie ?
+#else
+  // Mark the (device) data as modified, so that the next sync() (to host) will copy:
+  dual_view_arr_.template modify<memory_space>();
+#endif
+  // return *device* view:
+  return dual_view_arr_.view_device();
+}
+
+// Host version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, HostViewArr<_TYPE_> >
+TRUSTArray<_TYPE_,_SIZE_>::view_wo()
+{
+  return HostViewArr<_TYPE_>(addr(), size_array());
+}
+
+//////////// Read-Write ////////////////////////////
+// Device version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ViewArr<_TYPE_> >
+TRUSTArray<_TYPE_,_SIZE_>::view_rw()
+{
+  // Init if necessary
+  init_view_arr();
+#ifdef _OPENMP_TARGET
+  computeOnTheDevice(*this, "Kokkos TRUSTArray::view_rw()");
+#else
+  // Copy to device (if needed) ...
+  dual_view_arr_.template sync<memory_space>();
+  // ... and mark the (device) data as modified, so that the next sync() (to host) will copy:
+  dual_view_arr_.template modify<memory_space>();
+#endif
+  // return *device* view:
+  return dual_view_arr_.view_device();
+}
+
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, HostViewArr<_TYPE_> >
+TRUSTArray<_TYPE_,_SIZE_>::view_rw()
+{
+  return HostViewArr<_TYPE_>(addr(), size_array());
+}
+
+
+/////////////////////////
+
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTArray<_TYPE_,_SIZE_>::sync_to_host() const
+{
+#ifdef _OPENMP_TARGET
+  Process::exit("ToDo");
+#endif
+  // Copy to host (if needed) ...
+  dual_view_arr_.template sync<host_mirror_space>();
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTArray<_TYPE_,_SIZE_>::modified_on_host() const
+{
+#ifdef _OPENMP_TARGET
+  Process::exit("ToDo");
+#endif
+  // Mark modified on host side:
+  if(dual_view_arr_.h_view.is_allocated())
+    dual_view_arr_.template modify<host_mirror_space>();
+}
+
+// Methode de debug
+template<typename _TYPE_, typename _SIZE_>
+void debug_device_view(const ViewArr<_TYPE_> view_tab, TRUSTArray<_TYPE_,_SIZE_>& tab, _SIZE_ max_size=-1)
+{
+  assert(view_tab.data()==addrOnDevice(tab)); // Verifie meme adress
+  Cout << "View size=" << view_tab.size() << finl;
+  _SIZE_ size = max_size;
+  if (size==-1) size = view_tab.extent(0);
+  Kokkos::parallel_for(size, KOKKOS_LAMBDA(const _SIZE_ i)
+  {
+    printf("[Kokkos]: %p [%2ld]=%e\n", view_tab.data(), i, view_tab(i));
+  });
+  Cout << "Tab size=" << tab.size_array() << finl;
+  assert(view_tab.size()==tab.size_array());
+  _TYPE_ *ptr = tab.data();
+  #pragma omp target teams distribute parallel for
+  for (_SIZE_ i=0; i<size; i++)
+    printf("[OpenMP]: %p [%2ld]=%e\n", ptr, i, ptr[i]);
+}
+#endif
+#endif
+
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUSTArray_tools.tpp b/Utilities/VisItBridge/databases/readers/Lata/TRUSTArray_tools.tpp
new file mode 100644
index 00000000..b306d1a3
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUSTArray_tools.tpp
@@ -0,0 +1,206 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef TRUSTArray_tools_TPP_included
+#define TRUSTArray_tools_TPP_included
+
+/*! @brief Renvoie 1 si les tableaux "v" et "a" sont de la meme taille et contiennent les memes valeurs au sens strict, sinon renvoie 0.
+ *
+ * Le test est !(v[i]!=a[i])
+ *
+ */
+template <typename _TYPE_, typename _SIZE_>
+bool operator==(const TRUSTArray<_TYPE_,_SIZE_>& v, const TRUSTArray<_TYPE_,_SIZE_>& a)
+{
+  const _SIZE_ n = v.size_array();
+  const _SIZE_ na = a.size_array();
+
+  if (n != na) return false;
+
+  v.ensureDataOnHost();
+  a.ensureDataOnHost();
+  const _TYPE_ * vv = v.addr();
+  const _TYPE_ * av = a.addr();
+  for (_SIZE_ i = 0; i < n; i++)
+    if (av[i] != vv[i])
+      return false;
+  return true;
+}
+
+/*! @brief Retourne l'indice du min ou -1 si le tableau est vide
+ *
+ */
+template <typename _TYPE_, typename _SIZE_> _SIZE_ imin_array(const TRUSTArray<_TYPE_,_SIZE_>& dx)
+{
+  _SIZE_ indice_min = -1;
+  const _SIZE_ size = dx.size_array();
+  if (size > 0)
+    {
+      indice_min = 0;
+      _TYPE_ valeur_min = dx[0];
+      for (_SIZE_ i = 1; i < size; i++)
+        {
+          const _TYPE_ val = dx[i];
+          if(val < valeur_min)
+            {
+              indice_min = i;
+              valeur_min = val;
+            }
+        }
+    }
+  return indice_min;
+}
+
+/*! @brief Retourne l'indice du max ou -1 si le tableau est vide
+ *
+ */
+template <typename _TYPE_, typename _SIZE_> _SIZE_ imax_array(const TRUSTArray<_TYPE_,_SIZE_>& dx)
+{
+  _SIZE_ indice_max = -1;
+  const _SIZE_ size = dx.size_array();
+  if (size > 0)
+    {
+      indice_max = 0;
+      _TYPE_ valeur_max = dx[0];
+      for (_SIZE_ i = 1; i < size; i++)
+        {
+          const _TYPE_ val = dx[i];
+          if(val > valeur_max)
+            {
+              indice_max = i;
+              valeur_max = val;
+            }
+        }
+    }
+  return indice_max;
+}
+
+/*! @brief Retourne la valeur minimale
+ *
+ */
+template <typename _TYPE_, typename _SIZE_>
+_TYPE_ min_array(const TRUSTArray<_TYPE_,_SIZE_>& dx)
+{
+  const _SIZE_ size = dx.size_array();
+  assert(size > 0);
+  _TYPE_ valeur_min = dx[0];
+  for (_SIZE_ i = 1; i < size; i++)
+    {
+      const _TYPE_ val = dx[i];
+      if (val < valeur_min) valeur_min = val;
+    }
+  return valeur_min;
+}
+
+/*! @brief Retourne la valeur maximale
+ *
+ */
+template <typename _TYPE_, typename _SIZE_>
+_TYPE_ max_array(const TRUSTArray<_TYPE_,_SIZE_>& dx)
+{
+  const _SIZE_ size = dx.size_array();
+  assert(size > 0);
+  _TYPE_ valeur_max = dx[0];
+  for (_SIZE_ i = 1; i < size; i++)
+    {
+      const _TYPE_ val = dx[i];
+      if (val > valeur_max) valeur_max = val;
+    }
+  return valeur_max;
+}
+
+// Absolute value for a scalar ....
+namespace
+{
+template <typename _TYPE_>
+inline _TYPE_ scalar_abs(_TYPE_ x)
+{
+  constexpr bool IS_INT = std::is_integral<_TYPE_>::value;
+  return IS_INT ? std::abs(x) : std::fabs(x);
+}
+}
+
+/*! @brief Retourne le max des abs(i)
+ */
+template <typename _TYPE_, typename _SIZE_>
+_TYPE_ max_abs_array(const TRUSTArray<_TYPE_,_SIZE_>& dx)
+{
+  const _SIZE_ size = dx.size_array();
+  assert(size > 0);
+  _TYPE_ valeur_max = ::scalar_abs(dx[0]);
+  for(_SIZE_ i = 1; i < size; i++)
+    {
+      const _TYPE_ val = ::scalar_abs(dx[i]);
+      if (val > valeur_max) valeur_max = val;
+    }
+  return valeur_max;
+}
+
+/*! @brief Retourne le min des abs(i)
+ *
+ */
+template <typename _TYPE_, typename _SIZE_>
+_TYPE_ min_abs_array(const TRUSTArray<_TYPE_,_SIZE_>& dx)
+{
+  const _SIZE_ size = dx.size_array();
+  assert(size > 0);
+  _TYPE_ v = ::scalar_abs(dx[0]);
+  for(_SIZE_ i = 1; i < size; i++)
+    {
+      const _TYPE_ val = ::scalar_abs(dx[i]);
+      if (val < v) v = val;
+    }
+  return v;
+}
+
+/*! @brief Produit scalaire de deux "array"  (dotproduct_array remplace operator* car le nom indique clairement  que l'on fait un produit scalaire non distribue)
+ *
+ */
+template <typename _TYPE_, typename _SIZE_>
+_TYPE_ dotproduct_array(const TRUSTArray<_TYPE_,_SIZE_>& dx, const TRUSTArray<_TYPE_,_SIZE_>& dy)
+{
+  const _SIZE_ size = dx.size_array();
+  assert(size == dy.size_array());
+  _TYPE_ resultat = 0.;
+  if (size > 0)
+    {
+      integer n = size;
+      integer incx = 1;
+      dx.ensureDataOnHost();
+      dy.ensureDataOnHost();
+      resultat = F77NAME(DDOT)(&n, dx.addr(), &incx, dy.addr(), &incx);
+    }
+  return resultat;
+}
+
+
+/*! @brief Calcul de la norme du vecteur dx (fonction blas DNRM2, soit racine carree(somme des dx[i]*dx[i]).
+ *
+ */
+template <typename _TYPE_, typename _SIZE_>
+_TYPE_ norme_array(const TRUSTArray<_TYPE_,_SIZE_>& dx)
+{
+  integer n = dx.size_array();
+  _TYPE_ resultat = 0.;
+  if (n > 0)
+    {
+      integer incx = 1;
+      dx.ensureDataOnHost();
+      resultat = F77NAME(DNRM2)(&n, &dx[0], &incx);
+    }
+  return resultat;
+}
+
+#endif /* TRUSTArray_tools_TPP_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUSTArrays.h b/Utilities/VisItBridge/databases/readers/Lata/TRUSTArrays.h
new file mode 100644
index 00000000..36c1d646
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUSTArrays.h
@@ -0,0 +1,26 @@
+/****************************************************************************
+* Copyright (c) 2023, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef TRUSTArrays_included
+#define TRUSTArrays_included
+
+#include <TRUST_Vector.h>
+#include <TRUSTArray.h>
+
+// BYE BYE MACRO !! ahahaha
+using ArrsOfDouble = TRUST_Vector<TRUSTArray<double>>; // remplace VECT(ArrOfDouble)
+using ArrsOfInt = TRUST_Vector<TRUSTArray<int>>; // remplace VECT(ArrOfInt)
+
+#endif /* TRUSTArrays_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUSTTab.h b/Utilities/VisItBridge/databases/readers/Lata/TRUSTTab.h
new file mode 100644
index 00000000..e067abe7
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUSTTab.h
@@ -0,0 +1,402 @@
+/****************************************************************************
+* Copyright (c) 2025, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef TRUSTTab_included
+#define TRUSTTab_included
+
+#include <MD_Vector_base.h>
+#include <TRUSTVect.h>
+#include <math.h>
+
+#include <View_Types.h>  // Kokkos stuff
+
+/*! @brief : Tableau a n entrees pour n<= 4.
+ *
+ * Repose sur un TRUSTVect avec calculs de l'indice corespondant
+ *
+ */
+template<typename _TYPE_, typename _SIZE_>
+class TRUSTTab : public TRUSTVect<_TYPE_,_SIZE_>
+{
+protected:
+  inline unsigned taille_memoire() const override { throw; }
+
+  inline int duplique() const override
+  {
+    TRUSTTab* xxx = new  TRUSTTab(*this);
+    if(!xxx) Process::exit("Not enough memory ");
+    return xxx->numero();
+  }
+
+  /*! @brief ecriture d'un tableau sequentiel (idem que TRUSTVect::printOn() on ne sait pas quoi faire de pertinent pour un tableau distribue).
+   *
+   */
+  Sortie& printOn(Sortie& os) const override
+  {
+#ifndef LATATOOLS
+    assert(verifie_LINE_SIZE());
+    if (TRUSTVect<_TYPE_,_SIZE_>::nproc() > 1 && TRUSTVect<_TYPE_,_SIZE_>::get_md_vector().non_nul())
+      Process::exit("Error in TRUSTTab::printOn: try to print a parallel vector");
+    os << nb_dim_ << finl;
+    assert(dimensions_[0] == dimension_tot_0_);
+    if (nb_dim_ > 0) os.put(dimensions_, nb_dim_, nb_dim_);
+
+    const _SIZE_ sz = TRUSTVect<_TYPE_,_SIZE_>::size_array();
+    os << sz << finl;
+    const int l_size = TRUSTVect<_TYPE_,_SIZE_>::line_size();
+    const _TYPE_ *data = TRUSTVect<_TYPE_,_SIZE_>::addr();
+
+    if (sz > 0)  os.put(data, sz, l_size);
+#endif
+    return os;
+  }
+
+  /*! @brief lecture d'un tableau sequentiel
+   *
+   */
+  Entree& readOn(Entree& is) override
+  {
+#ifndef LATATOOLS
+    // Que veut-on faire si on lit dans un vecteur ayant deja une structure parallele ?
+    if (TRUSTVect<_TYPE_,_SIZE_>::get_md_vector().non_nul())
+      Process::exit("Error in TRUSTTab::readOn: vector has a parallel structure");
+
+    is >> nb_dim_;
+    if (nb_dim_ < 1 || nb_dim_ > MAXDIM_TAB)
+      {
+        Cerr << "Error in TRUSTTab::readOn: wrong nb_dim_ = " << nb_dim_ << finl;
+        Process::exit();
+      }
+    is.get(dimensions_, nb_dim_);
+    if (dimensions_[0] < 0)
+      {
+        Cerr << "Error in TRUSTTab::readOn: wrong dimension(0) = " << dimensions_[0] << finl;
+        Process::exit();
+      }
+    int l_size = 1;
+    for (int i = 1; i < nb_dim_; i++)
+      {
+        if (dimensions_[i] < 0)
+          {
+            Cerr << "Error in TRUSTTab::readOn: wrong dimension(" << i << ") = " << dimensions_[i] << finl;
+            Process::exit();
+          }
+        l_size *= (int)dimensions_[i];
+      }
+    dimension_tot_0_ = dimensions_[0];
+    TRUSTVect<_TYPE_,_SIZE_>::readOn(is);
+    TRUSTVect<_TYPE_,_SIZE_>::set_line_size_(l_size);
+    if (dimension_tot_0_ * l_size != TRUSTVect<_TYPE_,_SIZE_>::size_array())
+      {
+        Cerr << "Error in TRUSTTab::readOn: wrong size_array " << TRUSTVect<_TYPE_,_SIZE_>::size_array() << ", expected " << dimension_tot_0_ * l_size << finl;
+        Process::exit();
+      }
+    assert(verifie_LINE_SIZE());
+#endif
+    return is;
+  }
+
+public:
+  // Useful for from_tid_to_int() method implementation.
+  friend TRUSTTab<int, int>;
+
+  TRUSTTab() : nb_dim_(1), dimension_tot_0_(0)
+  {
+    init_dimensions(dimensions_);
+    dimensions_[0] = 0;
+  }
+
+  TRUSTTab(const TRUSTTab& dbt): TRUSTVect<_TYPE_,_SIZE_>(dbt), nb_dim_(dbt.nb_dim_), dimension_tot_0_(dbt.dimension_tot_0_)
+  {
+    for (int i = 0; i < MAXDIM_TAB; i++) dimensions_[i] = dbt.dimensions_[i];
+  }
+
+  TRUSTTab(_SIZE_ n) : TRUSTVect<_TYPE_,_SIZE_>(n), nb_dim_(1), dimension_tot_0_(n)
+  {
+    init_dimensions(dimensions_);
+    dimensions_[0] = n;
+  }
+
+  TRUSTTab(_SIZE_ n1, int n2): TRUSTVect<_TYPE_,_SIZE_>(n1*n2), nb_dim_(2), dimension_tot_0_(n1)
+  {
+    assert(n1 >= 0 && n2 >= 0);
+    if (std::is_same<_TYPE_,int>::value && (long)n1*(long)n2 > (long)std::numeric_limits<int>::max())
+      {
+        Cerr << "n1*n2 > 2^31. Error! Contact TRUST support, integer 32 bits limit exceeded with n1=" << n1 << " and n2=" << n2 << finl;
+        Process::exit();
+      }
+    init_dimensions(dimensions_);
+    dimensions_[0]=n1;
+    dimensions_[1]=n2;
+    TRUSTVect<_TYPE_,_SIZE_>::set_line_size_(n2);
+  }
+
+  TRUSTTab(_SIZE_ n1, int n2, int n3) : TRUSTVect<_TYPE_,_SIZE_>(n1*n2*n3), nb_dim_(3), dimension_tot_0_(n1)
+  {
+    assert(n1 >= 0 && n2 >= 0 && n3 >= 0);
+    if (std::is_same<_TYPE_,int>::value && (long)n1*(long)n2*(long)n3 > (long)std::numeric_limits<int>::max())
+      {
+        Cerr << "n1*n2*n3 > 2^31. Error! Contact TRUST support, integer 32 bits limit exceeded with n1=" << n1 << " and n2=" << n2 << " and n3=" << n3 << finl;
+        Process::exit();
+      }
+    init_dimensions(dimensions_);
+    dimensions_[0]=n1;
+    dimensions_[1]=n2;
+    dimensions_[2]=n3;
+    TRUSTVect<_TYPE_,_SIZE_>::set_line_size_(n2*n3);
+  }
+
+  TRUSTTab(_SIZE_ n1, int n2, int n3, int n4) : TRUSTVect<_TYPE_,_SIZE_>(n1*n2*n3*n4), nb_dim_(4), dimension_tot_0_(n1)
+  {
+    assert(n1 >= 0 && n2 >= 0 && n3 >= 0 && n4 >= 0);
+    if (std::is_same<_TYPE_,int>::value && (long)n1*(long)n2*(long)n3*(long)n4 > (long)std::numeric_limits<int>::max())
+      {
+        Cerr << "n1*n2*n3*n4 > 2^31. Error! Contact TRUST support, integer 32 bits limit exceeded with n1=" << n1 << " and n2=" << n2 << " and n3=" << n3 << " and n3=" << n3 << finl;
+        Process::exit();
+      }
+    init_dimensions(dimensions_);
+    dimensions_[0]=n1;
+    dimensions_[1]=n2;
+    dimensions_[2]=n3;
+    dimensions_[3]=n4;
+    TRUSTVect<_TYPE_,_SIZE_>::set_line_size_(n2*n3*n4);
+  }
+
+  inline void resize_dim0(_SIZE_ n, RESIZE_OPTIONS opt=RESIZE_OPTIONS::COPY_INIT);
+  inline void resize(_SIZE_ n, RESIZE_OPTIONS opt=RESIZE_OPTIONS::COPY_INIT);
+  inline void resize(_SIZE_ n1, int n2, RESIZE_OPTIONS opt=RESIZE_OPTIONS::COPY_INIT);
+  inline void resize(_SIZE_ n1, int n2, int n3, RESIZE_OPTIONS opt=RESIZE_OPTIONS::COPY_INIT);
+  inline void resize(_SIZE_ n1, int n2, int n3, int n4, RESIZE_OPTIONS opt=RESIZE_OPTIONS::COPY_INIT);
+  inline void resize(const TRUSTArray<_SIZE_,int>& tailles, RESIZE_OPTIONS opt=RESIZE_OPTIONS::COPY_INIT);
+  inline void copy(const TRUSTTab&, RESIZE_OPTIONS opt=RESIZE_OPTIONS::COPY_INIT);
+  inline void append_line(_TYPE_);
+  inline void append_line(_TYPE_, _TYPE_);
+  inline void append_line(_TYPE_, _TYPE_, _TYPE_);
+  inline void append_line(_TYPE_, _TYPE_, _TYPE_, _TYPE_);
+
+  // See doc in .tpp file!
+  _SIZE_ dimension(int d) const;
+  int dimension_int(int d) const;
+
+  inline _SIZE_ dimension_tot(int) const;
+  inline int nb_dim() const { return nb_dim_; }
+
+  // See same method in TRUSTArray - CAREFUL, this is not an override because arg types are different (tab vs arr)
+  inline void from_tid_to_int(TRUSTTab<int, int>& out) const;
+
+  inline TRUSTTab& operator=(const TRUSTTab&);
+  inline TRUSTTab& operator=(const TRUSTVect<_TYPE_,_SIZE_>&);
+  inline TRUSTTab& operator=(_TYPE_ d);
+  inline _TYPE_& operator()(const TRUSTArray<_SIZE_,int>& indice);
+  inline _TYPE_ operator()(const TRUSTArray<_SIZE_,int>& indice) const;
+  inline _TYPE_& operator[](_SIZE_ i);
+  inline const _TYPE_& operator[](_SIZE_ i) const ;
+  inline _TYPE_& operator()(_SIZE_ i);
+  inline const _TYPE_& operator()(_SIZE_ i) const ;
+  inline _TYPE_& operator()(_SIZE_ i1, int i2);
+  inline const _TYPE_& operator()(_SIZE_ i1, int i2) const ;
+  inline _TYPE_& operator()(_SIZE_ i1, int i2, int i3);
+  inline const _TYPE_& operator()(_SIZE_ i1, int i2, int i3) const ;
+  inline _TYPE_& operator()(_SIZE_ i1, int i2, int i3, int i4);
+  inline const _TYPE_& operator()(_SIZE_ i1, int i2, int i3, int i4) const ;
+
+  // Juste pour TRUSTTab<double/float>
+  template <typename _T_> inline void ajoute_produit_tensoriel(_T_ alpha, const TRUSTTab<_T_,_SIZE_>&, const TRUSTTab<_T_,_SIZE_>&); // z+=alpha*x*y;
+  template <typename _T_> inline void resoud_LU(_SIZE_, TRUSTArray<int,_SIZE_>&, const TRUSTArray<_T_,_SIZE_>&, TRUSTArray<_T_,_SIZE_>&);
+  template <typename _T_> inline bool inverse_LU(const TRUSTArray<_T_,_SIZE_>&, TRUSTArray<_T_,_SIZE_>&);
+  template <typename _T_> inline bool decomp_LU(_SIZE_, TRUSTArray<int,_SIZE_>&, TRUSTTab<_T_,_SIZE_>&);
+  template <typename _T_> inline _T_ max_du_u(const TRUSTTab<_T_,_SIZE_>&);
+
+  void ajoute_produit_tensoriel(int alpha, const TRUSTTab<int,_SIZE_>&, const TRUSTTab<int,_SIZE_>&) = delete; // z+=alpha*x*y;
+  void resoud_LU(int, TRUSTArray<int,_SIZE_>&, const TRUSTArray<int,_SIZE_>&, TRUSTArray<int,_SIZE_>&) = delete;
+  int inverse_LU(const TRUSTArray<int,_SIZE_>&, TRUSTArray<int,_SIZE_>&) = delete;
+  int decomp_LU(int, TRUSTArray<int,_SIZE_>&, TRUSTTab<int,_SIZE_>&) = delete;
+  int max_du_u(const TRUSTTab<int,_SIZE_>&) = delete;
+
+  // methodes virtuelles
+  inline virtual void ref(const TRUSTTab&);
+  inline virtual void ref_tab(TRUSTTab&, _SIZE_ start_line=0, _SIZE_ nb_lines=-1);
+  inline void set_md_vector(const MD_Vector&) override;
+  inline void jump(Entree&) override;
+  inline void lit(Entree&, bool resize_and_read=true) override;
+  inline void ecrit(Sortie&) const override;
+  inline void ref(const TRUSTVect<_TYPE_,_SIZE_>&) override;
+  inline void ref_data(_TYPE_* ptr, _SIZE_ size) override;
+  inline void ref_array(TRUSTArray<_TYPE_,_SIZE_>&, _SIZE_ start=0, _SIZE_ sz=-1) override;
+  inline void reset() override;
+  inline void resize_tab(_SIZE_ n, RESIZE_OPTIONS opt=RESIZE_OPTIONS::COPY_INIT) override;
+
+public:
+#ifdef KOKKOS
+  // Kokkos view accessors:
+  // Read only
+  template <typename EXEC_SPACE = Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ConstViewTab<_TYPE_> >
+  view_ro() const;
+  template <typename EXEC_SPACE = Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, ConstHostViewTab<_TYPE_> >
+  view_ro() const;
+
+  // Write only
+  template <typename EXEC_SPACE = Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ViewTab<_TYPE_> >
+  view_wo();
+  template <typename EXEC_SPACE = Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, HostViewTab<_TYPE_> >
+  view_wo();
+
+  // Read-write
+  template <typename EXEC_SPACE = Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ViewTab<_TYPE_> >
+  view_rw();
+  template <typename EXEC_SPACE = Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, HostViewTab<_TYPE_> >
+  view_rw();
+
+  inline void sync_to_host() const;             // Synchronize back to host
+  inline void modified_on_host() const;         // Mark data as being modified on host side
+
+  // For 3D arrays:
+  // Read only
+  template <typename EXEC_SPACE = Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ConstViewTab3<_TYPE_> >
+  view3_ro() const;
+  template <typename EXEC_SPACE = Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, ConstHostViewTab3<_TYPE_> >
+  view3_ro() const;
+
+  // Write only
+  template <typename EXEC_SPACE = Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ViewTab3<_TYPE_> >
+  view3_wo();
+  template <typename EXEC_SPACE = Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, HostViewTab3<_TYPE_> >
+  view3_wo();
+
+  // Read-write
+  template <typename EXEC_SPACE = Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ViewTab3<_TYPE_> >
+  view3_rw();
+  template <typename EXEC_SPACE = Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, HostViewTab3<_TYPE_> >
+  view3_rw();
+
+  inline void sync_to_host3() const;             // Synchronize back to host
+  inline void modified_on_host3() const;         // Mark data as being modified on host side
+
+  // For 4D arrays:
+  // Read only
+  template <typename EXEC_SPACE = Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ConstViewTab4<_TYPE_> >
+  view4_ro() const;
+  template <typename EXEC_SPACE = Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, ConstHostViewTab4<_TYPE_> >
+  view4_ro() const;
+
+  // Write only
+  template <typename EXEC_SPACE = Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ViewTab4<_TYPE_> >
+  view4_wo();
+  template <typename EXEC_SPACE = Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, HostViewTab4<_TYPE_> >
+  view4_wo();
+
+  // Read-write
+  template <typename EXEC_SPACE = Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ViewTab4<_TYPE_> >
+  view4_rw();
+  template <typename EXEC_SPACE = Kokkos::DefaultExecutionSpace>
+  inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, HostViewTab4<_TYPE_> >
+  view4_rw();
+
+  inline void sync_to_host4() const;             // Synchronize back to host
+  inline void modified_on_host4() const;         // Mark data as being modified on host side
+#endif
+
+private:
+  static constexpr int MAXDIM_TAB = 4;
+  // Nombre de dimensions du tableau (nb_dim_>=1)
+  int nb_dim_;
+
+  /*! Dimensions "reelles" (dimensions_[0] * line_size() = size_reelle()) : line_size() est egal au produit des dimensions_[i] pour 1 <= i < nb_dim_
+   *  Everything is stored as _SIZE_ but higher dims (>=1) should fit in an int. See line_size().
+   */
+  _SIZE_ dimensions_[MAXDIM_TAB];
+
+  // Dimension totale (nombre de lignes du tableau) = nb lignes reeles + nb lignes virtuelles
+  // Les dimensions dimension_tot(i>=1) sont implicitement egales a dimension(i)
+  _SIZE_ dimension_tot_0_;
+
+#ifdef KOKKOS
+  // Kokkos members
+protected:
+
+  inline void init_view_tab2() const;
+  inline void init_view_tab3() const;
+  inline void init_view_tab4() const;
+  mutable DualViewTab<_TYPE_> dual_view_tab2_;      // For 2D case : A(i,j)
+  mutable DualViewTab3<_TYPE_> dual_view_tab3_;      // For 3D case : A(i,j,k)
+  mutable DualViewTab4<_TYPE_> dual_view_tab4_;      // For 4D case : A(i,j,k,l)
+#endif
+
+  inline void verifie_MAXDIM_TAB() const
+  {
+    if (MAXDIM_TAB != 4)
+      {
+        Cerr << "Update code for MAXDIM_TAB for CHECK_LINE_SIZE" << finl;
+        throw;
+      }
+  }
+
+  inline bool verifie_LINE_SIZE() const
+  {
+    return ((TRUSTVect<_TYPE_,_SIZE_>::line_size() == ((nb_dim_ > 1) ? dimensions_[1] : 1) * ((nb_dim_ > 2) ? dimensions_[2] : 1) * ((nb_dim_ > 3) ? dimensions_[3] : 1))
+            && (TRUSTVect<_TYPE_,_SIZE_>::line_size() * dimension_tot_0_ == TRUSTVect<_TYPE_,_SIZE_>::size_array()));
+  }
+
+  inline void init_dimensions(_SIZE_ * tab)
+  {
+#ifndef NDEBUG
+    for (int i = 0; i < MAXDIM_TAB; i++) tab[i] = -1;
+#endif
+  }
+};
+
+using DoubleTab = TRUSTTab<double, int>;
+using FloatTab = TRUSTTab<float, int>;
+using IntTab = TRUSTTab<int, int>;
+using TIDTab = TRUSTTab<trustIdType, int>;
+
+template <typename _TYPE_>
+using BigTRUSTTab = TRUSTTab<_TYPE_, trustIdType>;
+
+using BigDoubleTab = BigTRUSTTab<double>;
+using BigIntTab = BigTRUSTTab<int>;
+using BigTIDTab = BigTRUSTTab<trustIdType>;
+
+/* ********************************* *
+ * FONCTIONS NON MEMBRES DE TRUSTTab *
+ * ********************************* */
+
+#include <TRUSTTab_tools.tpp> // external templates function specializations ici ;)
+
+/* ***************************** *
+ * FONCTIONS MEMBRES DE TRUSTTab *
+ * ***************************** */
+
+#include <TRUSTTab_kokkos.tpp> // Kokkos stuff
+#include <TRUSTTab.tpp> // The rest here!
+
+#endif /* TRUSTTab_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUSTTab.tpp b/Utilities/VisItBridge/databases/readers/Lata/TRUSTTab.tpp
new file mode 100644
index 00000000..31796b01
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUSTTab.tpp
@@ -0,0 +1,857 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef TRUSTTab_TPP_included
+#define TRUSTTab_TPP_included
+
+#include <TRUSTTab.h>
+
+// TODO : FIXME : delete
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_& TRUSTTab<_TYPE_,_SIZE_>::operator[](_SIZE_ i)
+{
+  assert(nb_dim_ == 1 || (nb_dim_ == 2 && dimensions_[1] == 1));
+  assert(i >= 0 && i < dimension_tot_0_);
+  return TRUSTVect<_TYPE_,_SIZE_>::operator[](i);
+}
+
+// TODO : FIXME : delete
+template<typename _TYPE_, typename _SIZE_>
+inline const _TYPE_& TRUSTTab<_TYPE_,_SIZE_>::operator[](_SIZE_ i) const
+{
+  assert(nb_dim_ == 1 || (nb_dim_ == 2 && dimensions_[1] == 1));
+  assert(i >= 0 && i < dimension_tot_0_);
+  return TRUSTVect<_TYPE_,_SIZE_>::operator[](i);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_& TRUSTTab<_TYPE_,_SIZE_>::operator()(_SIZE_ i)
+{
+  assert(nb_dim_ == 1 || (nb_dim_ == 2 && dimensions_[1] == 1));
+  assert(i >= 0 && i < dimension_tot_0_);
+  return TRUSTVect<_TYPE_,_SIZE_>::operator[](i);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline const _TYPE_& TRUSTTab<_TYPE_,_SIZE_>::operator()(_SIZE_ i) const
+{
+  assert(nb_dim_ == 1 || (nb_dim_ == 2 && dimensions_[1] == 1));
+  assert(i >= 0 && i < dimension_tot_0_);
+  return TRUSTVect<_TYPE_,_SIZE_>::operator[](i);
+}
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wstrict-overflow"
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_& TRUSTTab<_TYPE_,_SIZE_>::operator()(_SIZE_ i1, int i2)
+{
+  assert(nb_dim_ == 2);
+  assert(i1 >= 0 && i1 < dimension_tot_0_);
+  assert(i2 >= 0 && i2 < dimensions_[1]);
+  return TRUSTVect<_TYPE_,_SIZE_>::operator[](i1*dimensions_[1]+i2);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline const _TYPE_& TRUSTTab<_TYPE_,_SIZE_>::operator()(_SIZE_ i1, int i2) const
+{
+  assert(nb_dim_ == 2);
+  assert(i1 >= 0 && i1 < dimension_tot_0_);
+  assert(i2 >= 0 && i2 < dimensions_[1]);
+  return TRUSTVect<_TYPE_,_SIZE_>::operator[](i1*dimensions_[1]+i2);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_& TRUSTTab<_TYPE_,_SIZE_>::operator()(_SIZE_ i1, int i2, int i3)
+{
+  assert(nb_dim_ == 3);
+  assert(i1 >= 0 && i1 < dimension_tot_0_);
+  assert(i2 >= 0 && i2 < dimensions_[1]);
+  assert(i3 >= 0 && i3 < dimensions_[2]);
+  return TRUSTVect<_TYPE_,_SIZE_>::operator[]((i1*dimensions_[1]+i2)*dimensions_[2]+i3);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline const _TYPE_& TRUSTTab<_TYPE_,_SIZE_>::operator()(_SIZE_ i1, int i2, int i3) const
+{
+  assert(nb_dim_ == 3);
+  assert(i1 >= 0 && i1 < dimension_tot_0_);
+  assert(i2 >= 0 && i2 < dimensions_[1]);
+  assert(i3 >= 0 && i3 < dimensions_[2]);
+  return TRUSTVect<_TYPE_,_SIZE_>::operator[]((i1*dimensions_[1]+i2)*dimensions_[2]+i3);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_& TRUSTTab<_TYPE_,_SIZE_>::operator()(_SIZE_ i1, int i2, int i3, int i4)
+{
+  assert(nb_dim_ == 4);
+  assert(i1 >= 0 && i1 < dimension_tot_0_);
+  assert(i2 >= 0 && i2 < dimensions_[1]);
+  assert(i3 >= 0 && i3 < dimensions_[2]);
+  assert(i4 >= 0 && i4 < dimensions_[3]);
+  return TRUSTVect<_TYPE_,_SIZE_>::operator[](((i1*dimensions_[1]+i2)*dimensions_[2]+i3)*dimensions_[3]+i4);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline const _TYPE_& TRUSTTab<_TYPE_,_SIZE_>::operator()(_SIZE_ i1, int i2, int i3, int i4) const
+{
+  assert(nb_dim_ == 4);
+  assert(i1 >= 0 && i1 < dimension_tot_0_);
+  assert(i2 >= 0 && i2 < dimensions_[1]);
+  assert(i3 >= 0 && i3 < dimensions_[2]);
+  assert(i4 >= 0 && i4 < dimensions_[3]);
+  return TRUSTVect<_TYPE_,_SIZE_>::operator[](((i1*dimensions_[1]+i2)*dimensions_[2]+i3)*dimensions_[3]+i4);
+}
+#pragma GCC diagnostic pop
+
+/*!  Returns one of the "real" dimensions of the multi-dimensionnal array, as defined by:
+ *   dimension(0) = size_reelle() / line_size(), or 0 if line_size()==0
+ *  and, for i >= 1 : dimension(i) is equal to dimension_tot(i)
+ *  If TRUSTVect<_TYPE_,_SIZE_>::size_reelle_ok() returns 0, it is invalid to ask for dimension(0). You can only ask for dimension_tot(0) (see TRUSTVect<_TYPE_,_SIZE_>::size_reelle_ok())
+ *
+ *  In 64 bits, dimensions higher than 1 can always safely be casted down to an int, only the first dimension might be big.
+ *  To help with this, the _RET_TYPE_ parameter can be used. One can write:
+ *        int d1 = toto.dimension<int>(1);
+ *  which is cleaner than doing a wild cast like
+ *        int d1 = (int)toto.dimension(1);
+ *  and it will also check for potential overflow (with an assert).
+ *  This type of pattern is used in the 64b part of the code (before Scatter) when retreiving higher dimensions of arrays.
+ *  See arch.h.in for more explanations on 64b.
+ */
+template<typename _TYPE_, typename _SIZE_>
+inline _SIZE_ TRUSTTab<_TYPE_,_SIZE_>::dimension(int i) const
+{
+  assert(i >= 0 && i < nb_dim_);
+  // Si dimension_[0] == -1, c'est que c'est un vecteur distribue et que l'attribut size() est invalide. Il faut alors utiliser dimension_tot pour ce tableau.
+  assert(dimensions_[i] >= 0);
+  assert(i == 0 || dimensions_[i] < std::numeric_limits<int>::max());
+  return dimensions_[i];
+}
+
+/*! In 64 bits, dimensions higher than 1 can always safely be casted down to an int, only the first dimension might be big.
+*  To help with this, this method can be used. One can write:
+*        int d1 = toto.dimension_int(1);
+*  which is cleaner than doing a wild cast like
+*        int d1 = (int)toto.dimension(1);
+*  and it will also check for potential overflow (with an assert).
+*  This type of pattern is used in the 64b part of the code (before Scatter) when retrieving higher dimensions of arrays.
+*  See arch.h.in for more explanations on 64b.
+*/
+template<typename _TYPE_, typename _SIZE_>
+inline int TRUSTTab<_TYPE_,_SIZE_>::dimension_int(int i) const
+{
+  assert(i > 0);
+  return static_cast<int>(dimension(i));  // overflow check down above
+}
+
+//  Returns the total dimensions of the multi-dimensionnal array, including virtual items (used in parallel distributed arrays)
+template<typename _TYPE_, typename _SIZE_>
+inline _SIZE_ TRUSTTab<_TYPE_,_SIZE_>::dimension_tot(int i) const
+{
+  assert(i >= 0 && i < nb_dim_);
+  return (i == 0) ? dimension_tot_0_ : dimensions_[i];
+}
+
+/*!
+ * See doc in TRUSTArray. This one also deals with multi-dim.
+ */
+template<>
+inline void TRUSTTab<trustIdType,trustIdType>::from_tid_to_int(TRUSTTab<int, int>& out) const
+{
+  // Manage multi-dim structure - I could not copy members directly because TRUSTTab<tid,tid>
+  // can't see internals of TRUSTTab<int,int> and I could not get the 'friend' clause to work there ...
+  ArrOfInt sizes;
+  sizes.resize_array(nb_dim_);
+  for (int i = 0; i < nb_dim_; i++)
+    {
+      assert(dimensions_[i] < std::numeric_limits<int>::max());
+      sizes[i] = (int)dimensions_[i];
+    }
+  out.resize(sizes);
+
+  // Do the job as if an array:
+  TRUSTArray::from_tid_to_int(out);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+void TRUSTTab<_TYPE_,_SIZE_>::from_tid_to_int(TRUSTTab<int, int>& out) const
+{
+  // Should no be used for anything else than specialisations listed above.
+  assert(false);
+  Process::exit("TRUSTTab<>::from_tid_to_int() should not be used with those current template types.");
+}
+
+
+
+//  Adds 1 to dimension_tot(0) and puts a in the added line.
+// Precondition: line_size() must be equal to 1 and the array must be resizable.
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::append_line(_TYPE_ a)
+{
+  this->ensureDataOnHost();
+  assert( (TRUSTVect<_TYPE_,_SIZE_>::line_size() == 1) );
+  assert( (dimension_tot_0_ * TRUSTVect<_TYPE_,_SIZE_>::line_size() == TRUSTVect<_TYPE_,_SIZE_>::size_array()) );
+  const _SIZE_ n = dimension_tot_0_;
+  dimensions_[0] = ++dimension_tot_0_;
+  TRUSTVect<_TYPE_,_SIZE_>::resize_vect_(n+1, RESIZE_OPTIONS::COPY_NOINIT);
+  _TYPE_ * ptr = TRUSTVect<_TYPE_,_SIZE_>::addr() + n;
+  ptr[0] = a;
+}
+
+//  Adds 1 to dimension_tot(0) and puts a and b in the added line.
+// Precondition: line_size() must be equal to 2 and the array must be resizable.
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::append_line(_TYPE_ a, _TYPE_ b)
+{
+  this->ensureDataOnHost();
+  assert( (TRUSTVect<_TYPE_,_SIZE_>::line_size() == 2) );
+  assert( (dimension_tot_0_ * TRUSTVect<_TYPE_,_SIZE_>::line_size() == TRUSTVect<_TYPE_,_SIZE_>::size_array()) );
+  const _SIZE_ n = dimension_tot_0_ * 2;
+  dimensions_[0] = ++dimension_tot_0_;
+  TRUSTVect<_TYPE_,_SIZE_>::resize_vect_(n+2, RESIZE_OPTIONS::COPY_NOINIT);
+  _TYPE_ * ptr = TRUSTVect<_TYPE_,_SIZE_>::addr() + n;
+  ptr[0] = a;
+  ptr[1] = b;
+}
+
+//  Like append_line(i,j), but for arrays with line_size()==3
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::append_line(_TYPE_ a, _TYPE_ b, _TYPE_ c)
+{
+  this->ensureDataOnHost();
+  assert( (TRUSTVect<_TYPE_,_SIZE_>::line_size() == 3) );
+  assert( (dimension_tot_0_  * TRUSTVect<_TYPE_,_SIZE_>::line_size() == TRUSTVect<_TYPE_,_SIZE_>::size_array()) );
+  const _SIZE_ n = dimension_tot_0_ * 3;
+  dimensions_[0] = ++dimension_tot_0_;
+  TRUSTVect<_TYPE_,_SIZE_>::resize_vect_(n+3, RESIZE_OPTIONS::COPY_NOINIT);
+  _TYPE_ * ptr = TRUSTVect<_TYPE_,_SIZE_>::addr() + n;
+  ptr[0] = a;
+  ptr[1] = b;
+  ptr[2] = c;
+}
+
+//  Like append_line(i,j), but for arrays with line_size()==4
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::append_line(_TYPE_ a, _TYPE_ b, _TYPE_ c, _TYPE_ d)
+{
+  this->ensureDataOnHost();
+  assert( (TRUSTVect<_TYPE_,_SIZE_>::line_size() == 4) );
+  assert( (dimension_tot_0_  * TRUSTVect<_TYPE_,_SIZE_>::line_size() == TRUSTVect<_TYPE_,_SIZE_>::size_array()) );
+  const _SIZE_ n = dimension_tot_0_ * 4;
+  dimensions_[0] = ++dimension_tot_0_;
+  TRUSTVect<_TYPE_,_SIZE_>::resize_vect_(n+4, RESIZE_OPTIONS::COPY_NOINIT);
+  _TYPE_ * ptr = TRUSTVect<_TYPE_,_SIZE_>::addr() + n;
+  ptr[0] = a;
+  ptr[1] = b;
+  ptr[2] = c;
+  ptr[3] = d;
+}
+
+//  fait pointer le tableau sur le vecteur v et en associant la meme structure parallele.
+//  Attention, si line_size du vecteur v est different de 1, on cree un tableau bidimensionnel (on peut avoir un vecteur
+//  de ce type si on copie un Tab dans un Vect puis on prend une ref sur ce Vect).
+// Precondition: le vecteur v doit vraiment etre de type Vect ! (sinon utiliser DoubleTab::ref(const DoubleTab &)
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::ref(const TRUSTVect<_TYPE_,_SIZE_>& v)
+{
+  assert(std::string(typeid(v).name()).find("TRUSTVect") != std::string::npos);
+  TRUSTVect<_TYPE_,_SIZE_>::ref(v);
+  const int l = v.line_size();
+  // Attention: En prenant la ref, on est oblige de conserver l'attribut line_size du Vect (sinon echange_espace_virtuel ne fonctionnera pas car
+  //  on n'aura pas le bon facteur multiplicatif des items geometriques). Si on voulait creer un tableau monodimensionnel avec line_size > 1,
+  //  le tableau devient invalide car on n'a plus line_size = produit des dimensions > 1.
+  //  On peut le faire a condition de laisser tomber le md_vector_ en faisant  tab.ref_array(v) au lieu de  tab.ref(v)
+  if (l == 1)  nb_dim_ = 1;
+  else
+    {
+      nb_dim_ = 2;
+      dimensions_[1] = l;
+    }
+
+  if (v.size_reelle_ok())
+    {
+      _SIZE_ sz = v.size_reelle();
+      dimensions_[0] = sz / l;
+    }
+  else dimensions_[0] = -1;
+
+  dimension_tot_0_ = TRUSTVect<_TYPE_,_SIZE_>::size_array() / l;
+  assert(verifie_LINE_SIZE());
+}
+
+//  fait pointer le tableau sur le tableau t en recuperant la structure parallele. Attention, on fige le tableau qui ne pourra plus etre resize
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::ref(const TRUSTTab& src)
+{
+  TRUSTVect<_TYPE_,_SIZE_>::ref(src);
+  nb_dim_ = src.nb_dim_;
+  for (int i = 0; i < MAXDIM_TAB; i++) dimensions_[i] = src.dimensions_[i];
+  dimension_tot_0_ = src.dimension_tot_0_;
+  assert(verifie_LINE_SIZE());
+}
+
+//  identique a DoubleVect::ref_data()
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::ref_data(_TYPE_* ptr, _SIZE_ new_size)
+{
+  TRUSTVect<_TYPE_,_SIZE_>::ref_data(ptr, new_size);
+  if (new_size<0) new_size=-new_size;
+  assert( (!TRUSTVect<_TYPE_,_SIZE_>::get_md_vector().non_nul() && TRUSTVect<_TYPE_,_SIZE_>::size_reelle() == TRUSTVect<_TYPE_,_SIZE_>::size_array()) );
+  nb_dim_ = 1;
+  dimensions_[0] = dimension_tot_0_ = new_size;
+  assert(verifie_LINE_SIZE());
+}
+
+//  identique a TRUSTVect::ref_array() (cree un tableau monodimensionnel sans structure parallele)
+//  Attention, le tableau source et destination sont figes (resize interdit)
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::ref_array(TRUSTArray<_TYPE_,_SIZE_>& src, _SIZE_ start, _SIZE_ sz)
+{
+  TRUSTVect<_TYPE_,_SIZE_>::ref_array(src, start, sz);
+  assert( (!TRUSTVect<_TYPE_,_SIZE_>::get_md_vector().non_nul() && TRUSTVect<_TYPE_,_SIZE_>::size_reelle() == TRUSTVect<_TYPE_,_SIZE_>::size_array()) );
+  nb_dim_ = 1;
+  dimensions_[0] = dimension_tot_0_ = TRUSTVect<_TYPE_,_SIZE_>::size_array(); // pas sz qui peut valoir -1
+  assert(verifie_LINE_SIZE());
+}
+
+//  fait pointer le tableau sur une sous-partie du tableau t definie par la valeur du premier indice et ne nombre de "lignes" du tableau
+//   a recuperer (une ligne = toutes les valeurs tab(i,j,k,...) pour un i donne). Le nombre de dimensions du tableau est le meme que pour t,
+//   les dimension(i) pour i>=1 sont les memes et dimension(0) = nb_lines.
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::ref_tab(TRUSTTab& t, _SIZE_ start_line, _SIZE_ nb_lines)
+{
+  if (nb_lines < 0) nb_lines = t.dimension_tot_0_ - start_line;
+  assert(start_line >= 0 && nb_lines >= 0 && start_line + nb_lines <= t.dimension_tot_0_);
+  const int l_size = t.line_size();
+  TRUSTVect<_TYPE_,_SIZE_>::ref_array(t, start_line * l_size, nb_lines * l_size);
+  assert( (!TRUSTVect<_TYPE_,_SIZE_>::get_md_vector().non_nul() && TRUSTVect<_TYPE_,_SIZE_>::size_reelle() == TRUSTVect<_TYPE_,_SIZE_>::size_array()) );
+  TRUSTVect<_TYPE_,_SIZE_>::set_line_size_(l_size);
+  nb_dim_ = t.nb_dim_;
+  dimension_tot_0_ = nb_lines;
+  dimensions_[0] = nb_lines;
+  for (int i = 1; i < MAXDIM_TAB; i++) dimensions_[i] = t.dimensions_[i];
+  assert(verifie_LINE_SIZE());
+}
+
+//  met le tableau dans l'etat obtenu par le constructeur par defaut
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::reset()
+{
+  nb_dim_ = 1;
+  dimensions_[0] = 0;
+  dimension_tot_0_ = 0;
+  TRUSTVect<_TYPE_,_SIZE_>::reset();
+  assert(verifie_LINE_SIZE());
+}
+
+//  methode virtuelle qui force le tableau a changer de taille. Change aussi nb_dim_ a 1. Equivalent a TRUSTTab::resize(n, opt)
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::resize_tab(_SIZE_ n, RESIZE_OPTIONS opt)
+{
+  resize(n, opt);
+  assert(verifie_LINE_SIZE());
+}
+
+//  change la dimension[0] du tableau en conservant les autres.
+// Precondition: le tableau ne doit pas avoir de structure parallele
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::resize_dim0(_SIZE_ n, RESIZE_OPTIONS opt)
+{
+  assert(n >= 0);
+  assert( (dimension_tot_0_ * TRUSTVect<_TYPE_,_SIZE_>::line_size() == TRUSTVect<_TYPE_,_SIZE_>::size_array()) );
+  TRUSTVect<_TYPE_,_SIZE_>::resize_vect_(n * TRUSTVect<_TYPE_,_SIZE_>::line_size(), opt);
+  dimensions_[0] = dimension_tot_0_ = n;
+  assert(verifie_LINE_SIZE());
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::resize(_SIZE_ n, RESIZE_OPTIONS opt)
+{
+  assert(n >= 0);
+  TRUSTVect<_TYPE_,_SIZE_>::set_line_size_(1);
+  TRUSTVect<_TYPE_,_SIZE_>::resize_vect_(n, opt);
+  nb_dim_ = 1;
+  dimensions_[0] = dimension_tot_0_ = n;
+  assert(verifie_LINE_SIZE());
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::resize(_SIZE_ n, int n2, RESIZE_OPTIONS opt)
+{
+  assert(n >= 0 && n2 >= 0);
+  TRUSTVect<_TYPE_,_SIZE_>::set_line_size_(n2);
+  _SIZE_ new_size = n * n2;
+
+  if (std::is_same<_TYPE_,int>::value && new_size < 0)
+    {
+      Cerr << "n1*n2 > 2^31. Error! Contact TRUST support, integer 32 bits limit exceeded with n1=" << n << " and n2=" << n2 << finl;
+      Process::exit();
+    }
+
+  TRUSTVect<_TYPE_,_SIZE_>::resize_vect_(new_size, opt);
+  nb_dim_ = 2;
+  dimensions_[0] = dimension_tot_0_ = n;
+  dimensions_[1] = n2;
+  assert(verifie_LINE_SIZE());
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::resize(_SIZE_ n, int n2, int n3, RESIZE_OPTIONS opt)
+{
+  assert(n >= 0 && n2 >= 0 && n3 >= 0);
+  TRUSTVect<_TYPE_,_SIZE_>::set_line_size_(n2 * n3);
+  _SIZE_ new_size = n * n2 * n3;
+
+  if (std::is_same<_TYPE_,int>::value && new_size < 0)
+    {
+      Cerr << "n1*n2*n3 > 2^31. Error! Contact TRUST support, integer 32 bits limit exceeded with n1=" << n << " and n2=" << n2 << " and n3=" << n3 << finl;
+      Process::exit();
+    }
+
+  TRUSTVect<_TYPE_,_SIZE_>::resize_vect_(new_size, opt);
+  nb_dim_ = 3;
+  dimensions_[0] = dimension_tot_0_ = n;
+  dimensions_[1] = n2;
+  dimensions_[2] = n3;
+  assert(verifie_LINE_SIZE());
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::resize(_SIZE_ n, int n2, int n3, int n4, RESIZE_OPTIONS opt)
+{
+  assert(n >= 0 && n2 >= 0 && n3 >= 0 && n4 >= 0);
+  TRUSTVect<_TYPE_,_SIZE_>::set_line_size_(n2 * n3 * n4);
+  _SIZE_ new_size = n * n2 * n3 * n4;
+
+  if (std::is_same<_TYPE_,int>::value && new_size<0)
+    {
+      Cerr << "n1*n2*n3*n4 > 2^31. Error! Contact TRUST support, integer 32 bits limit exceeded with n1=" << n << " and n2=" << n2 << " and n3=" << n3 << " and n4=" << n4 << finl;
+      Process::exit();
+    }
+
+  TRUSTVect<_TYPE_,_SIZE_>::resize_vect_(new_size, opt);
+  nb_dim_ = 4;
+  dimensions_[0] = dimension_tot_0_ = n;
+  dimensions_[1] = n2;
+  dimensions_[2] = n3;
+  dimensions_[3] = n4;
+  assert(verifie_LINE_SIZE());
+}
+
+//  redimensionne le tableau (nb_dim_ sera egal a tailles.size_array() et dimension(i) a tailles[i].
+// Precondition: identiques a TRUSTVect::resize_vect_()
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::resize(const TRUSTArray<_SIZE_, int>& tailles, RESIZE_OPTIONS opt)
+{
+  nb_dim_ = tailles.size_array();
+  if (nb_dim_ <= 0 || nb_dim_ > MAXDIM_TAB)
+    {
+      Cerr << "Internal error in TRUSTTab::resize(const ArrOfInt & tailles, ...) \n" << " wrong dimensions number " << nb_dim_ << finl;
+      Process::exit();
+    }
+  int l_size = 1;
+  for (int i = 0; i < nb_dim_; i++)
+    {
+      const _SIZE_ n = tailles[i];
+      dimensions_[i] = n;
+      if (i > 0)
+        l_size *= (int)n;  // Assume higher dim (>=1) are always small
+      if (n < 0)
+        {
+          Cerr << "Internal error in TRUSTTab::resize(const ArrOfInt & tailles, ...) \n";
+#ifndef LATATOOLS
+          Cerr << " wrong dimensions: " << tailles << finl;
+#endif
+          Process::exit();
+        }
+    }
+  dimension_tot_0_ = dimensions_[0];
+  TRUSTVect<_TYPE_,_SIZE_>::set_line_size_(l_size);
+  TRUSTVect<_TYPE_,_SIZE_>::resize_vect_(dimensions_[0] * l_size, opt);
+  assert(verifie_LINE_SIZE());
+}
+
+//  copie la structure et les valeurs du tableau src
+//   Restrictions et preconditions identiques a TRUSTVect::operator=(const TRUSTVect & v)
+template<typename _TYPE_, typename _SIZE_>
+inline TRUSTTab<_TYPE_,_SIZE_>& TRUSTTab<_TYPE_,_SIZE_>::operator=(const TRUSTTab& src)
+{
+  copy(src);
+  return *this;
+}
+
+//  copie la structure et les valeurs de src. Attention: appel invalide si src est un type derive de Vect
+//  (sinon quoi faire, un tableau unidimensionnel, ou une copie de la structure ?)
+template<typename _TYPE_, typename _SIZE_>
+inline TRUSTTab<_TYPE_,_SIZE_>& TRUSTTab<_TYPE_,_SIZE_>::operator=(const TRUSTVect<_TYPE_,_SIZE_>& src)
+{
+  assert(std::string(typeid(src).name()).find("TRUSTVect") != std::string::npos);
+  TRUSTVect<_TYPE_,_SIZE_>::copy_(src);
+
+  // Idem que dans ref(TRUSTVect<_TYPE_,_SIZE_>) pour le nombre de dimensions du tableau cree
+  const int l = src.line_size();
+  if (l == 1) nb_dim_ = 1;
+  else
+    {
+      nb_dim_ = 2;
+      dimensions_[1] = l;
+    }
+
+  if (src.size_reelle_ok())
+    {
+      _SIZE_ sz = src.size_reelle();
+      dimensions_[0] = sz / l;
+      assert(sz % l == 0);
+    }
+  else dimensions_[0] = -1;
+
+  dimension_tot_0_ = TRUSTVect<_TYPE_,_SIZE_>::size_array() / l;
+  assert(verifie_LINE_SIZE());
+  return *this;
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline TRUSTTab<_TYPE_,_SIZE_>& TRUSTTab<_TYPE_,_SIZE_>::operator=(_TYPE_ d)
+{
+  TRUSTVect<_TYPE_,_SIZE_>::operator=(d);
+  return *this;
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::copy(const TRUSTTab& src, RESIZE_OPTIONS opt)
+{
+  if (&src != this)
+    {
+      TRUSTVect<_TYPE_,_SIZE_>::copy_(src, opt);
+      nb_dim_ = src.nb_dim_;
+      for (int i = 0; i < MAXDIM_TAB; i++) dimensions_[i] = src.dimensions_[i];
+      dimension_tot_0_ = src.dimension_tot_0_;
+      assert(verifie_LINE_SIZE());
+    }
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_& TRUSTTab<_TYPE_,_SIZE_>::operator()(const TRUSTArray<_SIZE_,int>& indice)
+{
+  assert(indice.size_array() == nb_dim_);
+  verifie_MAXDIM_TAB();
+  switch(nb_dim_)
+    {
+    case 1:
+      return operator()(indice[0]);
+    case 2:
+      return operator()(indice[0], indice[1]);
+    case 3:
+      return operator()(indice[0], indice[1], indice[2]);
+    default:
+      return operator()(indice[0], indice[1], indice[2], indice[3]);
+    }
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ TRUSTTab<_TYPE_,_SIZE_>::operator()(const TRUSTArray<_SIZE_,int>& indice) const
+{
+  assert(indice.size_array() == nb_dim_);
+  verifie_MAXDIM_TAB();
+  switch(nb_dim_)
+    {
+    case 1:
+      return operator()(indice[0]);
+    case 2:
+      return operator()(indice[0], indice[1]);
+    case 3:
+      return operator()(indice[0], indice[1], indice[2]);
+    default:
+      return operator()(indice[0], indice[1], indice[2], indice[3]);
+    }
+}
+
+//  associe le md_vector au vecteur (voir TRUSTVect::set_md_vector()) dimension(0) sera initialise a md_vector...get_nb_items_reels().
+// Precondition: en plus des preconditions de TRUSTVect::set_md_vector(), dimension_tot(0) doit etre egal a get_nb_items_tot() du md_vector.
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::set_md_vector(const MD_Vector& md_vector)
+{
+#ifndef LATATOOLS
+  _SIZE_ dim0 = dimension_tot_0_;
+  if (md_vector.non_nul())
+    // renvoie -1 si l'appel est invalide ou si le MD_Vector est mix (cf doc MD_Vector_base):
+    dim0 = md_vector->get_nb_items_reels();
+  dimensions_[0] = dim0;
+  assert(verifie_LINE_SIZE());
+  // a appeler meme pour un md_vector nul (pour remettre size_reelle_):
+  TRUSTVect<_TYPE_,_SIZE_>::set_md_vector(md_vector);
+#endif
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::ecrit(Sortie& os) const
+{
+#ifndef LATATOOLS
+  os << nb_dim_ << finl;
+  if (nb_dim_ > 0) os.put(dimensions_, nb_dim_, nb_dim_);
+  TRUSTArray<_SIZE_,int> tmp(nb_dim_);
+  for (int i = 0; i < nb_dim_; i++) tmp[i] = dimension_tot(i);
+  os << tmp;
+  TRUSTVect<_TYPE_,_SIZE_>::ecrit(os);
+#endif
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::jump(Entree& is)
+{
+  TRUSTTab<_TYPE_,_SIZE_>::lit(is, 0 /* Do not resize&read the array */);
+}
+
+//  lecture d'un tableau pour reprise de calcul. On lit les valeurs "raw".
+//  Attention, si le tableau n'est pas vide, il doit deja avoir la bonne taille et la bonne structure, sinon erreur !
+// Parameter resize_and_read if the array is sized AND read (by default, yes)
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::lit(Entree& is, bool resize_and_read)
+{
+#ifndef LATATOOLS
+  TRUSTArray<_SIZE_,int> tmp; // the dim array wich is read
+  is >> tmp;
+  bool ok = (tmp.size_array() == nb_dim_);
+
+  if (ok)
+    {
+      if (TRUSTVect<_TYPE_,_SIZE_>::size_reelle_ok() && dimension(0) != tmp[0]) ok = 0;
+      for (int i = 1; i < nb_dim_; i++)
+        if (dimension(i) != tmp[i]) ok = 0;
+    }
+  is >> tmp;
+  if (ok && tmp.size_array() != nb_dim_) ok = 0;
+  if (ok)
+    for (int i = 0; i < nb_dim_; i++)
+      if (dimension_tot(i) != tmp[i]) ok = 0;
+
+  // Autorisation ancien format des champs scalaire 183:
+  if (tmp.size_array()==1 && nb_dim_==2 && dimension(1)==1 && dimension_tot(0) == tmp[0]) ok = 1;
+
+  if (resize_and_read)
+    {
+      if (TRUSTVect<_TYPE_,_SIZE_>::size_array() == 0 && (!TRUSTVect<_TYPE_,_SIZE_>::get_md_vector().non_nul()))
+        resize(tmp, RESIZE_OPTIONS::NOCOPY_NOINIT);
+      else if (!ok)
+        {
+          // Si on cherche a relire un tableau de taille inconnue, le tableau doit etre reset() a l'entree. On n'aura pas la structure parallele du tableau !
+          Cerr << finl;
+          Cerr << "Error in DoubleTab::lit: array has wrong dimensions" << finl;
+          if (Process::is_parallel() && dimension(0) != tmp[0]) // Add message to detect different partitionning
+            {
+              Cerr << "We try to read an array with " << dimension(0) << " items whereas we are waiting for a size of " << tmp[0] << "!" << finl;
+              Cerr << "Probably a different partitionning from your previous calculation..." << finl;
+              Cerr << "Change your current partitionning to match the previous calculation or try .xyz restart protocol." << finl;
+            }
+          Process::exit();
+        }
+    }
+  TRUSTVect<_TYPE_,_SIZE_>::lit(is,resize_and_read);
+#endif
+}
+
+// ------------------------------------------------------
+// Juste pour double/float
+
+//  Quelqu'un veut-il expliquer ce que fait cette methode ?
+template<typename _TYPE_, typename _SIZE_>
+template <typename _T_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::ajoute_produit_tensoriel(_T_ alpha, const TRUSTTab<_T_,_SIZE_>& x, const TRUSTTab<_T_,_SIZE_>& y)
+{
+  this->ensureDataOnHost();
+  x.ensureDataOnHost();
+  y.ensureDataOnHost();
+  // Tableaux vus comme des tableaux unidimensionnels (pour ne pas avoir a gerer nb_dim)
+  const TRUSTVect<_T_,_SIZE_>& vx = x, &vy = y;
+  TRUSTVect<_T_,_SIZE_>& v = *this;
+
+  const int line_size_x = vx.line_size(), line_size_y = vy.line_size(), line_size_xy = v.line_size();
+  assert(line_size_xy == line_size_x * line_size_y);
+  // Pour ne pas diviser par line_size()
+  assert(vx.size_totale() * line_size_xy == v.size_totale() * line_size_x);
+  assert(vy.size_totale() * line_size_xy == v.size_totale() * line_size_y);
+
+  // Logic similar to what is done in TRUSTVect_Tools.cpp, with ::determine_blocks()
+  Block_Iter<_SIZE_> bloc_itr; // By default, nothing in the iterator
+  int nblocs_left = 0;
+  if (v.get_md_vector().non_nul() && v.get_md_vector()->use_blocks())
+    {
+      const ArrOfInt& items_blocs = v.get_md_vector()->get_items_to_compute();
+      assert(items_blocs.size_array() % 2 == 0);
+      nblocs_left = items_blocs.size_array() >> 1;
+      bloc_itr = Block_Iter<_SIZE_>(items_blocs.addr());
+    }
+  else
+    {
+      if (v.size_totale() > 0)
+        {
+          nblocs_left = 1;
+          bloc_itr = Block_Iter<_SIZE_>(0, v.size_totale() / v.line_size());   // iterator on a single (big) block
+        }
+    }
+
+  for (; nblocs_left; nblocs_left--)
+    {
+      const _SIZE_ debut = (*(bloc_itr++)), fin = (*(bloc_itr++));
+      _SIZE_ v_index = debut * line_size_xy;
+      for (_SIZE_ i = debut; i < fin; i++)
+        for (_SIZE_ j = 0; j < line_size_x; j++)
+          {
+            _T_ xval = vx[i * line_size_x + j];
+            for (_SIZE_ k = 0; k < line_size_y; k++)
+              {
+                _T_ yval = vy[i * line_size_y + k];
+                v[v_index] += alpha * xval * yval;
+                v_index++;
+              }
+          }
+    }
+}
+
+//  Resolution du systeme Ax=b
+template<typename _TYPE_, typename _SIZE_>
+template <typename _T_>
+inline bool TRUSTTab<_TYPE_,_SIZE_>::inverse_LU(const TRUSTArray<_T_,_SIZE_>& b, TRUSTArray<_T_,_SIZE_>& solution)
+{
+  b.ensureDataOnHost();
+  solution.ensureDataOnHost();
+  _SIZE_ n = b.size_array();
+  TRUSTArray<int,_SIZE_> index(n);
+  TRUSTTab<_T_,_SIZE_> lu_dec(n,n);
+  bool cvg = (*this).decomp_LU(n,index,lu_dec);
+
+  if(cvg) lu_dec.resoud_LU(n,index,b,solution);
+
+  return cvg;
+}
+
+//  Decomposition d'une matrice en L.U: methode de Crout (diagonale de L =1)
+// Retour: matrice A_ = assemblage (L-diagonale)+U
+template<typename _TYPE_, typename _SIZE_>
+template <typename _T_>
+inline bool TRUSTTab<_TYPE_,_SIZE_>::decomp_LU(_SIZE_ n, TRUSTArray<int,_SIZE_>& index, TRUSTTab<_T_,_SIZE_>& matLU)
+{
+  TRUSTArray<_T_,_SIZE_> vv(n);
+  _SIZE_ i, j, k,  imax = -1, cvg = 1;
+  _T_ big, dum, sum, temp;
+  matLU = (*this);
+
+  //Recupere le coeff max d'une ligne, stocke dans vv
+  for (i=0 ; i<n ; i++)
+    {
+      big = 0;
+      for (j=0 ; j<n ; j++)
+        if ((temp = std::fabs(matLU(i,j))) > big) big = temp;
+
+      if (big == 0)
+        {
+          Cerr <<"Singular matrix in LU decomposition"<<finl;
+          cvg = 0;
+          Process::exit();
+        }
+      vv[i] = 1./big;
+    }
+
+  //calcul de la matrice matLU
+  for (j=0 ; j<n ; j++)
+    {
+      for (i=0 ; i<j ; i++)
+        {
+          sum = matLU(i,j);
+          for (k=0 ; k<i ; k++) sum -= matLU(i,k) * matLU(k,j);
+          matLU(i,j) = sum;
+        }
+
+      big = 0;
+      for (i=j ; i<n ; i++)
+        {
+          sum = matLU(i,j);
+          for (k=0 ; k<j ; k++) sum -= matLU(i,k) * matLU(k,j);
+          matLU(i,j) = sum;
+          if ((dum = vv[i]*std::fabs(sum)) >= big)
+            {
+              big = dum;
+              imax = i;
+            }
+        }
+
+      if (j != imax)
+        {
+          for (k=0 ; k<n ; k++)
+            {
+              dum = matLU(imax,k);
+              matLU(imax,k) = matLU(j,k);
+              matLU(j,k) = dum;
+            }
+          vv[imax] = vv[j];
+        }
+
+      index[j] = imax;
+      dum = 1./matLU(j,j);
+      for (i=j+1 ; i<n ; i++) matLU(i,j) *= dum;
+    }
+  return cvg;
+}
+
+//  Resolution du systeme A_x=b : A_ contenant le decompostion LU de A (stockee dans une seule matrice)
+template<typename _TYPE_, typename _SIZE_>
+template <typename _T_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::resoud_LU(_SIZE_ n, TRUSTArray<int,_SIZE_>& index, const TRUSTArray<_T_,_SIZE_>& b, TRUSTArray<_T_,_SIZE_>& solution)
+{
+  _SIZE_ i,ii=-1,ip,j;
+  _T_ sum;
+  solution = b;
+  for (i=0 ; i<n ; i++)
+    {
+      ip = index[i];
+      sum = solution[ip];
+      solution[ip] = solution[i];
+      if (ii!=-1)
+        for (j=ii ; j<i ; j++) sum -= (*this)(i,j)*solution[j];
+      else if (sum) ii =i;
+
+      solution[i] = sum;
+    }
+
+  for (i=n-1 ; i>=0 ; i--)
+    {
+      sum = solution[i];
+      for (j=i+1 ; j<n ; j++) sum -= (*this)(i,j)*solution[j];
+      solution[i] = sum/(*this)(i,i);
+    }
+}
+
+//  Fonction utilisee pour le calcul du du/u (pour convergence implicite)
+//    renvoie le max de abs(du(i)/u(i)). utilisation    max_ = (u(n+1)-u(n)).max_du_u(u(n))
+template<typename _TYPE_, typename _SIZE_>
+template <typename _T_>
+inline _T_ TRUSTTab<_TYPE_,_SIZE_>::max_du_u(const TRUSTTab<_T_,_SIZE_>& u)
+{
+  u.ensureDataOnHost();
+  assert( (TRUSTVect<_TYPE_,_SIZE_>::size_array() == u.size_array()) );
+  const _T_ *du_ptr = TRUSTVect<_TYPE_,_SIZE_>::addr();
+  const _T_ *u_ptr = u.addr();
+  const _T_ epsilon = 1.e-8;
+  _T_ res = 0.;
+  for (_SIZE_ n = TRUSTVect<_TYPE_,_SIZE_>::size_array(); n; n--)
+    {
+      _T_ a = std::fabs(*du_ptr), b = std::fabs(*u_ptr), c = a / (b + epsilon);
+      if (b > 1.e-2 && c > res) res = c;
+      du_ptr++;
+      u_ptr++;
+    }
+  return res;
+}
+
+#endif /* TRUSTTab_TPP_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUSTTab_kokkos.tpp b/Utilities/VisItBridge/databases/readers/Lata/TRUSTTab_kokkos.tpp
new file mode 100644
index 00000000..2d21dee4
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUSTTab_kokkos.tpp
@@ -0,0 +1,556 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef TRUSTTab_kokkos_TPP_included
+#define TRUSTTab_kokkos_TPP_included
+
+#include <TRUSTTab.h>
+#ifdef KOKKOS
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+/// 2D
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+// Create internal DualView member, and populate it with current host data
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::init_view_tab2() const
+{
+  kokkos_self_test();
+  long trail_dim = 1;
+  for(int d=1; d < this->nb_dim(); d++)
+    trail_dim *= this->dimension_tot(d);
+  long dims[2] = {this->dimension_tot(0), trail_dim};
+
+  // change of alloc or resize triggers re-init (for now - resize could be done better)
+  if(dual_view_tab2_.h_view.is_allocated() &&
+      dual_view_tab2_.h_view.data() == this->data() &&
+      dual_view_tab2_.view_device().data() == addrOnDevice(*this) &&
+      (long) dual_view_tab2_.extent(0) == dims[0] &&
+      (long) dual_view_tab2_.extent(1) == dims[1])
+    return;
+
+//  if(nb_dim() != 2)
+//    Process::exit("Wrong dim number in view init!");
+
+  using t_host = typename DualViewTab<_TYPE_>::t_host;  // Host type
+  using t_dev = typename DualViewTab<_TYPE_>::t_dev;    // Device type
+  //using size_type = typename DualViewTab<_TYPE_>::size_type;
+
+  //const std::string& nom = this->le_nom().getString();
+
+  // Re-use data already allocated on host to create host-view:
+  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+  // !!!!!!!!!!!!!!!!!!!!!  WARNING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+  //          This heavily relies on the LayoutRight defined for the DualView (which is not optimal
+  //          for GPU processing, but avoids having to explicitely copying the data ...)
+  t_host host_view = t_host(const_cast<_TYPE_ *>(this->data()), dims[0], dims[1]);
+  // Empty view on device - just a memory allocation:
+  //t_dev device_view = t_dev(nom, dims[0], dims[1]);
+  t_dev device_view;
+#ifdef _OPENMP_TARGET
+  // Device memory is allocated with OpenMP: ToDo replace by allocate ?
+  mapToDevice(*this, "Kokkos init_view_tab2()");
+  device_view = t_dev(const_cast<_TYPE_ *>(addrOnDevice(*this)), dims[0], dims[1]);
+  // Example of transpose which will be used to connect Cuda (AmgX) to Kokkos:
+  /*
+  device_view = t_dev("", dims[0], dims[1]);
+  Kokkos::View<const _TYPE_ **, Kokkos::LayoutRight, memory_space, Kokkos::MemoryUnmanaged> device_view_LayoutRight(
+    const_cast<_TYPE_ *>(addrOnDevice(*this)), dims[0], dims[1]);
+  start_gpu_timer();
+  Nom name("[KOKKOS] Deep_copy items= ");
+  name += (Nom) (int) dims[0];
+  // Kokkos::deep_copy(device_view, device_view_LayoutRight); Slower 100-200% ?
+  Kokkos::parallel_for("[KOKKOS] Manual transpose ", Kokkos::RangePolicy<>(0, dims[0]), KOKKOS_LAMBDA(
+                         const int i)
+  {
+    for (int j = 0; j < dims[1]; j++)
+      device_view(i, j) = device_view_LayoutRight(j, i);
+  });
+  end_gpu_timer(Objet_U::computeOnDevice, name.getString());
+   */
+#else
+  device_view = create_mirror_view_and_copy(Kokkos::DefaultExecutionSpace::memory_space(), host_view);
+#endif
+
+  // Dual view is made as an assembly of the two views:
+  dual_view_tab2_ = DualViewTab<_TYPE_>(device_view, host_view);
+
+  // Mark data modified on host so it will be sync-ed to device later on:
+  dual_view_tab2_.template modify<host_mirror_space>();
+}
+
+//////////// Read-Only ////////////////////////////
+// Device version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ConstViewTab<_TYPE_> >
+TRUSTTab<_TYPE_,_SIZE_>::view_ro() const
+{
+  // Init if necessary
+  init_view_tab2();
+#ifdef _OPENMP_TARGET
+  mapToDevice(*this, "Kokkos TRUSTTab::view_ro()");
+#else
+  // Copy to device if needed (i.e. if modify() was called):
+  dual_view_tab2_.template sync<memory_space>();
+#endif
+  // return *device* view:
+  return dual_view_tab2_.view_device();
+}
+
+// Host version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, ConstHostViewTab<_TYPE_> >
+TRUSTTab<_TYPE_,_SIZE_>::view_ro() const
+{
+  return ConstHostViewTab<_TYPE_>(this->addr(), this->dimension_tot(0), this->dimension_tot(1));
+}
+
+//////////// Write-only ////////////////////////////
+// Device version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ViewTab<_TYPE_> >
+TRUSTTab<_TYPE_,_SIZE_>::view_wo()
+{
+  // Init if necessary
+  init_view_tab2();
+#ifdef _OPENMP_TARGET
+  computeOnTheDevice(*this, "Kokkos TRUSTTab<_TYPE_,_SIZE_>::view_wo()"); // ToDo allouer sans copie ?
+#else
+  // Mark the (device) data as modified, so that the next sync() (to host) will copy:
+  dual_view_tab2_.template modify<memory_space>();
+#endif
+  // return *device* view:
+  return dual_view_tab2_.view_device();
+}
+
+// Host version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, HostViewTab<_TYPE_> >
+TRUSTTab<_TYPE_,_SIZE_>::view_wo()
+{
+  return HostViewTab<_TYPE_>(this->addr(), this->dimension_tot(0), this->dimension_tot(1));
+}
+
+//////////// Read-Write ////////////////////////////
+// Device version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ViewTab<_TYPE_> >
+TRUSTTab<_TYPE_,_SIZE_>::view_rw()
+{
+  // Init if necessary
+  init_view_tab2();
+#ifdef _OPENMP_TARGET
+  computeOnTheDevice(*this, "Kokkos view_rw()");
+#else
+  // Copy to device (if needed) ...
+  dual_view_tab2_.template sync<memory_space>();
+  // ... and mark the (device) data as modified, so that the next sync() (to host) will copy:
+  dual_view_tab2_.template modify<memory_space>();
+#endif
+  // return *device* view:
+  return dual_view_tab2_.view_device();
+}
+
+
+// Host version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, HostViewTab<_TYPE_> >
+TRUSTTab<_TYPE_,_SIZE_>::view_rw()
+{
+  return HostViewTab<_TYPE_>(this->addr(), this->size());
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::sync_to_host() const
+{
+#ifdef _OPENMP_TARGET
+  Process::exit("ToDo");
+#endif
+  // Copy to host (if needed) ...
+  dual_view_tab2_.template sync<host_mirror_space>();
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::modified_on_host() const
+{
+#ifdef _OPENMP_TARGET
+  Process::exit("ToDo");
+#endif
+  // Mark modified on host side:
+  if(dual_view_tab2_.h_view.is_allocated())
+    dual_view_tab2_.template modify<host_mirror_space>();
+}
+
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+/// 3D
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+// Create internal DualView member, and populate it with current host data
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::init_view_tab3() const
+{
+  long dims[3] = {this->dimension_tot(0), nb_dim_>1 ? this->dimension_tot(1) : 0, nb_dim_>2 ? this->dimension_tot(2) : 0};
+
+  // change of alloc or resize triggers re-init (for now - resize could be done better)
+  if(dual_view_tab3_.h_view.is_allocated() &&
+      dual_view_tab3_.h_view.data() == this->data() &&
+      dual_view_tab3_.view_device().data() == addrOnDevice(*this) &&
+      (long) dual_view_tab3_.extent(0) == dims[0] &&
+      (long) dual_view_tab3_.extent(1) == dims[1] &&
+      (long) dual_view_tab3_.extent(2) == dims[2])
+    return;
+
+  //if(nb_dim() != 3)
+  //  Process::exit("Wrong dim number in view init!");
+
+  using t_host = typename DualViewTab3<_TYPE_>::t_host;  // Host type
+  using t_dev = typename DualViewTab3<_TYPE_>::t_dev;    // Device type
+  //using size_type = typename DualViewTab3<_TYPE_>::size_type;
+
+  //const std::string& nom = this->le_nom().getString();
+
+  // Re-use data already allocated on host to create host-view:
+  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+  // !!!!!!!!!!!!!!!!!!!!!  WARNING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+  //          This heavily relies on the LayoutRight defined for the DualView (which is not optimal
+  //          for GPU processing, but avoids having to explicitely copying the data ...)
+  t_host host_view = t_host(const_cast<_TYPE_ *>(this->data()), dims[0], dims[1], dims[2]);
+  // Empty view on device - just a memory allocation:
+  //t_dev device_view = t_dev(nom, dims[0], dims[1], dims[2]);
+  t_dev device_view;
+#ifdef _OPENMP_TARGET
+  // Device memory is allocated with OpenMP: ToDo replace by allocate ?
+  mapToDevice(*this, "Kokkos init_view_tab3()");
+  device_view = t_dev(const_cast<_TYPE_ *>(addrOnDevice(*this)), dims[0], dims[1], dims[2]);
+#else
+  device_view = create_mirror_view_and_copy(Kokkos::DefaultExecutionSpace::memory_space(), host_view);
+#endif
+
+  // Dual view is made as an assembly of the two views:
+  dual_view_tab3_ = DualViewTab3<_TYPE_>(device_view, host_view);
+
+  // Mark data modified on host so it will be sync-ed to device later on:
+  dual_view_tab3_.template modify<host_mirror_space>();
+}
+
+/////////// Read-Only ////////////////////////////
+// Device version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ConstViewTab3<_TYPE_> >
+TRUSTTab<_TYPE_,_SIZE_>::view3_ro() const
+{
+  // Init if necessary
+  init_view_tab3();
+#ifdef _OPENMP_TARGET
+  mapToDevice(*this, "Kokkos TRUSTTab3::view3_ro()");
+#else
+  // Copy to device if needed (i.e. if modify() was called):
+  dual_view_tab3_.template sync<memory_space>();
+#endif
+  // return *device* view:
+  return dual_view_tab3_.view_device();
+}
+
+// Host version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, ConstHostViewTab3<_TYPE_> >
+TRUSTTab<_TYPE_,_SIZE_>::view3_ro() const
+{
+  return ConstHostViewTab3<_TYPE_>(this->addr(), this->dimension_tot(0), this->dimension_tot(1), this->dimension_tot(2));
+}
+
+//////////// Write-only ////////////////////////////
+// Device version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ViewTab3<_TYPE_> >
+TRUSTTab<_TYPE_,_SIZE_>::view3_wo()
+{
+  // Init if necessary
+  init_view_tab3();
+#ifdef _OPENMP_TARGET
+  computeOnTheDevice(*this, "Kokkos TRUSTTab<_TYPE_,_SIZE_>::view3_wo()"); // ToDo allouer sans copie ?
+#else
+  // Mark the (device) data as modified, so that the next sync() (to host) will copy:
+  dual_view_tab3_.template modify<memory_space>();
+#endif
+  // return *device* view:
+  return dual_view_tab3_.view_device();
+}
+
+// Host version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, HostViewTab3<_TYPE_> >
+TRUSTTab<_TYPE_,_SIZE_>::view3_wo()
+{
+  return HostViewTab3<_TYPE_>(this->addr(), this->dimension(0), this->dimension(1), this->dimension(2));
+}
+
+//////////// Read-Write ////////////////////////////
+// Device version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ViewTab3<_TYPE_> >
+TRUSTTab<_TYPE_,_SIZE_>::view3_rw()
+{
+  // Init if necessary
+  init_view_tab3();
+#ifdef _OPENMP_TARGET
+  computeOnTheDevice(*this, "Kokkos view3_rw()");
+#else
+  // Copy to device (if needed) ...
+  dual_view_tab3_.template sync<memory_space>();
+  // ... and mark the (device) data as modified, so that the next sync() (to host) will copy:
+  dual_view_tab3_.template modify<memory_space>();
+#endif
+  // return *device* view:
+  return dual_view_tab3_.view_device();
+}
+// Host version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, HostViewTab3<_TYPE_> >
+TRUSTTab<_TYPE_,_SIZE_>::view3_rw()
+{
+  return HostViewTab3<_TYPE_>(this->addr(), this->size());
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::sync_to_host3() const
+{
+#ifdef _OPENMP_TARGET
+  Process::exit("ToDo");
+#endif
+  // Copy to host (if needed) ...
+  dual_view_tab3_.template sync<host_mirror_space>();
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::modified_on_host3() const
+{
+#ifdef _OPENMP_TARGET
+  Process::exit("ToDo");
+#endif
+  // Mark modified on host side:
+  if(dual_view_tab3_.h_view.is_allocated())
+    dual_view_tab3_.template modify<host_mirror_space>();
+}
+
+
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+/// 4D
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+// Create internal DualView member, and populate it with current host data
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::init_view_tab4() const
+{
+  long dims[4] = {this->dimension_tot(0), nb_dim_>1 ? this->dimension_tot(1) : 0, nb_dim_>2 ? this->dimension_tot(2) : 0 , nb_dim_>3 ? this->dimension_tot(3) : 0};
+
+  // change of alloc or resize triggers re-init (for now - resize could be done better)
+  if(dual_view_tab4_.h_view.is_allocated() &&
+      dual_view_tab4_.h_view.data() == this->data() &&
+      dual_view_tab4_.view_device().data() == addrOnDevice(*this) &&
+      (long)dual_view_tab4_.extent(0) == dims[0] &&
+      (long)dual_view_tab4_.extent(1) == dims[1] &&
+      (long)dual_view_tab4_.extent(2) == dims[2] &&
+      (long)dual_view_tab4_.extent(3) == dims[3])
+    return;
+
+  //if(nb_dim() != 4)
+  //  Process::exit("Wrong dim number in view init!");
+
+  using t_host = typename DualViewTab4<_TYPE_>::t_host;  // Host type
+  using t_dev = typename DualViewTab4<_TYPE_>::t_dev;    // Device type
+  //using size_type = typename DualViewTab4<_TYPE_>::size_type;
+
+  //const std::string& nom = this->le_nom().getString();
+
+  // Re-use data already allocated on host to create host-view:
+  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+  // !!!!!!!!!!!!!!!!!!!!!  WARNING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+  //          This heavily relies on the LayoutRight defined for the DualView (which is not optimal
+  //          for GPU processing, but avoids having to explicitely copying the data ...)
+  t_host host_view = t_host(const_cast<_TYPE_ *>(this->data()), dims[0], dims[1], dims[2], dims[3]);
+  // Empty view on device - just a memory allocation:
+  //t_dev device_view = t_dev(nom, dims[0], dims[1], dims[2], dims[3]);
+  t_dev device_view;
+#ifdef _OPENMP_TARGET
+  // Device memory is allocated with OpenMP: ToDo replace by allocate ?
+  mapToDevice(*this, "Kokkos init_view_tab4()");
+  device_view = t_dev(const_cast<_TYPE_ *>(addrOnDevice(*this)), dims[0], dims[1], dims[2], dims[3]);
+#else
+  device_view = create_mirror_view_and_copy(Kokkos::DefaultExecutionSpace::memory_space(), host_view);
+#endif
+
+  // Dual view is made as an assembly of the two views:
+  dual_view_tab4_ = DualViewTab4<_TYPE_>(device_view, host_view);
+
+  // Mark data modified on host so it will be sync-ed to device later on:
+  dual_view_tab4_.template modify<host_mirror_space>();
+}
+
+/////////// Read-Only ////////////////////////////
+// Device version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ConstViewTab4<_TYPE_> >
+TRUSTTab<_TYPE_,_SIZE_>::view4_ro() const
+{
+  // Init if necessary
+  init_view_tab4();
+#ifdef _OPENMP_TARGET
+  mapToDevice(*this, "Kokkos TRUSTTab::view4_ro()");
+#else
+  // Copy to device if needed (i.e. if modify() was called):
+  dual_view_tab4_.template sync<memory_space>();
+#endif
+  // return *device* view:
+  return dual_view_tab4_.view_device();
+}
+
+// Host version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, ConstHostViewTab4<_TYPE_> >
+TRUSTTab<_TYPE_,_SIZE_>::view4_ro() const
+{
+  return ConstHostViewTab4<_TYPE_>(this->addr(), this->dimension_tot(0), this->dimension_tot(1), this->dimension_tot(2), this->dimension_tot(3));
+}
+
+//////////// Write-only ////////////////////////////
+// Device version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ViewTab4<_TYPE_> >
+TRUSTTab<_TYPE_,_SIZE_>::view4_wo()
+{
+  // Init if necessary
+  init_view_tab4();
+#ifdef _OPENMP_TARGET
+  computeOnTheDevice(*this, "Kokkos TRUSTTab4<_TYPE_,_SIZE_>::view4_wo()"); // ToDo allouer sans copie ?
+#else
+  // Mark the (device) data as modified, so that the next sync() (to host) will copy:
+  dual_view_tab4_.template modify<memory_space>();
+#endif
+  // return *device* view:
+  return dual_view_tab4_.view_device();
+}
+
+// Host version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, HostViewTab4<_TYPE_> >
+TRUSTTab<_TYPE_,_SIZE_>::view4_wo()
+{
+  return HostViewTab4<_TYPE_>(this->addr(), this->dimension(0), this->dimension(1), this->dimension(2), this->dimension(3));
+}
+
+//////////// Read-Write ////////////////////////////
+// Device version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_default_exec_space<EXEC_SPACE>, ViewTab4<_TYPE_> >
+TRUSTTab<_TYPE_,_SIZE_>::view4_rw()
+{
+  // Init if necessary
+  init_view_tab4();
+#ifdef _OPENMP_TARGET
+  computeOnTheDevice(*this, "Kokkos view4_rw()");
+#else
+  // Copy to device (if needed) ...
+  dual_view_tab4_.template sync<memory_space>();
+  // ... and mark the (device) data as modified, so that the next sync() (to host) will copy:
+  dual_view_tab4_.template modify<memory_space>();
+#endif
+  // return *device* view:
+  return dual_view_tab4_.view_device();
+}
+// Host version
+template<typename _TYPE_, typename _SIZE_>  // this one first!!
+template<typename EXEC_SPACE>
+inline std::enable_if_t<is_host_exec_space<EXEC_SPACE>, HostViewTab4<_TYPE_> >
+TRUSTTab<_TYPE_,_SIZE_>::view4_rw()
+{
+  return HostViewTab4<_TYPE_>(this->addr(), this->size());
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::sync_to_host4() const
+{
+#ifdef _OPENMP_TARGET
+  Process::exit("ToDo");
+#endif
+  // Copy to host (if needed) ...
+  dual_view_tab4_.template sync<host_mirror_space>();
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTTab<_TYPE_,_SIZE_>::modified_on_host4() const
+{
+#ifdef _OPENMP_TARGET
+  Process::exit("ToDo");
+#endif
+  // Mark modified on host side:
+  if(dual_view_tab4_.h_view.is_allocated())
+    dual_view_tab4_.template modify<host_mirror_space>();
+}
+
+// Methode de debug:
+template<typename _TYPE_, typename _SIZE_>
+void debug_device_view(const ViewTab<_TYPE_> view_tab, TRUSTTab<_TYPE_,_SIZE_>& tab, _SIZE_ max_size=-1)
+{
+  assert(view_tab.data()==addrOnDevice(tab)); // Verifie meme adress
+  Cout << "View size=" << view_tab.size() << finl;
+  _SIZE_ size = max_size;
+  if (size==-1) size = (int)view_tab.extent(0);
+  int nb_compo = (int)view_tab.extent(1);
+  Kokkos::parallel_for(size, KOKKOS_LAMBDA(const int i)
+  {
+    for (int j=0; j<nb_compo; j++)
+      printf("[Kokkos]: %p [%2d,%2d]=%e\n", (void*)view_tab.data(), i, j, view_tab(i,j));
+  });
+  Cout << "Tab size=" << tab.size_array() << finl;
+  assert((int)view_tab.size()==tab.size_array());
+  nb_compo = tab.dimension(1);
+  _TYPE_ *ptr = tab.data();
+  #pragma omp target teams distribute parallel for
+  for (int i=0; i<size; i++)
+    {
+      for (int j=0; j<nb_compo; j++)
+        printf("[OpenMP]: %p [%d,%d]=%e\n", (void*)ptr,  i, j, ptr[i*nb_compo+j]);
+    }
+}
+#endif
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUSTTab_tools.tpp b/Utilities/VisItBridge/databases/readers/Lata/TRUSTTab_tools.tpp
new file mode 100644
index 00000000..915a5868
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUSTTab_tools.tpp
@@ -0,0 +1,69 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef TRUSTTab_tools_TPP_included
+#define TRUSTTab_tools_TPP_included
+
+#include <limits>
+
+// NB: all those methods are never used on big (64b) arrays, so the size type is always 'int'.
+
+template <typename _T_>
+void local_carre_norme_tab(const TRUSTTab<_T_,int>& tableau, TRUSTArray<_T_,int>& norme_colonne);
+
+template <>
+inline void local_carre_norme_tab(const TRUSTTab<int,int>& , TRUSTArray<int,int>& ) = delete;
+
+
+template <typename _T_>
+inline void mp_carre_norme_tab(const TRUSTTab<_T_,int>& tableau, TRUSTArray<_T_,int>& norme_colonne)
+{
+  local_carre_norme_tab(tableau, norme_colonne);
+  mp_sum_for_each_item(norme_colonne);
+}
+
+template <>
+inline void mp_carre_norme_tab(const TRUSTTab<int,int>& , TRUSTArray<int,int>& ) = delete;
+
+
+template <typename _T_>
+inline void mp_norme_tab(const TRUSTTab<_T_,int>& tableau, TRUSTArray<_T_,int>& norme_colonne)
+{
+  mp_carre_norme_tab(tableau,norme_colonne);
+  for (int c=0; c<norme_colonne.size_array(); c++) norme_colonne[c] = sqrt(norme_colonne[c]);
+}
+
+template <>
+inline void mp_norme_tab(const TRUSTTab<int,int>& , TRUSTArray<int,int>& ) = delete;
+
+
+template <typename _T_>
+void local_max_abs_tab(const TRUSTTab<_T_,int>& tableau, TRUSTArray<_T_,int>& max_colonne);
+
+template <>
+inline void local_max_abs_tab(const TRUSTTab<int,int>& , TRUSTArray<int,int>& ) = delete;
+
+
+template <typename _T_>
+inline void mp_max_abs_tab(const TRUSTTab<_T_,int>& tableau, TRUSTArray<_T_,int>& max_colonne)
+{
+  local_max_abs_tab(tableau, max_colonne);
+  mp_max_for_each_item(max_colonne);
+}
+
+template <>
+inline void mp_max_abs_tab(const TRUSTTab<int,int>& , TRUSTArray<int,int>& ) = delete;
+
+#endif /* TRUSTTab_tools_TPP_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUSTTabs.h b/Utilities/VisItBridge/databases/readers/Lata/TRUSTTabs.h
new file mode 100644
index 00000000..aebb18d5
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUSTTabs.h
@@ -0,0 +1,26 @@
+/****************************************************************************
+* Copyright (c) 2023, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef TRUSTTabs_included
+#define TRUSTTabs_included
+
+#include <TRUST_Vector.h>
+#include <TRUSTTab.h>
+
+// BYE BYE MACRO !! ahahaha
+using DoubleTabs = TRUST_Vector<TRUSTTab<double>>; // remplace VECT(DoubleTab)
+using IntTabs = TRUST_Vector<TRUSTTab<int>>; // remplace VECT(IntTab)
+
+#endif /* TRUSTTabs_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUSTTabs_forward.h b/Utilities/VisItBridge/databases/readers/Lata/TRUSTTabs_forward.h
new file mode 100644
index 00000000..a4f8d034
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUSTTabs_forward.h
@@ -0,0 +1,92 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef TRUSTTabs_forward_included
+#define TRUSTTabs_forward_included
+
+#include <arch.h>
+
+template <typename _SIZE_> class ArrOfBit_32_64;
+using ArrOfBit = ArrOfBit_32_64<int>;
+
+template <typename _TYPE_, typename _SIZE_=int> class TRUSTArray;
+using ArrOfDouble = TRUSTArray<double, int>;
+using ArrOfFloat = TRUSTArray<float, int>;
+using ArrOfInt = TRUSTArray<int, int>;
+using ArrOfTID = TRUSTArray<trustIdType, int>;
+
+using BigArrOfDouble = TRUSTArray<double, trustIdType>;
+using BigArrOfFloat = TRUSTArray<float, trustIdType>;
+using BigArrOfInt = TRUSTArray<int, trustIdType>;
+using BigArrOfTID = TRUSTArray<trustIdType, trustIdType>;
+
+template<typename _TYPE_, typename _SIZE_=int> class TRUSTVect;
+using DoubleVect = TRUSTVect<double, int>;
+using FloatVect = TRUSTVect<float, int>;
+using IntVect = TRUSTVect<int, int>;
+using TIDVect = TRUSTVect<trustIdType, int>;
+
+using BigDoubleVect = TRUSTVect<double, trustIdType>;
+using BigIntVect = TRUSTVect<int, trustIdType>;
+using BigTIDVect = TRUSTVect<trustIdType, trustIdType>;
+
+template<typename _TYPE_, typename _SIZE_=int> class TRUSTTab;
+using DoubleTab = TRUSTTab<double, int>;
+using FloatTab = TRUSTTab<float, int>;
+using IntTab = TRUSTTab<int, int>;
+
+using TIDTab = TRUSTTab<trustIdType, int>;
+
+using BigDoubleTab = TRUSTTab<double, trustIdType>;
+using BigFloatTab = TRUSTTab<float, trustIdType>;
+using BigIntTab = TRUSTTab<int, trustIdType>;
+using BigTIDTab = TRUSTTab<trustIdType, trustIdType>;
+
+template<typename _TYPE_> class TRUSTTrav;
+using IntTrav = TRUSTTrav<int>;
+using DoubleTrav = TRUSTTrav<double>;
+using FloatTrav = TRUSTTrav<float>;
+
+// previous VECT macros :-)
+// TODO : FIXME : Add float typedefs ...
+template<typename _TYPE_> class TRUST_Vector;
+using ArrsOfDouble = TRUST_Vector<TRUSTArray<double, int>>; // remplace VECT(ArrOfDouble)
+using ArrsOfInt = TRUST_Vector<TRUSTArray<int, int>>; // remplace VECT(ArrOfInt)
+using DoubleVects = TRUST_Vector<TRUSTVect<double, int>>; // remplace VECT(DoubleVect)
+using IntVects = TRUST_Vector<TRUSTVect<int, int>>; // remplace VECT(IntVect)
+using DoubleTabs = TRUST_Vector<TRUSTTab<double, int>>; // remplace VECT(DoubleTab)
+using IntTabs = TRUST_Vector<TRUSTTab<int, int>>; // remplace VECT(IntTab)
+
+
+//
+// Handy 'using' clauses used in all the class templatized on the 32/64b aspect (Domaine, Octree, Elem_geom, etc.)
+//
+template <typename _SIZE_> using ArrOfInt_T = TRUSTArray<_SIZE_, _SIZE_>;      // either an ArrOfInt (32 bits) or a BigArrOfTID (64b)
+template <typename _SIZE_> using IntVect_T = TRUSTVect<_SIZE_, _SIZE_>;       // either an IntVect (32 bits) or a BigTIDVect (64b)
+template <typename _SIZE_> using IntTab_T = TRUSTTab<_SIZE_, _SIZE_>;         // either an IntTab (32 bits) or a BigTIDTab (64b)
+template <typename _TYPE_> using SmallArrOfTID_T = TRUSTArray<_TYPE_, int>;    // a small array of identifiers (small even in 64b)
+template <typename _TYPE_> using BigArrOfInt_T = TRUSTArray<int, _TYPE_>;    // a big array, but always storing small values (rarely used ...)
+template <typename _TYPE_> using BigIntVect_T = TRUSTVect<int, _TYPE_>;      // a big vect, but always storing small values (rarely used ...)
+
+template <typename _SIZE_> using ArrOfDouble_T= TRUSTArray<double, _SIZE_>;
+template <typename _SIZE_> using DoubleVect_T = TRUSTVect<double, _SIZE_>;
+template <typename _SIZE_> using DoubleTab_T = TRUSTTab<double, _SIZE_>;         // either an DoubleTab (32 bits) or a BigDoubleTab (64b)
+
+template <typename _SIZE_> using FloatVect_T = TRUSTVect<float, _SIZE_>;
+
+template <typename _SIZE_> using ArrsOfInt_T = TRUST_Vector<TRUSTArray<_SIZE_, _SIZE_>>;
+template <typename _SIZE_> using DoubleTabs_T = TRUST_Vector<TRUSTTab<double, _SIZE_>>;
+
+#endif /* TRUSTTabs_forward_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUSTTrav.h b/Utilities/VisItBridge/databases/readers/Lata/TRUSTTrav.h
new file mode 100644
index 00000000..2778719d
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUSTTrav.h
@@ -0,0 +1,161 @@
+/****************************************************************************
+* Copyright (c) 2025, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef TRUSTTrav_included
+#define TRUSTTrav_included
+
+#include <TRUSTTab.h>
+
+/*! @brief Temporary multidimensional array ('tableau de travail')
+ *
+ * Exactly the same as a TRUSTTab with a custom memory pool management allowing re-using previously allocated blocks
+ * See implementation in TRUSTTravPool class.
+ *
+ * 64 bits version is not defined, as those should be only used inside the timestepping algorithm.
+ */
+template<typename _TYPE_>
+class TRUSTTrav : public TRUSTTab<_TYPE_, int>
+{
+protected:
+  inline unsigned taille_memoire() const override { throw; }
+  inline Sortie& printOn(Sortie& os) const override { return TRUSTTab<_TYPE_,int>::printOn(os); }
+  inline Entree& readOn(Entree& is) override { return TRUSTTab<_TYPE_,int>::readOn(is); }
+
+  inline int duplique() const override
+  {
+    TRUSTTrav* xxx = new  TRUSTTrav(*this);
+    if(!xxx)
+      {
+        Cerr << "Not enough memory " << finl;
+        Process::exit();
+      }
+    return xxx->numero();
+  }
+
+public:
+  inline TRUSTTrav()
+  {
+    TRUSTTab<_TYPE_,int>::set_mem_storage(STORAGE::TEMP_STORAGE);
+  }
+
+  inline TRUSTTrav(int n)
+  {
+    TRUSTTab<_TYPE_,int>::set_mem_storage(STORAGE::TEMP_STORAGE);
+    TRUSTTab<_TYPE_,int>::resize(n);
+  }
+
+  inline TRUSTTrav(int n1, int n2)
+  {
+    TRUSTTab<_TYPE_,int>::set_mem_storage(STORAGE::TEMP_STORAGE);
+    TRUSTTab<_TYPE_,int>::resize(n1, n2);
+  }
+
+  inline TRUSTTrav(int n1, int n2, int n3)
+  {
+    TRUSTTab<_TYPE_,int>::set_mem_storage(STORAGE::TEMP_STORAGE);
+    TRUSTTab<_TYPE_,int>::resize(n1, n2, n3);
+  }
+
+  inline TRUSTTrav(int n1, int n2, int n3, int n4)
+  {
+    TRUSTTab<_TYPE_,int>::set_mem_storage(STORAGE::TEMP_STORAGE);
+    TRUSTTab<_TYPE_,int>::resize(n1, n2, n3, n4);
+  }
+
+  // Constructeur par copie depuis Vect
+  //  ATTENTION: construit un tableau de meme taill et de meme structure (espaces virtuels), mais initialise avec TYPE_ZERO !!!
+  inline TRUSTTrav(const TRUSTVect<_TYPE_,int>& tab)
+  {
+    TRUSTTab<_TYPE_,int>::set_mem_storage(STORAGE::TEMP_STORAGE);
+    TRUSTTab<_TYPE_,int>::set_line_size_(tab.line_size());
+    TRUSTTab<_TYPE_,int>::resize(tab.size_array(), RESIZE_OPTIONS::NOCOPY_NOINIT);
+    TRUSTTab<_TYPE_,int>::set_md_vector(tab.get_md_vector());
+    // Important! Even with default std::vector<> allocation to 0 in TRUSTArray, Trav re-uses previous blocks
+    // which might not be zero, so we enforce it:
+    TRUSTTab<_TYPE_,int>::operator=(TYPE_ZERO);
+  }
+
+  // Constructeur par copie depuis Tab
+  //  ATTENTION: construit un tableau de meme taill et de meme structure (espaces virtuels), mais initialise avec TYPE_ZERO !!!
+  inline TRUSTTrav(const TRUSTTab<_TYPE_,int>& tab)
+  {
+    TRUSTTab<_TYPE_,int>::set_mem_storage(STORAGE::TEMP_STORAGE);
+    TRUSTTab<_TYPE_,int>::copy(tab, RESIZE_OPTIONS::NOCOPY_NOINIT);
+    // Important! Even with default std::vector<> allocation to 0 in TRUSTArray, Trav re-uses previous blocks
+    // which might not be zero, so we enforce it:
+    TRUSTTab<_TYPE_,int>::operator=(TYPE_ZERO);
+  }
+
+  // Constructeur par copie depuis Trav
+  //  ATTENTION: construit un tableau de meme taill et de meme structure (espaces virtuels), mais initialise avec TYPE_ZERO !!!
+  inline TRUSTTrav(const TRUSTTrav& tab) :
+    // Force invocation of previous ctor on TRUSTTab<> since nothing new here (but this ctor must exist since 'operator=()' is coded)
+    TRUSTTrav<_TYPE_>((const TRUSTTab<_TYPE_,int>&)tab)
+  { }
+
+  // Operateurs copie
+
+  // Operateur copie (on ne veut pas l'operateur par defaut)
+  inline TRUSTTrav& operator=(const TRUSTTrav& tab)
+  {
+    TRUSTTab<_TYPE_,int>::operator=(tab);
+    return *this;
+  }
+
+  //  Operateur copie d'un tableau (copie structure ET contenu)
+  inline TRUSTTrav& operator=(const TRUSTTab<_TYPE_,int>& tab)
+  {
+    // ATTENTION: note aux programmeurs
+    //  La declaration de cet operateur est indispensable, sinon
+    //   IntTab b;
+    //   IntTrav a;
+    //   a = b
+    //  est traduit en
+    //   IntTrav tmp(b); // copie la structure mais met les valeurs a TYPE_ZERO
+    //   a.operator=(tmp);
+    TRUSTTab<_TYPE_,int>::operator=(tab);
+    return *this;
+  }
+
+  //  Operateur copie d'un tableau (copie structure ET contenu)
+  inline TRUSTTrav& operator=(const TRUSTVect<_TYPE_,int>& tab)
+  {
+    // ATTENTION: note aux programmeurs ...
+    TRUSTTab<_TYPE_,int>::operator=(tab);
+    return *this;
+  }
+
+  // Comme on surcharge l'operateur copie, il faut redefinir celui-la aussi.
+  inline TRUSTTrav& operator=(_TYPE_ d)
+  {
+    TRUSTTab<_TYPE_,int>::operator=(d);
+    return *this;
+  }
+
+private:
+  static constexpr _TYPE_ TYPE_ZERO = (_TYPE_)0;
+
+  /* APPELS INTERDITS : very in-efficient on Trvas, should use tabs */
+  void append_line(_TYPE_);
+  void append_line(_TYPE_, _TYPE_);
+  void append_line(_TYPE_, _TYPE_, _TYPE_);
+  void append_line(_TYPE_, _TYPE_, _TYPE_, _TYPE_);
+};
+
+using DoubleTrav = TRUSTTrav<double>;
+using FloatTrav = TRUSTTrav<float>;
+using IntTrav = TRUSTTrav<int>;
+
+#endif /* TRUSTTrav_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUSTTravPool.h b/Utilities/VisItBridge/databases/readers/Lata/TRUSTTravPool.h
new file mode 100644
index 00000000..4d1803da
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUSTTravPool.h
@@ -0,0 +1,55 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef TRUSTTravPool_included
+#define TRUSTTravPool_included
+
+#include <memory>
+#include <vector>
+
+#include <TVAlloc.h>
+
+/*! Pool of memory blocks used when requesting temporary storage (Trav arrays)
+ *
+ * Purely static methods. One pool per base type (int, double, etc...).
+ *
+ * The implementation details are in the .cpp file.
+ */
+template<typename _TYPE_>
+class TRUSTTravPool
+{
+public:
+  using block_ptr_t = std::shared_ptr<std::vector<_TYPE_, TVAlloc<_TYPE_> > >;
+
+  TRUSTTravPool() = delete;
+
+#ifndef LATATOOLS
+  static block_ptr_t GetFreeBlock(int sz);
+  static block_ptr_t ResizeBlock(block_ptr_t p, int new_sz);
+  static void ReleaseBlock(block_ptr_t);
+  static void ClearPool();
+#else // Cheating when compiling lata_tools: Trav are never needed:
+  static block_ptr_t GetFreeBlock(int sz) { return nullptr; }
+  static block_ptr_t ResizeBlock(block_ptr_t p, int new_sz) { return nullptr; }
+  static void ReleaseBlock(block_ptr_t) { }
+
+  static void ClearPool() { }
+#endif
+  static void DeleteOnDevice();
+  static void PrintStats();
+};
+
+
+#endif  // TRUSTTravPool_included
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUSTVect.h b/Utilities/VisItBridge/databases/readers/Lata/TRUSTVect.h
new file mode 100644
index 00000000..28d27e69
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUSTVect.h
@@ -0,0 +1,229 @@
+/****************************************************************************
+* Copyright (c) 2025, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef TRUSTVect_included
+#define TRUSTVect_included
+
+#include <type_traits>
+#include <DescStructure.h>
+#include <TRUSTArray.h>
+#include <limits.h>
+#include <math.h>
+
+#include <MD_Vector.h>
+#ifndef LATATOOLS   // Lata tools does not use parallelism
+#include <MD_Vector_tools.h>
+#include <MD_Vector_base.h>
+#include <communications.h>
+#endif
+
+template<typename _TYPE_, typename _SIZE_>
+class TRUSTVect : public TRUSTArray<_TYPE_,_SIZE_>
+{
+protected:
+  inline unsigned taille_memoire() const override { throw; }
+
+  inline int duplique() const override
+  {
+    TRUSTVect* xxx = new  TRUSTVect(*this);
+    if(!xxx) Process::exit("Not enough memory ");
+    return xxx->numero();
+  }
+
+  Sortie& printOn(Sortie& os) const override
+  {
+#ifndef LATATOOLS
+    if (TRUSTArray<_TYPE_,_SIZE_>::nproc() > 1 && md_vector_.non_nul())
+      Process::exit("Error in TRUSTVect::printOn: try to print a parallel vector");
+    TRUSTArray<_TYPE_,_SIZE_>::printOn(os);
+#endif
+    return os;
+  }
+
+  /*! @brief Lecture d'un vecteur sequentiel (comme un ArrOfDouble) Attention: appel invalide si le vecteur a un MD_Vector non nul.
+   *
+   * (pour les vecteurs paralleles, utiliser une methode de sauvegarde/reprise)
+   *
+   */
+  Entree& readOn(Entree& is) override
+  {
+#ifndef LATATOOLS
+    // Que veut-on faire si on lit dans un vecteur ayant deja une structure parallele ?
+    if (md_vector_.non_nul())
+      Process::exit("Error in TRUSTVect::readOn: vector has a parallel structure");
+    TRUSTArray<_TYPE_,_SIZE_>::readOn(is);
+    size_reelle_ = TRUSTArray<_TYPE_,_SIZE_>::size_array();
+    line_size_ = 1;
+#endif
+    return is;
+  }
+
+public:
+
+  using Span_ = tcb::span<_TYPE_>;
+
+  virtual ~TRUSTVect() { }
+
+  TRUSTVect() : size_reelle_(0), line_size_(1) { }
+
+  /*! @brief construction d'un vecteur de taille n.
+   *
+   * Les elements du vecteur sont initialises a zero par defaut. Pour ne pas initialiser les valeurs, utiliser ceci: DoubleVect toto;
+   *    toto.resize(n, RESIZE_OPTIONS::NOCOPY_NOINIT);
+   *
+   */
+  TRUSTVect(_SIZE_ n) :   TRUSTArray<_TYPE_,_SIZE_>(n), size_reelle_(n), line_size_(1) { }
+
+  /*! @brief Constructeur par copie.
+   *
+   * Il s'agit d'un "deep copy" voir ArrOfDouble::ArrOfDouble(const ArrOfDouble &) Remarque: il n'y a pas de constructeur par copie a partir de ArrOfDouble
+   *    Ceci est volontaire, sinon on risque de grosses pertes de performances par creation implicite d'objets, difficile a trouver.
+   *    (exemple: appel d'une methode toto(const IntVect &) avec un ArrOfInt produit une copie du tableau !)
+   *   Utiliser copy() pour copier un ArrOfDouble dans un DoubleVect
+   *
+   */
+  TRUSTVect(const TRUSTVect& v) : TRUSTArray<_TYPE_,_SIZE_>(v), md_vector_(v.md_vector_), size_reelle_(v.size_reelle_), line_size_(v.line_size_) { }
+
+  inline TRUSTVect& operator=(const TRUSTVect&);
+  inline TRUSTVect& operator=(_TYPE_);
+  inline _SIZE_ size() const;
+  inline _SIZE_ size_totale() const;
+  inline _SIZE_ size_reelle() const;
+  inline _SIZE_ size_reelle_ok() const;
+  inline int line_size() const;   // Even in 64b we suppose line_size_ is always sufficiently small to fit in an int.
+  inline void resize(_SIZE_, RESIZE_OPTIONS opt=RESIZE_OPTIONS::COPY_INIT);
+  inline void copy(const TRUSTArray<_TYPE_,_SIZE_>&, RESIZE_OPTIONS opt=RESIZE_OPTIONS::COPY_INIT);
+  inline void copy(const TRUSTVect&, RESIZE_OPTIONS opt=RESIZE_OPTIONS::COPY_INIT);
+  inline void operator+=(const TRUSTVect& v) { operator_add(*this, v); }
+  inline void operator+=(const _TYPE_ x) { operator_add(*this, x); }
+  inline void operator-=(const TRUSTVect& v) { operator_sub(*this, v); }
+  inline void operator-=(const _TYPE_ x) { operator_sub(*this, x); }
+  inline void operator*=(const TRUSTVect& v) { operator_multiply(*this, v); }
+  inline void operator*= (const _TYPE_ x) { operator_multiply(*this, x); }
+
+  template<typename _T_ /* double ou float */>
+  inline void operator/=(const TRUSTVect<_T_, _SIZE_>& v) { operator_divide(*this, v); }
+  inline void operator/= (const _TYPE_ x) { operator_divide(*this, x); }
+
+  inline virtual const MD_Vector& get_md_vector() const { return md_vector_; }
+  inline void resize_tab(_SIZE_ n, RESIZE_OPTIONS opt=RESIZE_OPTIONS::COPY_INIT) override;
+
+  // Options par defaut choisies pour compatibilite avec la version precedente. Attention: il y avait un echange_espace_virtuel avant, ce n'est pas strictement equivalent
+  inline void abs(Mp_vect_options opt=VECT_ALL_ITEMS) { operator_abs(*this, opt); }
+  inline void carre(Mp_vect_options opt=VECT_ALL_ITEMS) { carre_(*this, opt); }
+  inline void racine_carree(Mp_vect_options opt=VECT_ALL_ITEMS) { racine_carree_(*this, opt); }
+
+  template<typename _SCALAR_TYPE_>
+  inline void ajoute(_SCALAR_TYPE_ alpha, const TRUSTVect& y, Mp_vect_options opt=VECT_ALL_ITEMS);
+
+  template<typename _SCALAR_TYPE_>
+  inline void ajoute_sans_ech_esp_virt(_SCALAR_TYPE_ alpha, const TRUSTVect& y, Mp_vect_options opt=VECT_REAL_ITEMS);
+
+  template<typename _SCALAR_TYPE_>
+  inline void ajoute_produit_scalaire(_SCALAR_TYPE_ alpha, const TRUSTVect& x, const TRUSTVect& y, Mp_vect_options opt=VECT_ALL_ITEMS);
+
+  template<typename _SCALAR_TYPE_>
+  inline void ajoute_carre(_SCALAR_TYPE_ alpha, const TRUSTVect& y, Mp_vect_options opt=VECT_ALL_ITEMS);
+
+#ifndef LATATOOLS
+  //
+  //    All the methods below involve parallelism or are not used in lata_tools
+  //
+
+  // par defaut: min et max sur items reels (compat. 1.5.6):
+  inline _TYPE_ local_max_vect(Mp_vect_options opt=VECT_REAL_ITEMS) const { return local_max_vect_(*this, opt); }
+  inline _TYPE_ local_min_vect(Mp_vect_options opt=VECT_REAL_ITEMS) const { return local_min_vect_(*this, opt); }
+  inline _TYPE_ local_max_abs_vect(Mp_vect_options opt=VECT_REAL_ITEMS) const { return local_max_abs_vect_(*this, opt); }
+  inline _TYPE_ local_min_abs_vect(Mp_vect_options opt=VECT_REAL_ITEMS) const { return local_min_abs_vect_(*this, opt); }
+  inline _TYPE_ mp_max_vect(Mp_vect_options opt=VECT_REAL_ITEMS) const { return mp_max_vect_(*this, opt); }
+  inline _TYPE_ mp_min_vect(Mp_vect_options opt=VECT_REAL_ITEMS) const { return mp_min_vect_(*this, opt); }
+  inline _TYPE_ mp_max_abs_vect(Mp_vect_options opt=VECT_REAL_ITEMS) const { return mp_max_abs_vect_(*this, opt); }
+  inline _TYPE_ mp_min_abs_vect(Mp_vect_options opt=VECT_REAL_ITEMS) const { return mp_min_abs_vect_(*this, opt); }
+  inline _TYPE_ mp_norme_vect() const { return mp_norme_vect_(*this); }
+#endif  // LATATOOLS
+
+  // methodes virtuelles
+
+  inline virtual void ref(const TRUSTVect&);
+  inline virtual void echange_espace_virtuel();
+  inline virtual void set_md_vector(const MD_Vector&);
+  inline virtual void jump(Entree&);
+  inline virtual void lit(Entree&, bool resize_and_read=1);
+  inline virtual void ecrit(Sortie&) const;
+  inline virtual void detach_vect() { md_vector_.detach(); }
+
+  inline void ref_data(_TYPE_* ptr, _SIZE_ new_size) override;
+  inline void ref_array(TRUSTArray<_TYPE_,_SIZE_>&, _SIZE_ start = 0, _SIZE_ sz = -1) override;
+
+  inline Span_ get_span() override { return Span_(TRUSTArray<_TYPE_,_SIZE_>::addr(),size_reelle()); }
+  inline Span_ get_span_tot() override { return Span_(TRUSTArray<_TYPE_,_SIZE_>::addr(),TRUSTArray<_TYPE_,_SIZE_>::size_array()); }
+  inline const Span_ get_span() const override { return Span_((_TYPE_*)TRUSTArray<_TYPE_,_SIZE_>::addr(), size_reelle()); }
+  inline const Span_ get_span_tot() const override { return Span_((_TYPE_*)TRUSTArray<_TYPE_,_SIZE_>::addr(), TRUSTArray<_TYPE_,_SIZE_>::size_array()); }
+
+  /*! @brief met l'objet dans l'etat obtenu par le constructeur par defaut.
+   *
+   */
+  inline void reset() override
+  {
+    md_vector_.detach();
+    line_size_ = 1;
+    size_reelle_ = 0;
+    TRUSTArray<_TYPE_,_SIZE_>::reset();
+  }
+
+protected:
+  inline void set_line_size_(int n);   // Even in 64b we suppose line_size_ is always sufficiently small to fit in an int.
+  inline void resize_vect_(_SIZE_ n, RESIZE_OPTIONS opt=RESIZE_OPTIONS::COPY_INIT);
+  inline void copy_(const TRUSTVect& v, RESIZE_OPTIONS opt=RESIZE_OPTIONS::COPY_INIT);
+
+private:
+  // Un DoubleVect est un ArrOfDouble qui possede eventuellement une structure de tableau distribue. Ce pointeur peut etre nul.
+  MD_Vector md_vector_;
+
+  // Propriete size_reelle du tableau (fournie par scattered_vect_data). -1 => l'appel a size_reelle() et size() est invalide pour ce vecteur.
+  _SIZE_ size_reelle_;
+
+  // Facteur multiplicatif a appliquer entre md_vector_.nb_items_tot() et size_array() et entre md_vector_.nb_items_reels() et size_reelle_.
+  // Si l'objet est un tableau, ce facteur est generalement egal au produit des dimension(i) pour i>1 (une ligne du tableau par item geometrique du descripteur)
+  // Attention, line_size_ peut etre nul pour un tableau a zero colonnes mais pas s'il y a un descripteur attache.
+  // Even in 64b we suppose line_size_ is always sufficiently small to fit in an int.
+  int line_size_;
+};
+
+using DoubleVect = TRUSTVect<double, int>;
+using FloatVect = TRUSTVect<float, int>;
+using IntVect = TRUSTVect<int, int>;
+using TIDVect = TRUSTVect<trustIdType, int>;
+
+template <typename _TYPE_>
+using BigTRUSTVect = TRUSTVect<_TYPE_, trustIdType>;
+
+using BigDoubleVect = BigTRUSTVect<double>;
+using BigIntVect = BigTRUSTVect<int>;
+using BigTIDVect = BigTRUSTVect<trustIdType>;
+
+/* ********************************** *
+ * FONCTIONS NON MEMBRES DE TRUSTVect *
+ * ********************************** */
+
+#include <TRUSTVect_tools.tpp> // external templates function specializations ici ;)
+
+/* ****************************** *
+ * FONCTIONS MEMBRES DE TRUSTVect *
+ * ****************************** */
+
+#include <TRUSTVect.tpp> // templates specializations ici ;)
+
+#endif /* TRUSTVect_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUSTVect.tpp b/Utilities/VisItBridge/databases/readers/Lata/TRUSTVect.tpp
new file mode 100644
index 00000000..ab71e39e
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUSTVect.tpp
@@ -0,0 +1,385 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef TRUSTVect_TPP_included
+#define TRUSTVect_TPP_included
+
+#include <string>
+#include <TRUSTVect.h>
+
+//  Taille de l'espace "reel" du vecteur. (si md_vector_ est nul, cette valeur est identique a size_array(),
+//   sinon, soit elle est egale a md_vector_....get_nb_items(),
+//          soit l'appel est invalide (en particulier si les items reels ne sont pas regroupes en debut de tableau)
+//  On peut interroger le vecteur pour savoir si size_reelle() est valide avec size_reelle_ok()
+template<typename _TYPE_, typename _SIZE_>
+inline _SIZE_ TRUSTVect<_TYPE_,_SIZE_>::size_reelle() const
+{
+  // Si cet assert plante, c'est que l'appel a ete declare invalide par le MD_Vect associe a ce vecteur.
+  assert(size_reelle_ >= 0);
+  // Si cet assert plante, c'est que le tableau a ete redimensionne avec resize_array() au lieu de resize(). (invalide pour un Vect ou un Tab).
+  assert( (TRUSTArray<_TYPE_,_SIZE_>::size_array() == size_reelle_ || md_vector_.non_nul()) );
+  return size_reelle_;
+}
+
+//  renvoie 1 si l'appel a size() et size_reelle() est valide, 0 sinon
+template<typename _TYPE_, typename _SIZE_>
+inline _SIZE_ TRUSTVect<_TYPE_,_SIZE_>::size_reelle_ok() const
+{
+  return size_reelle_ >= 0;
+}
+
+//  Identique a size_reelle()
+template<typename _TYPE_, typename _SIZE_>
+inline _SIZE_ TRUSTVect<_TYPE_,_SIZE_>::size() const
+{
+  return size_reelle();
+}
+
+template<typename _TYPE_, typename _SIZE_>
+template<typename _SCALAR_TYPE_>
+inline void TRUSTVect<_TYPE_,_SIZE_>::ajoute(_SCALAR_TYPE_ alpha, const TRUSTVect& y, Mp_vect_options opt)
+{
+  assert ( (std::is_scalar<_SCALAR_TYPE_>::value) );
+  ajoute_alpha_v(*this, alpha, y, opt);
+  if (opt == VECT_ALL_ITEMS) echange_espace_virtuel();
+}
+
+//  Identique a size_array()
+template<typename _TYPE_, typename _SIZE_>
+inline _SIZE_ TRUSTVect<_TYPE_,_SIZE_>::size_totale() const
+{
+  return TRUSTArray<_TYPE_,_SIZE_>::size_array();
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline int TRUSTVect<_TYPE_,_SIZE_>::line_size() const
+{
+  // Si line_size_ est nulle, size_array doit etre nul aussi
+  assert( (line_size_ > 0 || TRUSTArray<_TYPE_,_SIZE_>::size_array() == 0) );
+  return line_size_;
+}
+
+//  change l'attribut line_size_ du tableau avec n >= 1. n == 0 est autorise uniquement si size_array_ == 0
+// Precondition: le md_vector_ doit etre nul (il faut attribuer md_vector_ apres la line_size_ car lorsqu'on attribue md_vector_ on teste
+//  la validite des tailles de tableaux en fonction de line_size_) ou la line_size_ ne doit pas changer (cas d'un resize qui ne change rien)
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTVect<_TYPE_,_SIZE_>::set_line_size_(int n)
+{
+  assert(!md_vector_.non_nul() || line_size_ == n);
+  assert(n >= 0);
+  line_size_ = n;
+}
+
+//  Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et de nouvelles cases).
+//  Attention: Cette methode n'est pas virtuelle, et afin d'eviter d'amener un DoubleTab/Int dans un etat invalide, l'appel est interdit si l'objet
+//  est de ce type. Dans ce cas, voir resize_tab.
+// Precondition: l'appel est interdit si le vecteur a une structure parallele. Le vecteur doit etre "resizable" (voir preconditions de ArrOfDouble::resize_array()).
+//  Appel interdit si l'objet n'est pas un DoubleVect (sinon mauvaise initialisation des dimensions du tableau)
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTVect<_TYPE_,_SIZE_>::resize(_SIZE_ n, RESIZE_OPTIONS opt)
+{
+  // Verifie que l'objet est bien du type DoubleVect
+  assert( (n == TRUSTArray<_TYPE_,_SIZE_>::size_array() || std::string(typeid(*this).name()).find("TRUSTVect") != std::string::npos) );
+  resize_vect_(n, opt);
+}
+
+//  Methode interne de resize (appellee par DoubleTab/Int::resize(...)) sans precondition sur le type de l'objet.
+// Precondition: l'appel est interdit si le vecteur a une structure parallele.
+//  Le vecteur doit etre "resizable" (voir preconditions de ArrOfDouble/Int::resize_array()). n doit etre un multiple de line_size_
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTVect<_TYPE_,_SIZE_>::resize_vect_(_SIZE_ n, RESIZE_OPTIONS opt)
+{
+  if (md_vector_.non_nul())
+    {
+      Cerr << "Resize of a distributed array is forbidden!" << finl;
+      Process::exit();
+    }
+  assert(n == 0 || (n > 0 && line_size_ > 0 && n % line_size_ == 0));
+  TRUSTArray<_TYPE_,_SIZE_>::resize_array_(n, opt);
+  size_reelle_ = n;
+  // ne pas mettre line_size_ a 1 ici, voir DoubleTab::resize_dim0()
+}
+
+//  copie la structure et les valeurs du tableau v dans *this avec ArrOfDouble/Int::operator=()
+//  (attention, si le tableau est de type ref_data ou ref, restrictions et cas particuliers !!!)
+//  Attention: si on ne veut pas copier les structures paralleles, utiliser inject_array()
+// Precondition: si le tableau *this doit etre resize, il doit etre de type DoubleVect (et pas d'un type derive !)
+//  Si le tableau *this a deja une structure parallele, l'appel n'est autorise que les md_vector
+//  sont deja identiques, sinon il faut d'abord faire un reset() du tableau (pour copier la structure), ou utiliser inject_array() (pour ne pas copier la structure).
+//  (ceci pour eviter d'ecraser accidentellement une structure parallele alors qu'on ne veut que copier les valeurs).
+template<typename _TYPE_, typename _SIZE_>
+inline TRUSTVect<_TYPE_,_SIZE_>& TRUSTVect<_TYPE_,_SIZE_>::operator=(const TRUSTVect& v)
+{
+  copy(v);
+  return *this;
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline TRUSTVect<_TYPE_,_SIZE_>& TRUSTVect<_TYPE_,_SIZE_>::operator=(_TYPE_ x)
+{
+  TRUSTArray<_TYPE_,_SIZE_>::operator=(x);
+  return *this;
+}
+
+//  detache le tableau et l'attache a v (sauf si v==*this, ne fait rien)
+//  Fait pointer le tableau sur la meme domaine de memoire que v et copie le MD_Vector (utilise ArrOfDouble/Int::attach_array())
+//  Attention, il devient alors interdit de resizer le tableau v ainsi que *this
+//  Methode virtuelle reimplementee dans DoubleTab
+// Precondition:
+//  L'objet ne doit pas etre un sous-type de DoubleVect (sinon mauvaise initialisation  des dimensions.
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTVect<_TYPE_,_SIZE_>::ref(const TRUSTVect& v)
+{
+  if (&v != this)
+    {
+      TRUSTArray<_TYPE_,_SIZE_>::detach_array();
+      TRUSTArray<_TYPE_,_SIZE_>::attach_array(v);
+      md_vector_ = v.md_vector_;
+      size_reelle_ = v.size_reelle_;
+      line_size_ = v.line_size_;
+    }
+}
+
+//  copie de la structure et des valeurs (si opt==COPY_INIT) du tableau v.
+//  Attention, v doit vraiment etre de type ArrOfDouble/Int, pas d'un type derive (sinon ambiguite: faut-il copier ou pas le MD_Vector ?)
+// Precondition: Le vecteur ne doit pas avoir de structure de tableau distribue et il doit vraiment etre de type Double/IntVect.
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTVect<_TYPE_,_SIZE_>::copy(const TRUSTArray<_TYPE_,_SIZE_>& v, RESIZE_OPTIONS opt)
+{
+  assert(std::string(typeid(*this).name()).find("TRUSTVect") != std::string::npos);
+  assert(std::string(typeid(v).name()).find("TRUSTArray") != std::string::npos);
+  assert(!md_vector_.non_nul());
+  resize(v.size_array(), opt);
+  if (opt != RESIZE_OPTIONS::NOCOPY_NOINIT) inject_array(v);
+}
+
+//  copie de la structure du vecteur v et des valeurs si opt==COPY_INIT.
+// Precondition: idem que operator=(const DoubleVect &)
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTVect<_TYPE_,_SIZE_>::copy(const TRUSTVect& v, RESIZE_OPTIONS opt)
+{
+  if (&v != this)
+    {
+      // Interdiction de resizer si l'objet est d'un type derive de DoubleVect (sinon mauvaise dimension(0) !)
+      assert( (v.size_array() == TRUSTArray<_TYPE_,_SIZE_>::size_array() || std::string(typeid(*this).name()).find("TRUSTVect") != std::string::npos) );
+      copy_(v, opt);
+    }
+}
+
+//  methode protegee appelable depuis une classe derivee (pas de precondition sur le type derive de *this)
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTVect<_TYPE_,_SIZE_>::copy_(const TRUSTVect& v, RESIZE_OPTIONS opt)
+{
+  assert(&v != this); // Il faut avoir fait le test avant !
+  // Si le vecteur a deja une structure parallele, la copie n'est autorisee que si
+  // le vecteur source a la meme structure. Si ce n'est pas le cas, utiliser inject_array() pour copier uniquement les valeurs, ou faire d'abord reset() si on veut ecraser la structure.
+#ifndef LATATOOLS
+  assert((!md_vector_.non_nul()) || (md_vector_ == v.md_vector_));
+#endif
+  TRUSTArray<_TYPE_,_SIZE_>::resize_array_(v.size_array(), RESIZE_OPTIONS::NOCOPY_NOINIT);
+  if (v.isDataOnDevice()) allocateOnDevice(*this); // Alloue de la memoire sur le device si v est deja alloue sur le device
+  if (opt != RESIZE_OPTIONS::NOCOPY_NOINIT)
+    TRUSTArray<_TYPE_,_SIZE_>::inject_array(v);
+  md_vector_ = v.md_vector_; // Pour le cas ou md_vector_ est nul et pas v.md_vector_
+  size_reelle_ = v.size_reelle_;
+  line_size_ = v.line_size_;
+}
+
+//  methode virtuelle identique a resize_array(), permet de traiter de facon generique les ArrOf, Vect et Tab.
+//   Cree un tableau sequentiel... Si l'objet est de type Int/DoubleVect, appel a resize(n)
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTVect<_TYPE_,_SIZE_>::resize_tab(_SIZE_ n, RESIZE_OPTIONS opt)
+{
+  resize(n, opt);
+}
+
+/*! See TRUSTArray::ref_data().
+ * Create an array without any parallel structure.
+ */
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTVect<_TYPE_,_SIZE_>::ref_data(_TYPE_* ptr, _SIZE_ size)
+{
+  md_vector_.detach();
+  TRUSTArray<_TYPE_,_SIZE_>::ref_data(ptr, size);
+  size_reelle_ = size;
+  line_size_ = 1;
+}
+
+//  voir ArrOfDouble/Int::ref_array(). (cree un tableau sans structure parallele)
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTVect<_TYPE_,_SIZE_>::ref_array(TRUSTArray<_TYPE_,_SIZE_>& m, _SIZE_ start, _SIZE_ new_size)
+{
+  md_vector_.detach();
+  TRUSTArray<_TYPE_,_SIZE_>::ref_array(m, start, new_size);
+  size_reelle_ = TRUSTArray<_TYPE_,_SIZE_>::size_array(); // pas size qui peut valoir -1
+  line_size_ = 1;
+}
+
+//  associe le md_vector au vecteur et initialise l'attribut size_reelle_ (voir methode size_reelle())
+//  Si md_vector est nul, detache simplement le md_vector existant.
+// Precondition: le vecteur doit deja avoir la taille appropriee au nouveau md_vector, c'est a dire md_vector...get_nb_items_tot() * line_size_
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTVect<_TYPE_,_SIZE_>::set_md_vector(const MD_Vector& md_vector)
+{
+#ifndef LATATOOLS
+  _SIZE_ size_r = TRUSTArray<_TYPE_,_SIZE_>::size_array();
+  if (md_vector.non_nul())
+    {
+      size_r = md_vector->get_nb_items_reels();
+      if (size_r >= 0) size_r *= line_size_;
+      else size_r = -1; // Cas particulier ou la size_reelle ne veut rien dire
+
+      // Will throw if there is a problem:
+      md_vector->validate(TRUSTArray<_TYPE_,_SIZE_>::size_array(), line_size_);
+    }
+  size_reelle_ = size_r;
+  md_vector_ = md_vector;
+#endif
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTVect<_TYPE_,_SIZE_>::echange_espace_virtuel()
+{
+#ifndef LATATOOLS
+  if(Process::is_sequential()) return;
+#if INT_is_64_ == 2
+  // echange_espace_virtuel() should not be called on big array (but can be called on small arrays of TIDs, in SolvPetsc for example):
+  assert( (!std::is_same<_SIZE_, trustIdType>::value) );
+#endif
+  MD_Vector_tools::echange_espace_virtuel(*this);
+#endif
+}
+
+#if INT_is_64_ == 2
+// We should never have to do MPI on big arrays:
+// [ABN] do not know why, constexpr test in generic version not working ...
+template<> inline void TRUSTVect<int, trustIdType>::echange_espace_virtuel()
+{
+  assert(false);
+  Process::exit("echange_espace_virtuel() called on big array or array of int!");
+}
+template<> inline void TRUSTVect<trustIdType, trustIdType>::echange_espace_virtuel()
+{
+  assert(false);
+  Process::exit("echange_espace_virtuel() called on big array or array of TID!");
+}
+template<> inline void TRUSTVect<double, trustIdType>::echange_espace_virtuel()
+{
+  assert(false);
+  Process::exit("echange_espace_virtuel() called on big array or array of double!");
+}
+template<> inline void TRUSTVect<float, trustIdType>::echange_espace_virtuel()
+{
+  assert(false);
+  Process::exit("echange_espace_virtuel() called on big array or array of float!");
+}
+#endif
+
+//  ecriture des valeurs du tableau "raw" sans structure parallele
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTVect<_TYPE_,_SIZE_>::ecrit(Sortie& os) const
+{
+#ifndef LATATOOLS
+  TRUSTArray<_TYPE_,_SIZE_>::printOn(os);
+  os << (int)-1 << finl; // le marqueur -1 indique que c'est le nouveau format "ecrit", sans structure parallele
+#endif
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTVect<_TYPE_,_SIZE_>::jump(Entree& is)
+{
+  TRUSTVect::lit(is, 0 /* Do not resize&read the array */);
+}
+
+//  lecture d'un tableau pour reprise de calcul. On lit les valeurs "raw".
+//  Attention, si le tableau n'est pas vide, il doit deja avoir la bonne taille et la bonne structure, sinon erreur !
+// Parameter resize_and_read if the array is sized AND read (by default, yes)
+template<typename _TYPE_, typename _SIZE_>
+inline void TRUSTVect<_TYPE_,_SIZE_>::lit(Entree& is, bool resize_and_read)
+{
+#ifndef LATATOOLS
+  _SIZE_ sz = -1;
+  is >> sz;
+  if (resize_and_read)
+    {
+      if (TRUSTArray<_TYPE_,_SIZE_>::size_array() == 0 && (!get_md_vector().non_nul()))
+        resize(sz, RESIZE_OPTIONS::NOCOPY_NOINIT);
+      else if (sz != TRUSTArray<_TYPE_,_SIZE_>::size_array())
+        {
+          // Si on cherche a relire un tableau de taille inconnue, le tableau doit etre reset() a l'entree. On n'aura pas la structure parallele du tableau !
+          Cerr << "Error in TRUSTVect::lit(Entree & is): array has already a structure with incorrect size" << finl;
+          Process::exit();
+        }
+      is.get(TRUSTArray<_TYPE_,_SIZE_>::addr(), sz);
+    }
+  else
+    {
+      // May be slow if large chunks are read:
+      // Double tmp;
+      //for (_SIZE_ i=0;i<sz;i++) is >> tmp;
+      // So we bufferize:
+      const _SIZE_ sz_max = 128000;
+      _SIZE_ buffer_size = std::min(sz,sz_max);
+      TRUSTArray<_TYPE_,_SIZE_> tmp(buffer_size);
+      while(sz>buffer_size)
+        {
+          is.get(tmp.addr(), buffer_size);
+          sz-=buffer_size;
+        }
+      is.get(tmp.addr(), sz);
+    }
+  _SIZE_ sz_reel = -2;
+  is >> sz_reel;
+  if (sz_reel >= 0)
+    {
+      // Lecture de l'ancien format. Ignore les valeurs lues.
+      _SIZE_ sz_virt;
+      is >> sz_virt;
+      DescStructure toto;
+      is >> toto;
+      if (!std::is_same<_TYPE_,int>::value) /* double ou float */
+        {
+          TRUSTArray<int,_SIZE_> it_communs;
+          is >> it_communs;
+          TRUSTArray<int,_SIZE_> it_communs_tot;
+          is >> it_communs_tot;
+        }
+    }
+#endif
+}
+
+template<typename _TYPE_, typename _SIZE_>
+template<typename _SCALAR_TYPE_>
+inline void TRUSTVect<_TYPE_,_SIZE_>::ajoute_sans_ech_esp_virt(_SCALAR_TYPE_ alpha, const TRUSTVect& y, Mp_vect_options opt)
+{
+  ajoute_alpha_v(*this, alpha, y, opt); // x+=alpha*y sans echange_espace_virtuel
+}
+
+template<typename _TYPE_, typename _SIZE_>
+template<typename _SCALAR_TYPE_>
+inline void TRUSTVect<_TYPE_,_SIZE_>::ajoute_produit_scalaire(_SCALAR_TYPE_ alpha, const TRUSTVect& x, const TRUSTVect& y, Mp_vect_options opt)
+{
+  ajoute_produit_scalaire(*this, alpha, x, y, opt);  // z+=alpha*x*y;
+}
+
+template<typename _TYPE_, typename _SIZE_>
+template<typename _SCALAR_TYPE_>
+inline void TRUSTVect<_TYPE_,_SIZE_>::ajoute_carre(_SCALAR_TYPE_ alpha, const TRUSTVect& y, Mp_vect_options opt)
+{
+  ajoute_operation_speciale_generic<TYPE_OPERATION_VECT_SPEC::CARRE_,_TYPE_>(*this,alpha,y,opt);
+}
+
+
+#endif /* TRUSTVect_TPP_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUSTVect_tools.cpp b/Utilities/VisItBridge/databases/readers/Lata/TRUSTVect_tools.cpp
new file mode 100644
index 00000000..b18bf4ea
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUSTVect_tools.cpp
@@ -0,0 +1,783 @@
+/****************************************************************************
+* Copyright (c) 2025, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <TRUSTVect.h>
+#include <TRUSTVect_tools.tpp>
+#include <TRUSTTabs.h>
+#include <View_Types.h>
+#ifndef LATATOOLS
+#include <MD_Vector_seq.h>
+#endif
+
+// Ajout d'un flag par appel a end_timer peut etre couteux (creation d'une string)
+#ifdef _OPENMP_TARGET
+static bool timer=true;
+#else
+static bool timer=false;
+#endif
+
+/*! Determine which blocks of indices should be used to perform an operation.
+ */
+template <typename _SIZE_>
+Block_Iter<_SIZE_> determine_blocks(Mp_vect_options opt, const MD_Vector& md, const _SIZE_ vect_size_tot, const int line_size, int& nblocs_left)
+{
+  nblocs_left = 1;
+#ifndef LATATOOLS
+  // Should we use the members bloc_items_to_* of the MD_Vector_* classes ?
+  // (this must be avoided when
+  //    - md.valeur() is not defined (md is nul)
+  //    - we want all items (VECT_SEQUENTIAL_ITEMS)
+  //    - md.valeur() is a MD_Vector_seq
+  //    - or md.valeur() is a MD_Vector_composite when it is an aggregation of several MD_Vector_seq)
+  const bool use_blocks = (opt != VECT_ALL_ITEMS && md.non_nul() && md->use_blocks());
+
+  if (use_blocks)
+    {
+      assert(opt == VECT_SEQUENTIAL_ITEMS || opt == VECT_REAL_ITEMS);
+#if INT_is_64_ == 2
+      // Should never use parallel patterns in 64b:
+      assert( (!std::is_same<_SIZE_,std::int64_t>::value) );
+#endif
+      const ArrOfInt& items_blocs = (opt == VECT_SEQUENTIAL_ITEMS) ? md->get_items_to_sum() : md->get_items_to_compute();
+      assert(items_blocs.size_array() % 2 == 0);
+      nblocs_left = items_blocs.size_array() >> 1;
+      return Block_Iter<_SIZE_>(items_blocs.addr());  // iterator on int, but operator*() will cast and return a _SIZE_
+    }
+  else
+#endif
+    if (vect_size_tot > 0)
+      {
+        // Warning, if vect_size_tot is 0, line_size might be 0 too
+        // Compute all data, in the vector (including virtual data), build a big bloc:
+        nblocs_left = 1;
+        return Block_Iter<_SIZE_>(0, vect_size_tot / line_size);   // iterator on a single (big) block
+      }
+  return Block_Iter<_SIZE_>();
+}
+
+// Explicit instanciations
+template Block_Iter<int> determine_blocks(Mp_vect_options opt, const MD_Vector& md, const int vect_size_tot, const int line_size, int& nblocs_left);
+#if INT_is_64_ == 2
+template Block_Iter<trustIdType> determine_blocks(Mp_vect_options opt, const MD_Vector& md, const trustIdType vect_size_tot, const int line_size, int& nblocs_left);
+#endif
+
+
+template<typename _TYPE_, typename _SIZE_>
+void ajoute_produit_scalaire(TRUSTVect<_TYPE_,_SIZE_>& resu, _TYPE_ alpha, const TRUSTVect<_TYPE_,_SIZE_>& vx, const TRUSTVect<_TYPE_,_SIZE_>& vy, Mp_vect_options opt)
+{
+#ifndef LATATOOLS
+  ToDo_Kokkos("critical"); // Ne semble pas utilise...
+  resu.ensureDataOnHost();
+  vx.ensureDataOnHost();
+  vy.ensureDataOnHost();
+  // Master vect donne la structure de reference, les autres vecteurs doivent avoir la meme structure.
+  const TRUSTVect<_TYPE_,_SIZE_>& master_vect = resu;
+  const int line_size = master_vect.line_size(), vect_size_tot = master_vect.size_totale();
+  const MD_Vector& md = master_vect.get_md_vector();
+  assert(vx.line_size() == line_size && vy.line_size() == line_size);
+  assert(vx.size_totale() == vect_size_tot && vy.size_totale() == vect_size_tot); // this test is necessary if md is null
+#ifndef LATATOOLS
+  assert(vx.get_md_vector() == md && vy.get_md_vector() == md);
+#endif
+  // Determine blocs of data to process, depending on " opt"
+  int nblocs_left;
+  Block_Iter<_SIZE_> bloc_itr = ::determine_blocks(opt, md, vect_size_tot, line_size, nblocs_left);
+  // Shortcut for empty arrays (avoid case line_size == 0)
+  if (bloc_itr.empty()) return;
+
+  _TYPE_ *resu_base = resu.addr();
+  const _TYPE_ *x_base = vx.addr();
+  const _TYPE_ *y_base = vy.addr();
+  for (; nblocs_left; nblocs_left--)
+    {
+      // Get index of next bloc start:
+      const int begin_bloc = (*(bloc_itr++)) * line_size, end_bloc = (*(bloc_itr++)) * line_size;
+      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
+      _TYPE_ *resu_ptr = resu_base + begin_bloc;
+      const _TYPE_ *x_ptr = x_base + begin_bloc;
+      const _TYPE_ *y_ptr = y_base + begin_bloc;
+      int count = end_bloc - begin_bloc;
+      for (; count; count--)
+        {
+          const _TYPE_ x = *x_ptr;
+          const _TYPE_ y = *(y_ptr++);
+          _TYPE_& p_resu = *(resu_ptr++);
+          p_resu += alpha * x * y;
+          x_ptr++;
+        }
+    }
+  // In debug mode, put invalid values where data has not been computed
+#ifndef NDEBUG
+  invalidate_data(resu, opt);
+#endif
+  return;
+#endif // LATATOOLS
+}
+
+// Explicit instanciation for templates:
+template void ajoute_produit_scalaire<double, int>(TRUSTVect<double, int>& resu, double alpha, const TRUSTVect<double, int>& vx, const TRUSTVect<double, int>& vy, Mp_vect_options opt);
+template void ajoute_produit_scalaire<float, int>(TRUSTVect<float, int>& resu, float alpha, const TRUSTVect<float, int>& vx, const TRUSTVect<float, int>& vy, Mp_vect_options opt);
+
+
+//Process bloc function used below in operation_speciale_tres_generic
+//It is templated as a function of the in/out view location and execution spaces (Device/Host)
+#ifndef LATATOOLS
+namespace
+{
+template<typename ExecSpace, typename _TYPE_, typename _SIZE_>
+void operation_speciale_tres_generic_kernel(TRUSTVect<_TYPE_, _SIZE_>& resu, const TRUSTVect<_TYPE_, _SIZE_>& vx, int nblocs_left,
+                                            Block_Iter<_SIZE_>& bloc_itr, int line_size_vx, int vect_size_tot, int delta_line_size, bool IS_MUL, bool kernelOnDevice)
+{
+  auto vx_view= vx.template view_ro<ExecSpace>();
+  auto resu_view= resu.template view_rw<ExecSpace>();
+
+  for (; nblocs_left; nblocs_left--)
+    {
+      // Get index of next bloc start:
+      const int begin_bloc = (*(bloc_itr++)) * line_size_vx;
+      const int end_bloc = (*(bloc_itr++)) * line_size_vx;
+      const int count = end_bloc - begin_bloc;
+
+      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
+
+      // Adjust pointers to indices
+      const int resu_start_idx = begin_bloc * delta_line_size;
+      const int x_start_idx = begin_bloc;
+
+      Kokkos::RangePolicy<ExecSpace> policy(0, count);
+      Kokkos::parallel_for(start_gpu_timer(__KERNEL_NAME__), policy, KOKKOS_LAMBDA(const int i)
+      {
+        const _TYPE_ x = vx_view(x_start_idx + i);
+
+        //The // for could be also placed there
+        for (int j = 0; j < delta_line_size; ++j)
+          {
+            const int resu_idx = resu_start_idx + i * delta_line_size + j;
+            if (IS_MUL)
+              resu_view(resu_idx) *= x;
+            else //If it's not MUL, it's DIV
+              resu_view(resu_idx) *= ((_TYPE_)1 / x);
+          }
+      });
+      end_gpu_timer(kernelOnDevice, __KERNEL_NAME__);
+    }
+}
+}
+#endif
+
+template<TYPE_OPERATION_VECT_SPEC_GENERIC _TYPE_OP_, typename _TYPE_, typename _SIZE_>
+void operation_speciale_tres_generic(TRUSTVect<_TYPE_, _SIZE_>& resu, const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt)
+{
+#ifndef LATATOOLS
+
+  // Check the nature of the operation
+  static constexpr bool IS_MUL = (_TYPE_OP_ == TYPE_OPERATION_VECT_SPEC_GENERIC::MUL_); //it's either MUL or DIV
+
+  // get info for computation
+  const int line_size = resu.line_size(), line_size_vx = vx.line_size(), vect_size_tot = resu.size_totale();
+  const MD_Vector& md = resu.get_md_vector();
+  // Le line_size du vecteur resu doit etre un multiple du line_size du vecteur vx
+  assert(line_size > 0 && line_size_vx > 0 && line_size % line_size_vx == 0);
+  const int delta_line_size = line_size / line_size_vx;
+  assert(vx.size_totale() * delta_line_size == vect_size_tot); // this test is necessary if md is null
+#ifndef LATATOOLS
+  assert(vx.get_md_vector() == md);
+#endif
+
+  // Determine blocs of data to process, depending on " opt"
+  int nblocs_left;
+  Block_Iter<_SIZE_> bloc_itr = ::determine_blocks(opt, md, vect_size_tot, line_size, nblocs_left);
+  // Shortcut for empty arrays (avoid case line_size == 0)
+  if (bloc_itr.empty())
+    return;
+
+  //Check where is the data to minimize memory transfer between Host and Device
+  bool kernelOnDevice = (vx.isDataOnDevice() && resu.isDataOnDevice());
+
+  //Lauch computation with the execution space and view types as (template) parameters
+  if (kernelOnDevice)
+    operation_speciale_tres_generic_kernel<Kokkos::DefaultExecutionSpace, _TYPE_, _SIZE_>(resu, vx, nblocs_left, bloc_itr, line_size_vx, vect_size_tot, delta_line_size, IS_MUL, kernelOnDevice);
+  else
+    operation_speciale_tres_generic_kernel<Kokkos::DefaultHostExecutionSpace, _TYPE_, _SIZE_>(resu, vx, nblocs_left, bloc_itr, line_size_vx, vect_size_tot, delta_line_size, IS_MUL, kernelOnDevice);
+
+#ifndef NDEBUG
+  // In debug mode, put invalid values where data has not been computed
+  invalidate_data(resu, opt);
+#endif
+  return;
+#endif
+}
+
+
+// Explicit instanciation for templates:
+template void operation_speciale_tres_generic<TYPE_OPERATION_VECT_SPEC_GENERIC::MUL_, double, int>(TRUSTVect<double, int>& resu, const TRUSTVect<double, int>& vx, Mp_vect_options opt);
+template void operation_speciale_tres_generic<TYPE_OPERATION_VECT_SPEC_GENERIC::MUL_, float, int>(TRUSTVect<float, int>& resu, const TRUSTVect<float, int>& vx, Mp_vect_options opt);
+template void operation_speciale_tres_generic<TYPE_OPERATION_VECT_SPEC_GENERIC::DIV_, double, int>(TRUSTVect<double, int>& resu, const TRUSTVect<double, int>& vx, Mp_vect_options opt);
+template void operation_speciale_tres_generic<TYPE_OPERATION_VECT_SPEC_GENERIC::DIV_, float, int>(TRUSTVect<float, int>& resu, const TRUSTVect<float, int>& vx, Mp_vect_options opt);
+
+
+
+template <TYPE_OPERATION_VECT_SPEC _TYPE_OP_ ,typename _TYPE_, typename _SIZE_>
+void ajoute_operation_speciale_generic(TRUSTVect<_TYPE_,_SIZE_>& resu, _TYPE_ alpha,
+                                       const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt)
+{
+  static constexpr bool IS_ADD = (_TYPE_OP_ == TYPE_OPERATION_VECT_SPEC::ADD_),
+                        IS_CARRE = (_TYPE_OP_ == TYPE_OPERATION_VECT_SPEC::CARRE_);
+
+  // Master vect donne la structure de reference, les autres vecteurs doivent avoir la meme structure.
+  const TRUSTVect<_TYPE_,_SIZE_>& master_vect = resu;
+  const int line_size = master_vect.line_size();
+  const _SIZE_ vect_size_tot = master_vect.size_totale();
+  const MD_Vector& md = master_vect.get_md_vector();
+  assert(vx.line_size() == line_size);
+  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
+#ifndef LATATOOLS
+  assert(vx.get_md_vector() == md);
+#endif
+  // Determine blocs of data to process, depending on " opt"
+  int nblocs_left;
+  Block_Iter<_SIZE_> bloc_itr = ::determine_blocks(opt, md, vect_size_tot, line_size, nblocs_left);
+  // Shortcut for empty arrays (avoid case line_size == 0)
+  if (bloc_itr.empty()) return;
+
+  bool kernelOnDevice = resu.checkDataOnDevice(vx);
+  _TYPE_ *resu_base = computeOnTheDevice(resu, "", kernelOnDevice);
+  const _TYPE_ *x_base = mapToDevice(vx, "", kernelOnDevice);
+  start_gpu_timer();
+  for (; nblocs_left; nblocs_left--)
+    {
+      // Get index of next bloc start:
+      const _SIZE_ begin_bloc = (*(bloc_itr++)) * line_size, end_bloc = (*(bloc_itr++)) * line_size;
+      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
+      _TYPE_ *resu_ptr = resu_base + begin_bloc;
+      const _TYPE_ *x_ptr = x_base + begin_bloc;
+      #pragma omp target teams distribute parallel for if (kernelOnDevice)
+      for (_SIZE_ count = 0; count < end_bloc - begin_bloc ; count++)
+        {
+          const _TYPE_ x = x_ptr[count];
+          _TYPE_& p_resu = resu_ptr[count];
+
+          if (IS_ADD) p_resu += alpha * x;
+          if (IS_CARRE) p_resu += alpha * x * x;
+        }
+    }
+  if (timer) end_gpu_timer(kernelOnDevice, __KERNEL_NAME__);
+  // In debug mode, put invalid values where data has not been computed
+#ifndef NDEBUG
+  invalidate_data(resu, opt);
+#endif
+  return;
+}
+
+// Explicit instanciation for templates:
+template void ajoute_operation_speciale_generic<TYPE_OPERATION_VECT_SPEC::ADD_, double, int>(TRUSTVect<double, int>& resu, double alpha, const TRUSTVect<double, int>& vx, Mp_vect_options opt);
+template void ajoute_operation_speciale_generic<TYPE_OPERATION_VECT_SPEC::ADD_, float, int>(TRUSTVect<float, int>& resu, float alpha, const TRUSTVect<float, int>& vx, Mp_vect_options opt);
+template void ajoute_operation_speciale_generic<TYPE_OPERATION_VECT_SPEC::CARRE_, double, int>(TRUSTVect<double, int>& resu, double alpha, const TRUSTVect<double, int>& vx, Mp_vect_options opt);
+template void ajoute_operation_speciale_generic<TYPE_OPERATION_VECT_SPEC::CARRE_, float, int>(TRUSTVect<float, int>& resu, float alpha, const TRUSTVect<float, int>& vx, Mp_vect_options opt);
+
+template <typename _TYPE_, typename _SIZE_, TYPE_OPERATOR_VECT _TYPE_OP_>
+void operator_vect_vect_generic(TRUSTVect<_TYPE_,_SIZE_>& resu, const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt)
+{
+  static constexpr bool IS_ADD = (_TYPE_OP_ == TYPE_OPERATOR_VECT::ADD_), IS_SUB = (_TYPE_OP_ == TYPE_OPERATOR_VECT::SUB_),
+                        IS_MULT = (_TYPE_OP_ == TYPE_OPERATOR_VECT::MULT_), IS_DIV = (_TYPE_OP_ == TYPE_OPERATOR_VECT::DIV_),
+                        IS_EGAL = (_TYPE_OP_ == TYPE_OPERATOR_VECT::EGAL_);
+
+  // Master vect donne la structure de reference, les autres vecteurs doivent avoir la meme structure.
+  const TRUSTVect<_TYPE_,_SIZE_>& master_vect = resu;
+  const int line_size = master_vect.line_size();
+  const _SIZE_ vect_size_tot = master_vect.size_totale();
+  const MD_Vector& md = master_vect.get_md_vector();
+  assert(vx.line_size() == line_size);
+  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
+#ifndef LATATOOLS
+  assert(vx.get_md_vector() == md);
+#endif
+  // Determine blocs of data to process, depending on " opt"
+  int nblocs_left_size;
+  Block_Iter<_SIZE_> bloc_itr = ::determine_blocks(opt, md, vect_size_tot, line_size, nblocs_left_size);
+  // Shortcut for empty arrays (avoid case line_size == 0)
+  if (bloc_itr.empty()) return;
+
+  bool kernelOnDevice = resu.checkDataOnDevice(vx);
+  _TYPE_ *resu_base = computeOnTheDevice(resu, "", kernelOnDevice);
+  const _TYPE_ *x_base = mapToDevice(vx, "", kernelOnDevice);
+  start_gpu_timer();
+  for (int nblocs_left=nblocs_left_size; nblocs_left; nblocs_left--)
+    {
+      // Get index of next bloc start:
+      const _SIZE_ begin_bloc = (*(bloc_itr++)) * line_size, end_bloc = (*(bloc_itr++)) * line_size;
+      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
+      _TYPE_ *resu_ptr = resu_base + begin_bloc;
+      const _TYPE_ *x_ptr = x_base + begin_bloc;
+      #pragma omp target teams distribute parallel for if (kernelOnDevice)
+      for (_SIZE_ count = 0; count < end_bloc - begin_bloc ; count++)
+        {
+          const _TYPE_& x = x_ptr[count];
+          _TYPE_ &p_resu = resu_ptr[count];
+          if (IS_ADD) p_resu += x;
+          if (IS_SUB) p_resu -= x;
+          if (IS_MULT) p_resu *= x;
+          if (IS_EGAL) p_resu = x;
+          if (IS_DIV)
+            {
+#ifndef _OPENMP_TARGET
+              if (x == 0.) error_divide(__func__);
+#endif
+              p_resu /= x;
+            }
+          //printf("After resu %p %p %f\n,",(void*)&x, (void*)&p_resu, p_resu);
+        }
+    }
+  if (timer) end_gpu_timer(kernelOnDevice, "operator_vect_vect_generic(x,y)");
+  // In debug mode, put invalid values where data has not been computed
+#ifndef NDEBUG
+  invalidate_data(resu, opt);
+#endif
+  return;
+}
+// Explicit instanciation for templates:
+template void operator_vect_vect_generic<double, int, TYPE_OPERATOR_VECT::ADD_>(TRUSTVect<double, int>& resu, const TRUSTVect<double, int>& vx, Mp_vect_options opt);
+template void operator_vect_vect_generic<int, int, TYPE_OPERATOR_VECT::ADD_>(TRUSTVect<int, int>& resu, const TRUSTVect<int, int>& vx, Mp_vect_options opt);
+template void operator_vect_vect_generic<float, int, TYPE_OPERATOR_VECT::ADD_>(TRUSTVect<float, int>& resu, const TRUSTVect<float, int>& vx, Mp_vect_options opt);
+template void operator_vect_vect_generic<double, int, TYPE_OPERATOR_VECT::SUB_>(TRUSTVect<double, int>& resu, const TRUSTVect<double, int>& vx, Mp_vect_options opt);
+template void operator_vect_vect_generic<int, int, TYPE_OPERATOR_VECT::SUB_>(TRUSTVect<int, int>& resu, const TRUSTVect<int, int>& vx, Mp_vect_options opt);
+template void operator_vect_vect_generic<float, int, TYPE_OPERATOR_VECT::SUB_>(TRUSTVect<float, int>& resu, const TRUSTVect<float, int>& vx, Mp_vect_options opt);
+template void operator_vect_vect_generic<double, int, TYPE_OPERATOR_VECT::MULT_>(TRUSTVect<double, int>& resu, const TRUSTVect<double, int>& vx, Mp_vect_options opt);
+template void operator_vect_vect_generic<int, int, TYPE_OPERATOR_VECT::MULT_>(TRUSTVect<int, int>& resu, const TRUSTVect<int, int>& vx, Mp_vect_options opt);
+template void operator_vect_vect_generic<float, int, TYPE_OPERATOR_VECT::MULT_>(TRUSTVect<float, int>& resu, const TRUSTVect<float, int>& vx, Mp_vect_options opt);
+template void operator_vect_vect_generic<double, int, TYPE_OPERATOR_VECT::DIV_>(TRUSTVect<double, int>& resu, const TRUSTVect<double, int>& vx, Mp_vect_options opt);
+template void operator_vect_vect_generic<int, int, TYPE_OPERATOR_VECT::DIV_>(TRUSTVect<int, int>& resu, const TRUSTVect<int, int>& vx, Mp_vect_options opt);
+template void operator_vect_vect_generic<float, int, TYPE_OPERATOR_VECT::DIV_>(TRUSTVect<float, int>& resu, const TRUSTVect<float, int>& vx, Mp_vect_options opt);
+template void operator_vect_vect_generic<double, int, TYPE_OPERATOR_VECT::EGAL_>(TRUSTVect<double, int>& resu, const TRUSTVect<double, int>& vx, Mp_vect_options opt);
+template void operator_vect_vect_generic<int, int, TYPE_OPERATOR_VECT::EGAL_>(TRUSTVect<int, int>& resu, const TRUSTVect<int, int>& vx, Mp_vect_options opt);
+template void operator_vect_vect_generic<float, int, TYPE_OPERATOR_VECT::EGAL_>(TRUSTVect<float, int>& resu, const TRUSTVect<float, int>& vx, Mp_vect_options opt);
+
+template <typename _TYPE_, typename _SIZE_, TYPE_OPERATOR_SINGLE _TYPE_OP_ >
+void operator_vect_single_generic(TRUSTVect<_TYPE_,_SIZE_>& resu, const _TYPE_ x, Mp_vect_options opt)
+{
+  static constexpr bool IS_ADD = (_TYPE_OP_ == TYPE_OPERATOR_SINGLE::ADD_), IS_SUB = (_TYPE_OP_ == TYPE_OPERATOR_SINGLE::SUB_),
+                        IS_MULT = (_TYPE_OP_ == TYPE_OPERATOR_SINGLE::MULT_), IS_DIV = (_TYPE_OP_ == TYPE_OPERATOR_SINGLE::DIV_), IS_EGAL = (_TYPE_OP_ == TYPE_OPERATOR_SINGLE::EGAL_),
+                        IS_NEGATE = (_TYPE_OP_ == TYPE_OPERATOR_SINGLE::NEGATE_), IS_INV = (_TYPE_OP_ == TYPE_OPERATOR_SINGLE::INV_), IS_ABS = (_TYPE_OP_ == TYPE_OPERATOR_SINGLE::ABS_),
+                        IS_RACINE_CARRE = (_TYPE_OP_ == TYPE_OPERATOR_SINGLE::RACINE_CARRE_), IS_CARRE = (_TYPE_OP_ == TYPE_OPERATOR_SINGLE::CARRE_);
+
+  // Master vect donne la structure de reference, les autres vecteurs doivent avoir la meme structure.
+  const TRUSTVect<_TYPE_,_SIZE_>& master_vect = resu;
+  const int line_size = master_vect.line_size();
+  const _SIZE_ vect_size_tot = master_vect.size_totale();
+  const MD_Vector& md = master_vect.get_md_vector();
+  // Determine blocs of data to process, depending on " opt"
+  int nblocs_left;
+  Block_Iter<_SIZE_> bloc_itr = ::determine_blocks(opt, md, vect_size_tot, line_size, nblocs_left);
+  // Shortcut for empty arrays (avoid case line_size == 0)
+  if (bloc_itr.empty()) return;
+
+  bool kernelOnDevice = resu.checkDataOnDevice();
+  _TYPE_ *resu_base = computeOnTheDevice(resu, "", kernelOnDevice);
+  start_gpu_timer();
+  for (; nblocs_left; nblocs_left--)
+    {
+      // Get index of next bloc start:
+      const _SIZE_ begin_bloc = (*(bloc_itr++)) * line_size, end_bloc = (*(bloc_itr++)) * line_size;
+      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
+      _TYPE_ *resu_ptr = resu_base + begin_bloc;
+      #pragma omp target teams distribute parallel for if (kernelOnDevice)
+      for (_SIZE_ count=0; count < end_bloc - begin_bloc; count++)
+        {
+          _TYPE_ &p_resu = resu_ptr[count];
+          if (IS_ADD) p_resu += x;
+          if (IS_SUB) p_resu -= x;
+          if (IS_MULT) p_resu *= x;
+          if (IS_EGAL) p_resu = x;
+          if (IS_NEGATE) p_resu = -p_resu;
+          if (IS_ABS) p_resu = (_TYPE_) std::abs(p_resu);  // the proper specialisation of std::abs should be selected (int, long, float, double)
+          if (IS_RACINE_CARRE) p_resu = (_TYPE_) sqrt(p_resu);  // _TYPE_ casting just to pass 'int' instanciation of the template wo triggering -Wconversion warning
+          if (IS_CARRE) p_resu *= p_resu;
+
+          if (IS_DIV)
+            {
+#ifndef _OPENMP_TARGET
+              if (x == (_TYPE_)0) error_divide(__func__);
+#endif
+              p_resu /= x;
+            }
+
+          if (IS_INV)
+            {
+#ifndef _OPENMP_TARGET
+              if (p_resu == (_TYPE_)0) error_divide(__func__);
+#endif
+              p_resu = (_TYPE_) ((_TYPE_)1 / p_resu); // same as sqrt above
+            }
+        }
+    }
+  if (timer) end_gpu_timer(kernelOnDevice, "operator_vect_single_generic(x,y)");
+  // In debug mode, put invalid values where data has not been computed
+#ifndef NDEBUG
+  invalidate_data(resu, opt);
+#endif
+  return;
+}
+// Explicit instanciation for templates:
+template void operator_vect_single_generic<double, int, TYPE_OPERATOR_SINGLE::ADD_>(TRUSTVect<double, int>& resu, const double x, Mp_vect_options opt);
+template void operator_vect_single_generic<int, int, TYPE_OPERATOR_SINGLE::ADD_>(TRUSTVect<int, int>& resu, const int x, Mp_vect_options opt);
+template void operator_vect_single_generic<float, int, TYPE_OPERATOR_SINGLE::ADD_>(TRUSTVect<float, int>& resu, const float x, Mp_vect_options opt);
+template void operator_vect_single_generic<double, int, TYPE_OPERATOR_SINGLE::SUB_>(TRUSTVect<double, int>& resu, const double x, Mp_vect_options opt);
+template void operator_vect_single_generic<int, int, TYPE_OPERATOR_SINGLE::SUB_>(TRUSTVect<int, int>& resu, const int x, Mp_vect_options opt);
+template void operator_vect_single_generic<float, int, TYPE_OPERATOR_SINGLE::SUB_>(TRUSTVect<float, int>& resu, const float x, Mp_vect_options opt);
+template void operator_vect_single_generic<double, int, TYPE_OPERATOR_SINGLE::MULT_>(TRUSTVect<double, int>& resu, const double x, Mp_vect_options opt);
+template void operator_vect_single_generic<int, int, TYPE_OPERATOR_SINGLE::MULT_>(TRUSTVect<int, int>& resu, const int x, Mp_vect_options opt);
+template void operator_vect_single_generic<float, int, TYPE_OPERATOR_SINGLE::MULT_>(TRUSTVect<float, int>& resu, const float x, Mp_vect_options opt);
+template void operator_vect_single_generic<double, int, TYPE_OPERATOR_SINGLE::DIV_>(TRUSTVect<double, int>& resu, const double x, Mp_vect_options opt);
+template void operator_vect_single_generic<int, int, TYPE_OPERATOR_SINGLE::DIV_>(TRUSTVect<int, int>& resu, const int x, Mp_vect_options opt);
+template void operator_vect_single_generic<float, int, TYPE_OPERATOR_SINGLE::DIV_>(TRUSTVect<float, int>& resu, const float x, Mp_vect_options opt);
+template void operator_vect_single_generic<double, int, TYPE_OPERATOR_SINGLE::EGAL_>(TRUSTVect<double, int>& resu, const double x, Mp_vect_options opt);
+template void operator_vect_single_generic<int, int, TYPE_OPERATOR_SINGLE::EGAL_>(TRUSTVect<int, int>& resu, const int x, Mp_vect_options opt);
+template void operator_vect_single_generic<float, int, TYPE_OPERATOR_SINGLE::EGAL_>(TRUSTVect<float, int>& resu, const float x, Mp_vect_options opt);
+template void operator_vect_single_generic<double, int, TYPE_OPERATOR_SINGLE::NEGATE_>(TRUSTVect<double, int>& resu, const double x, Mp_vect_options opt);
+template void operator_vect_single_generic<int, int, TYPE_OPERATOR_SINGLE::NEGATE_>(TRUSTVect<int, int>& resu, const int x, Mp_vect_options opt);
+template void operator_vect_single_generic<float, int, TYPE_OPERATOR_SINGLE::NEGATE_>(TRUSTVect<float, int>& resu, const float x, Mp_vect_options opt);
+template void operator_vect_single_generic<double, int, TYPE_OPERATOR_SINGLE::INV_>(TRUSTVect<double, int>& resu, const double x, Mp_vect_options opt);
+template void operator_vect_single_generic<int, int, TYPE_OPERATOR_SINGLE::INV_>(TRUSTVect<int, int>& resu, const int x, Mp_vect_options opt);
+template void operator_vect_single_generic<float, int, TYPE_OPERATOR_SINGLE::INV_>(TRUSTVect<float, int>& resu, const float x, Mp_vect_options opt);
+template void operator_vect_single_generic<double, int, TYPE_OPERATOR_SINGLE::ABS_>(TRUSTVect<double, int>& resu, const double x, Mp_vect_options opt);
+template void operator_vect_single_generic<int, int, TYPE_OPERATOR_SINGLE::ABS_>(TRUSTVect<int, int>& resu, const int x, Mp_vect_options opt);
+template void operator_vect_single_generic<float, int, TYPE_OPERATOR_SINGLE::ABS_>(TRUSTVect<float, int>& resu, const float x, Mp_vect_options opt);
+template void operator_vect_single_generic<double, int, TYPE_OPERATOR_SINGLE::RACINE_CARRE_>(TRUSTVect<double, int>& resu, const double x, Mp_vect_options opt);
+template void operator_vect_single_generic<int, int, TYPE_OPERATOR_SINGLE::RACINE_CARRE_>(TRUSTVect<int, int>& resu, const int x, Mp_vect_options opt);
+template void operator_vect_single_generic<float, int, TYPE_OPERATOR_SINGLE::RACINE_CARRE_>(TRUSTVect<float, int>& resu, const float x, Mp_vect_options opt);
+template void operator_vect_single_generic<double, int, TYPE_OPERATOR_SINGLE::CARRE_>(TRUSTVect<double, int>& resu, const double x, Mp_vect_options opt);
+template void operator_vect_single_generic<int, int, TYPE_OPERATOR_SINGLE::CARRE_>(TRUSTVect<int, int>& resu, const int x, Mp_vect_options opt);
+template void operator_vect_single_generic<float, int, TYPE_OPERATOR_SINGLE::CARRE_>(TRUSTVect<float, int>& resu, const float x, Mp_vect_options opt);
+
+#if INT_is_64_ == 2
+template void operator_vect_single_generic<trustIdType, trustIdType, TYPE_OPERATOR_SINGLE::ADD_>(TRUSTVect<trustIdType, trustIdType>& resu, const trustIdType x, Mp_vect_options opt);
+template void operator_vect_single_generic<int, trustIdType, TYPE_OPERATOR_SINGLE::ADD_>(TRUSTVect<int, trustIdType>& resu, const int x, Mp_vect_options opt);
+template void operator_vect_single_generic<float, trustIdType, TYPE_OPERATOR_SINGLE::ADD_>(TRUSTVect<float, trustIdType>& resu, const float x, Mp_vect_options opt);
+template void operator_vect_single_generic<double, trustIdType, TYPE_OPERATOR_SINGLE::ADD_>(TRUSTVect<double, trustIdType>& resu, const double x, Mp_vect_options opt);
+
+template void operator_vect_single_generic<trustIdType, trustIdType, TYPE_OPERATOR_SINGLE::SUB_>(TRUSTVect<trustIdType, trustIdType>& resu, const trustIdType x, Mp_vect_options opt);
+template void operator_vect_single_generic<int, trustIdType, TYPE_OPERATOR_SINGLE::SUB_>(TRUSTVect<int, trustIdType>& resu, const int x, Mp_vect_options opt);
+template void operator_vect_single_generic<float, trustIdType, TYPE_OPERATOR_SINGLE::SUB_>(TRUSTVect<float, trustIdType>& resu, const float x, Mp_vect_options opt);
+template void operator_vect_single_generic<double, trustIdType, TYPE_OPERATOR_SINGLE::SUB_>(TRUSTVect<double, trustIdType>& resu, const double x, Mp_vect_options opt);
+
+template void operator_vect_single_generic<double, trustIdType, TYPE_OPERATOR_SINGLE::MULT_>(TRUSTVect<double, trustIdType>& resu, const double x, Mp_vect_options opt);
+template void operator_vect_single_generic<float, trustIdType, TYPE_OPERATOR_SINGLE::MULT_>(TRUSTVect<float, trustIdType>& resu, const float x, Mp_vect_options opt);
+
+template void operator_vect_single_generic<double, trustIdType, TYPE_OPERATOR_SINGLE::DIV_>(TRUSTVect<double, trustIdType>& resu, const double x, Mp_vect_options opt);
+
+
+#endif
+
+template <typename _TYPE_, typename _SIZE_, typename _TYPE_RETURN_, TYPE_OPERATION_VECT _TYPE_OP_ >
+_TYPE_RETURN_ local_extrema_vect_generic(const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt)
+{
+  static constexpr bool IS_IMAX = (_TYPE_OP_ == TYPE_OPERATION_VECT::IMAX_), IS_IMIN = (_TYPE_OP_ == TYPE_OPERATION_VECT::IMIN_), IS_MAX = (_TYPE_OP_ == TYPE_OPERATION_VECT::MAX_),
+                        IS_MIN = (_TYPE_OP_ == TYPE_OPERATION_VECT::MIN_), IS_MAX_ABS = (_TYPE_OP_ == TYPE_OPERATION_VECT::MAX_ABS_), IS_MIN_ABS = (_TYPE_OP_ == TYPE_OPERATION_VECT::MIN_ABS_);
+
+  _TYPE_ min_max_val = neutral_value<_TYPE_,_TYPE_OP_>(); // _TYPE_ et pas _TYPE_RETURN_ desole ...
+  _TYPE_RETURN_ i_min_max = -1 ; // seulement pour IMAX_ et IMIN_
+
+  // Master vect donne la structure de reference, les autres vecteurs doivent avoir la meme structure.
+  const TRUSTVect<_TYPE_,_SIZE_>& master_vect = vx;
+  const int line_size = master_vect.line_size();
+  const _SIZE_ vect_size_tot = master_vect.size_totale();
+  const MD_Vector& md = master_vect.get_md_vector();
+  assert(vx.line_size() == line_size);
+  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
+#ifndef LATATOOLS
+  assert(vx.get_md_vector() == md);
+#endif
+  // Determine blocs of data to process, depending on " opt"
+  int nblocs_left;
+  Block_Iter<_SIZE_> bloc_itr = ::determine_blocks(opt, md, vect_size_tot, line_size, nblocs_left);
+  // Shortcut for empty arrays (avoid case line_size == 0)
+  if (bloc_itr.empty())
+    return (IS_IMAX || IS_IMIN) ? i_min_max : (_TYPE_RETURN_)min_max_val;
+
+  bool kernelOnDevice = vx.checkDataOnDevice();
+  const _TYPE_ *x_base = mapToDevice(vx, "", kernelOnDevice);
+  start_gpu_timer();
+  for (; nblocs_left; nblocs_left--)
+    {
+      // Get index of next bloc start:
+      const _SIZE_ begin_bloc = (*(bloc_itr++)) * line_size, end_bloc = (*(bloc_itr++)) * line_size;
+      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
+      const _TYPE_ *x_ptr = x_base + begin_bloc;
+      _SIZE_ size_bloc = end_bloc - begin_bloc;
+      if (IS_MAX || IS_MAX_ABS)
+        {
+          if (kernelOnDevice)
+            {
+              #pragma omp target teams distribute parallel for reduction(max:min_max_val)
+              for (_SIZE_ count = 0; count < size_bloc; count++)
+                {
+                  const _TYPE_ x = IS_MAX ? x_ptr[count] : (_TYPE_) std::abs(x_ptr[count]);
+                  if (x > min_max_val) min_max_val = x;
+                }
+            }
+          else
+            {
+              for (_SIZE_ count = 0; count < size_bloc; count++)
+                {
+                  const _TYPE_ x = IS_MAX ? x_ptr[count] : std::is_same<_TYPE_, int>::value ? (_TYPE_) std::abs(
+                                     x_ptr[count]) : (_TYPE_) std::fabs(x_ptr[count]);
+                  if (x > min_max_val) min_max_val = x;
+                }
+            }
+        }
+      else if (IS_MIN || IS_MIN_ABS)
+        {
+          if (kernelOnDevice)
+            {
+              #pragma omp target teams distribute parallel for reduction(min:min_max_val)
+              for (_SIZE_ count = 0; count < size_bloc; count++)
+                {
+                  const _TYPE_ x = IS_MIN ? x_ptr[count] : (_TYPE_) std::abs(x_ptr[count]);
+                  if (x < min_max_val) min_max_val = x;
+                }
+            }
+          else
+            {
+              for (_SIZE_ count = 0; count < size_bloc; count++)
+                {
+                  const _TYPE_ x = IS_MIN ? x_ptr[count] : (_TYPE_) std::abs(x_ptr[count]);
+                  if (x < min_max_val) min_max_val = x;
+                }
+            }
+        }
+      // ToDo OpenMP Pas porte sur device car le compilateur NVidia plante:
+      if (IS_IMAX || IS_IMIN)
+        {
+          for (_SIZE_ count = 0; count < size_bloc; count++)
+            {
+              const _TYPE_ x = x_ptr[count];
+              if ((IS_IMAX && x > min_max_val) || (IS_IMIN && x < min_max_val))
+                {
+                  i_min_max = (_TYPE_RETURN_) count;
+                  min_max_val = x;
+                }
+            }
+        }
+      // Compilateur NVidia plante sur cela: "symbol local_min_max_val(20167) is team-private but we are returning false"
+      /*
+      if (IS_IMAX || IS_IMIN)
+        {
+          #pragma omp target parallel if (kernelOnDevice)
+          {
+            _TYPE_ local_min_max_val = min_max_val;
+            _TYPE_RETURN_ local_i_min_max = -1;
+            #pragma omp for nowait
+            for (_SIZE_ count = 0; count < end_bloc - begin_bloc; count++)
+              {
+                const _TYPE_ x = x_ptr[count];
+                if ((IS_IMAX && x > local_min_max_val) || (IS_IMIN && x < local_min_max_val))
+                  {
+                    local_min_max_val = x;
+                    local_i_min_max = (_TYPE_RETURN_) count;
+                  }
+              }
+            #pragma omp critical
+            {
+              if ((IS_IMAX && local_min_max_val > min_max_val) || (IS_IMIN && local_min_max_val < min_max_val))
+                {
+                  min_max_val = local_min_max_val;
+                  i_min_max = local_i_min_max;
+                }
+            }
+          }
+        } */
+    }
+  if (timer) end_gpu_timer(kernelOnDevice, "local_extrema_vect_generic(x)");
+  return (IS_IMAX || IS_IMIN) ? i_min_max : (_TYPE_RETURN_)min_max_val;
+}
+// Explicit instanciation for templates:
+template double local_extrema_vect_generic<double, int, double, TYPE_OPERATION_VECT::IMAX_>(const TRUSTVect<double, int>& vx, Mp_vect_options opt);
+template double local_extrema_vect_generic<double, int, double, TYPE_OPERATION_VECT::IMIN_>(const TRUSTVect<double, int>& vx, Mp_vect_options opt);
+template double local_extrema_vect_generic<double, int, double, TYPE_OPERATION_VECT::MAX_>(const TRUSTVect<double, int>& vx, Mp_vect_options opt);
+template double local_extrema_vect_generic<double, int, double, TYPE_OPERATION_VECT::MIN_>(const TRUSTVect<double, int>& vx, Mp_vect_options opt);
+template double local_extrema_vect_generic<double, int, double, TYPE_OPERATION_VECT::MAX_ABS_>(const TRUSTVect<double, int>& vx, Mp_vect_options opt);
+template double local_extrema_vect_generic<double, int, double, TYPE_OPERATION_VECT::MIN_ABS_>(const TRUSTVect<double, int>& vx, Mp_vect_options opt);
+template int local_extrema_vect_generic<double, int, int, TYPE_OPERATION_VECT::IMAX_>(const TRUSTVect<double, int>& vx, Mp_vect_options opt);
+template int local_extrema_vect_generic<double, int, int, TYPE_OPERATION_VECT::IMIN_>(const TRUSTVect<double, int>& vx, Mp_vect_options opt);
+template int local_extrema_vect_generic<double, int, int, TYPE_OPERATION_VECT::MAX_>(const TRUSTVect<double, int>& vx, Mp_vect_options opt);
+template int local_extrema_vect_generic<double, int, int, TYPE_OPERATION_VECT::MIN_>(const TRUSTVect<double, int>& vx, Mp_vect_options opt);
+template int local_extrema_vect_generic<double, int, int, TYPE_OPERATION_VECT::MAX_ABS_>(const TRUSTVect<double, int>& vx, Mp_vect_options opt);
+template int local_extrema_vect_generic<double, int, int, TYPE_OPERATION_VECT::MIN_ABS_>(const TRUSTVect<double, int>& vx, Mp_vect_options opt);
+template int local_extrema_vect_generic<int, int, int, TYPE_OPERATION_VECT::IMAX_>(const TRUSTVect<int, int>& vx, Mp_vect_options opt);
+template int local_extrema_vect_generic<int, int, int, TYPE_OPERATION_VECT::IMIN_>(const TRUSTVect<int, int>& vx, Mp_vect_options opt);
+template int local_extrema_vect_generic<int, int, int, TYPE_OPERATION_VECT::MAX_>(const TRUSTVect<int, int>& vx, Mp_vect_options opt);
+template int local_extrema_vect_generic<int, int, int, TYPE_OPERATION_VECT::MIN_>(const TRUSTVect<int, int>& vx, Mp_vect_options opt);
+template int local_extrema_vect_generic<int, int, int, TYPE_OPERATION_VECT::MAX_ABS_>(const TRUSTVect<int, int>& vx, Mp_vect_options opt);
+template int local_extrema_vect_generic<int, int, int, TYPE_OPERATION_VECT::MIN_ABS_>(const TRUSTVect<int, int>& vx, Mp_vect_options opt);
+
+#if INT_is_64_ == 2
+template int local_extrema_vect_generic<int, trustIdType, int, TYPE_OPERATION_VECT::MAX_>(const TRUSTVect<int, trustIdType>& vx, Mp_vect_options opt);
+template trustIdType local_extrema_vect_generic<trustIdType, trustIdType, trustIdType, TYPE_OPERATION_VECT::MAX_>(const TRUSTVect<trustIdType, trustIdType>& vx, Mp_vect_options opt);
+#endif
+
+template <typename _TYPE_, typename _SIZE_, TYPE_OPERATION_VECT_BIS _TYPE_OP_ >
+_TYPE_ local_operations_vect_bis_generic(const TRUSTVect<_TYPE_,_SIZE_>& vx,Mp_vect_options opt)
+{
+  static constexpr bool IS_CARRE = (_TYPE_OP_ == TYPE_OPERATION_VECT_BIS::CARRE_), IS_SOMME = (_TYPE_OP_ == TYPE_OPERATION_VECT_BIS::SOMME_);
+
+  _TYPE_ sum = 0;
+  // Master vect donne la structure de reference, les autres vecteurs doivent avoir la meme structure.
+  const TRUSTVect<_TYPE_,_SIZE_>& master_vect = vx;
+  const int line_size = master_vect.line_size();
+  const _SIZE_ vect_size_tot = master_vect.size_totale();
+  const MD_Vector& md = master_vect.get_md_vector();
+  assert(vx.line_size() == line_size);
+  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
+#ifndef LATATOOLS
+  assert(vx.get_md_vector() == md);
+#endif
+  // Determine blocs of data to process, depending on " opt"
+  int nblocs_left;
+  Block_Iter<_SIZE_> bloc_itr  = ::determine_blocks(opt, md, vect_size_tot, line_size, nblocs_left);
+  // Shortcut for empty arrays (avoid case line_size == 0)
+  if (bloc_itr.empty()) return sum;
+
+  bool kernelOnDevice = vx.checkDataOnDevice();
+  const _TYPE_ *x_base = mapToDevice(vx, "", kernelOnDevice);
+  start_gpu_timer();
+  for (; nblocs_left; nblocs_left--)
+    {
+      // Get index of next bloc start:
+      const _SIZE_ begin_bloc = (*(bloc_itr++)) * line_size, end_bloc = (*(bloc_itr++)) * line_size;
+      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
+      const _TYPE_ *x_ptr = x_base + begin_bloc;
+      if (kernelOnDevice)
+        {
+          #pragma omp target teams distribute parallel for reduction(+:sum)
+          for (_SIZE_ count = 0; count < end_bloc - begin_bloc; count++)
+            {
+              const _TYPE_ x = x_ptr[count];
+              if (IS_CARRE) sum += x * x;
+              if (IS_SOMME) sum += x;
+            }
+        }
+      else
+        {
+          for (_SIZE_ count = 0; count < end_bloc - begin_bloc; count++)
+            {
+              const _TYPE_ x = x_ptr[count];
+              if (IS_CARRE) sum += x * x;
+              if (IS_SOMME) sum += x;
+            }
+        }
+    }
+  if (timer) end_gpu_timer(kernelOnDevice, "local_operations_vect_bis_generic(x)");
+  return sum;
+}
+// Explicit instanciation for templates:
+template double local_operations_vect_bis_generic<double, int, TYPE_OPERATION_VECT_BIS::CARRE_>(const TRUSTVect<double, int>& vx,Mp_vect_options opt);
+template int local_operations_vect_bis_generic<int, int, TYPE_OPERATION_VECT_BIS::CARRE_>(const TRUSTVect<int, int>& vx,Mp_vect_options opt);
+template float local_operations_vect_bis_generic<float, int, TYPE_OPERATION_VECT_BIS::CARRE_>(const TRUSTVect<float, int>& vx,Mp_vect_options opt);
+template double local_operations_vect_bis_generic<double, int, TYPE_OPERATION_VECT_BIS::SOMME_>(const TRUSTVect<double, int>& vx,Mp_vect_options opt);
+template int local_operations_vect_bis_generic<int, int, TYPE_OPERATION_VECT_BIS::SOMME_>(const TRUSTVect<int, int>& vx,Mp_vect_options opt);
+template float local_operations_vect_bis_generic<float, int, TYPE_OPERATION_VECT_BIS::SOMME_>(const TRUSTVect<float, int>& vx,Mp_vect_options opt);
+
+#if INT_is_64_ == 2
+template double local_operations_vect_bis_generic<double, trustIdType, TYPE_OPERATION_VECT_BIS::SOMME_>(const TRUSTVect<double, trustIdType>& vx,Mp_vect_options opt);
+#endif
+
+// ==================================================================================================================================
+// DEBUT code pour debug
+#ifndef NDEBUG
+// INVALID_SCALAR is used to fill arrays when values are not computed (virtual space might not be computed by operators).
+// The value below probably triggers errors on parallel test cases but does not prevent from doing "useless" computations with it.
+template <typename _TYPE_, typename _SIZE_>
+void invalidate_data(TRUSTVect<_TYPE_,_SIZE_>& resu, Mp_vect_options opt)
+{
+#ifndef LATATOOLS
+  if (Process::is_sequential()) return; // no invalid values in sequential
+
+  _TYPE_ invalid = (_TYPE_)-987654321;
+
+  const MD_Vector& md = resu.get_md_vector();
+  const int line_size = resu.line_size();
+  if (opt == VECT_ALL_ITEMS || (!md.non_nul())) return; // no invalid values
+  assert(opt == VECT_SEQUENTIAL_ITEMS || opt == VECT_REAL_ITEMS);
+  const ArrOfInt& items_blocs = (opt == VECT_SEQUENTIAL_ITEMS) ? md->get_items_to_sum() : md->get_items_to_compute();
+  const int blocs_size = items_blocs.size_array();
+  int i = 0;
+  bool kernelOnDevice = resu.checkDataOnDevice();
+  _TYPE_ *resu_ptr = computeOnTheDevice(resu, "", kernelOnDevice);
+  start_gpu_timer();
+  for (int blocs_idx = 0; blocs_idx < blocs_size; blocs_idx += 2) // process data until beginning of next bloc, or end of array
+    {
+      const int bloc_end = line_size * items_blocs[blocs_idx];
+      #pragma omp target teams distribute parallel for if (kernelOnDevice)
+      for (int count=i; count < bloc_end; count++) resu_ptr[count] = invalid;
+      i = items_blocs[blocs_idx+1] * line_size;
+    }
+  const _SIZE_ bloc_end = resu.size_array(); // Process until end of vector
+  #pragma omp target teams distribute parallel for if (kernelOnDevice)
+  for (_SIZE_ count=i; count < bloc_end; count++) resu_ptr[count] = invalid;
+  if (timer) end_gpu_timer(kernelOnDevice, "invalidate_data(x)");
+#endif
+}
+// FIN code pour debug
+// ==================================================================================================================================
+// Explicit instanciation for templates:
+template void invalidate_data<double>(TRUSTVect<double, int>& resu, Mp_vect_options opt);
+template void invalidate_data<float>(TRUSTVect<float, int>& resu, Mp_vect_options opt);
+template void invalidate_data<int>(TRUSTVect<int, int>& resu, Mp_vect_options opt);
+#endif /* NDEBUG */
+
+template<typename _TYPE_, typename _SIZE_>
+_TYPE_ local_prodscal(const TRUSTVect<_TYPE_,_SIZE_>& vx, const TRUSTVect<_TYPE_,_SIZE_>& vy, Mp_vect_options opt)
+{
+  _TYPE_ sum = 0;
+  // Master vect donne la structure de reference, les autres vecteurs doivent avoir la meme structure.
+  const TRUSTVect<_TYPE_,_SIZE_>& master_vect = vx;
+  const int line_size = master_vect.line_size();
+  const _SIZE_ vect_size_tot = master_vect.size_totale();
+  const MD_Vector& md = master_vect.get_md_vector();
+  assert(vx.line_size() == line_size && vy.line_size() == line_size);
+  assert(vx.size_totale() == vect_size_tot && vy.size_totale() == vect_size_tot); // this test is necessary if md is null
+#ifndef LATATOOLS
+  assert(vx.get_md_vector() == md && vy.get_md_vector() == md);
+#endif
+  // Determine blocs of data to process, depending on " opt"
+  int nblocs_left;
+  Block_Iter<_SIZE_> bloc_itr  = ::determine_blocks(opt, md, vect_size_tot, line_size, nblocs_left);
+  // Shortcut for empty arrays (avoid case line_size == 0)
+  if (bloc_itr.empty()) return sum;
+
+  bool kernelOnDevice = const_cast<TRUSTVect<_TYPE_,_SIZE_>&>(vx).checkDataOnDevice(vy);
+  const _TYPE_ *vx_ptr = mapToDevice(vx, "", kernelOnDevice);
+  const _TYPE_ *vy_ptr = mapToDevice(vy, "", kernelOnDevice);
+  if (timer) start_gpu_timer(__KERNEL_NAME__);
+  for (; nblocs_left; nblocs_left--)
+    {
+      // Get index of next bloc start:
+      const _SIZE_ begin_bloc = (*(bloc_itr++)) * line_size, end_bloc = (*(bloc_itr++)) * line_size;
+      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
+      // ToDo OpenMP bug nvc++ compiler recent bouh: https://forums.developer.nvidia.com/t/openmp-nvc-duplicate-name-in-reduction-clause-error-with-recent-sdk/255696/3
+      if (kernelOnDevice)
+        #pragma omp target teams distribute parallel for reduction(+:sum)
+        for (_SIZE_ i=begin_bloc; i<end_bloc; i++)
+          sum += vx_ptr[i] * vy_ptr[i];
+      else
+        for (_SIZE_ i=begin_bloc; i<end_bloc; i++)
+          sum += vx_ptr[i] * vy_ptr[i];
+    }
+  if (timer) end_gpu_timer(kernelOnDevice, __KERNEL_NAME__);
+  return sum;
+}
+// Explicit instanciation for templates:
+template double local_prodscal(const TRUSTVect<double, int>& vx, const TRUSTVect<double, int>& vy, Mp_vect_options opt);
+template float local_prodscal(const TRUSTVect<float, int>& vx, const TRUSTVect<float, int>& vy, Mp_vect_options opt);
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUSTVect_tools.tpp b/Utilities/VisItBridge/databases/readers/Lata/TRUSTVect_tools.tpp
new file mode 100644
index 00000000..e13d3697
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUSTVect_tools.tpp
@@ -0,0 +1,591 @@
+/****************************************************************************
+* Copyright (c) 2025, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef TRUSTVect_tools_TPP_included
+#define TRUSTVect_tools_TPP_included
+
+#ifdef MICROSOFT
+#define HUGE_VALL 1e99
+#endif
+
+/*! Small iterator class to scan blocks of a MD vector (blocks described by integer indices) or scan a single big block (trustIdType).
+ * The important point: the operator*() always returns a trustIdType (TID), whether internal data is int* or trustIdType* :
+ *   - in sequential, we can scan a whole Big array from start to end,
+ *   - in parallel, we can scan chunks of the arrays, as defined by MD_Vector_mono::blocs_items_to_compute_ (which store int values, never long)
+ */
+template<typename _SIZE_>
+struct Block_Iter
+{
+  Block_Iter() = default;
+  Block_Iter(const Block_Iter& other) = default;  // default copy ctor, will copy all members
+  Block_Iter& operator=(const Block_Iter& other) = default; // default copy operator
+  Block_Iter(const int * p) : int_ptr(p) {}
+  Block_Iter(_SIZE_ s, _SIZE_ e) : start(s), end(e) {}
+
+  _SIZE_ operator*() const
+  {
+    return start == -1 ? (_SIZE_)*int_ptr : start;  // potentially casting!
+  }
+  Block_Iter operator++(True_int)   // Postfix operator
+  {
+    Block_Iter ret = *this;
+    if(int_ptr) int_ptr++;
+    else std::swap(start, end);
+    return ret;
+  }
+  bool empty() const { return int_ptr == nullptr && start == -1; }
+
+  const int * int_ptr=nullptr;
+  _SIZE_ start=-1;
+  _SIZE_ end=-1;
+};
+
+template <typename _SIZE_>
+Block_Iter<_SIZE_> determine_blocks(Mp_vect_options opt, const MD_Vector& md, const _SIZE_ vect_size_tot, const int line_size, int& nblocs_left);
+
+/*! @brief renvoie 1 si meme strucuture parallele et egalite au sens TRUSTArray (y compris espaces virtuels) BM: faut-il etre aussi strict, comparer uniquement size() elements ?
+ *
+ */
+template<typename _TYPE_, typename _SIZE_>
+inline int operator==(const TRUSTVect<_TYPE_,_SIZE_>& x, const TRUSTVect<_TYPE_,_SIZE_>& y)
+{
+  x.ensureDataOnHost();
+  y.ensureDataOnHost();
+  if (!(x.get_md_vector() == y.get_md_vector())) return 0;
+  const TRUSTArray<_TYPE_,_SIZE_>& ax = x;
+  const TRUSTArray<_TYPE_,_SIZE_>& ay = y;
+  return ax == ay;
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline int operator!=(const TRUSTVect<_TYPE_,_SIZE_>& x, const TRUSTVect<_TYPE_,_SIZE_>& y)
+{
+  return !(x == y);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+extern void invalidate_data(TRUSTVect<_TYPE_,_SIZE_>& resu, Mp_vect_options opt);
+
+// ==================================================================================================================================
+// DEBUT code pour operation min/max/abs
+enum class TYPE_OPERATION_VECT { IMAX_ , IMIN_ , MAX_ , MIN_ , MAX_ABS_ , MIN_ABS_ };
+
+
+inline double neutral_value_double_(const bool IS_MAX)
+{
+  return IS_MAX ? (-HUGE_VAL) : HUGE_VAL;
+}
+
+inline float neutral_value_float_(const bool IS_MAX)
+{
+  return IS_MAX ? (-HUGE_VALF) : HUGE_VALF; // et ouiiiiiiiiiiiiiiii
+}
+
+inline int neutral_value_int_(const bool IS_MAX)
+{
+  return IS_MAX ? INT_MIN : INT_MAX;
+}
+
+template <typename _TYPE_, TYPE_OPERATION_VECT _TYPE_OP_ >
+inline _TYPE_ neutral_value()
+{
+  static constexpr bool IS_MAX = ((_TYPE_OP_ == TYPE_OPERATION_VECT::IMAX_) || (_TYPE_OP_ == TYPE_OPERATION_VECT::MAX_)), IS_MAX_ABS = (_TYPE_OP_ == TYPE_OPERATION_VECT::MAX_ABS_);
+  if (IS_MAX_ABS)
+    return 0;
+  else
+    {
+      _TYPE_ neutral_val;
+
+      if (std::is_same<_TYPE_, double>::value) neutral_val = (_TYPE_) neutral_value_double_(IS_MAX);
+      else if (std::is_same<_TYPE_, float>::value) neutral_val = (_TYPE_) neutral_value_float_(IS_MAX);
+      else neutral_val = (_TYPE_) neutral_value_int_(IS_MAX);
+
+      return neutral_val;
+    }
+}
+
+template <typename _TYPE_, typename _SIZE_, typename _TYPE_RETURN_, TYPE_OPERATION_VECT _TYPE_OP_ >
+extern _TYPE_RETURN_ local_extrema_vect_generic(const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt);
+
+template<typename _TYPE_, typename _SIZE_>
+inline int local_imax_vect(const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt=VECT_REAL_ITEMS)
+{
+  return local_extrema_vect_generic<_TYPE_,_SIZE_,int,TYPE_OPERATION_VECT::IMAX_>(vx,opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline int local_imin_vect(const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt=VECT_REAL_ITEMS)
+{
+  return local_extrema_vect_generic<_TYPE_,_SIZE_,int,TYPE_OPERATION_VECT::IMIN_>(vx,opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ local_max_vect_(const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt=VECT_REAL_ITEMS)
+{
+  return local_max_vect(vx,opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ local_max_vect(const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt=VECT_REAL_ITEMS)
+{
+  return local_extrema_vect_generic<_TYPE_,_SIZE_,_TYPE_ /* return type */,TYPE_OPERATION_VECT::MAX_>(vx,opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ local_min_vect_(const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt=VECT_REAL_ITEMS)
+{
+  return local_min_vect(vx,opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ local_min_vect(const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt=VECT_REAL_ITEMS)
+{
+  return local_extrema_vect_generic<_TYPE_,_SIZE_,_TYPE_ /* return type */,TYPE_OPERATION_VECT::MIN_>(vx, opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ mp_max_vect_(const TRUSTVect<_TYPE_,_SIZE_>& x, Mp_vect_options opt=VECT_REAL_ITEMS)
+{
+  return mp_max_vect(x, opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ mp_max_vect(const TRUSTVect<_TYPE_,_SIZE_>& x, Mp_vect_options opt=VECT_REAL_ITEMS)
+{
+  _TYPE_ s = local_max_vect(x, opt);
+  s = Process::mp_max(s);
+  return s;
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ mp_min_vect_(const TRUSTVect<_TYPE_,_SIZE_>& x, Mp_vect_options opt=VECT_REAL_ITEMS)
+{
+  return mp_min_vect(x, opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ mp_min_vect(const TRUSTVect<_TYPE_,_SIZE_>& x, Mp_vect_options opt=VECT_REAL_ITEMS)
+{
+  _TYPE_ s = local_min_vect(x, opt);
+  s = Process::mp_min(s);
+  return s;
+}
+
+template<typename _SIZE_>
+inline trustIdType mp_somme_vect(const TRUSTVect<trustIdType,_SIZE_>& vx)
+{
+  trustIdType x = local_somme_vect(vx);
+  trustIdType y = Process::mp_sum(x);
+  return y;
+}
+
+template<typename _SIZE_>
+inline double mp_somme_vect_as_double(const TRUSTVect<trustIdType,_SIZE_>& vx)
+{
+  return static_cast<double>(mp_somme_vect(vx));
+}
+
+#if INT_is_64_ == 2
+template<typename _SIZE_>
+inline trustIdType mp_somme_vect(const TRUSTVect<int,_SIZE_>& vx)
+{
+  int x = local_somme_vect(vx);
+  trustIdType y = Process::mp_sum(x);
+  return y;
+}
+
+template<typename _SIZE_>
+inline double mp_somme_vect_as_double(const TRUSTVect<int,_SIZE_>& vx)
+{
+  return static_cast<double>(mp_somme_vect(vx));
+}
+
+#endif
+
+template<typename _SIZE_>
+inline float mp_somme_vect(const TRUSTVect<float,_SIZE_>& vx)
+{
+  float x = local_somme_vect(vx);
+  float y = Process::mp_sum(x);
+  return y;
+}
+
+template<typename _SIZE_>
+inline double mp_somme_vect(const TRUSTVect<double,_SIZE_>& vx)
+{
+  double x = local_somme_vect(vx);
+  double y = Process::mp_sum(x);
+  return y;
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ local_max_abs_vect_(const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt=VECT_REAL_ITEMS)
+{
+  return local_max_abs_vect(vx,opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ local_max_abs_vect(const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt=VECT_REAL_ITEMS)
+{
+  return local_extrema_vect_generic<_TYPE_,_SIZE_,_TYPE_ /* return type */,TYPE_OPERATION_VECT::MAX_ABS_>(vx, opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ local_min_abs_vect_(const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt=VECT_REAL_ITEMS)
+{
+  return local_min_abs_vect(vx,opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ local_min_abs_vect(const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt=VECT_REAL_ITEMS)
+{
+  return local_extrema_vect_generic<_TYPE_,_SIZE_,_TYPE_ /* return type */,TYPE_OPERATION_VECT::MIN_ABS_>(vx, opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ mp_max_abs_vect_(const TRUSTVect<_TYPE_,_SIZE_>& x, Mp_vect_options opt=VECT_REAL_ITEMS)
+{
+  return mp_max_abs_vect(x, opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ mp_max_abs_vect(const TRUSTVect<_TYPE_,_SIZE_>& x, Mp_vect_options opt=VECT_REAL_ITEMS)
+{
+  _TYPE_ s = local_max_abs_vect(x, opt);
+  s = Process::mp_max(s);
+  return s;
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ mp_min_abs_vect_(const TRUSTVect<_TYPE_,_SIZE_>& x, Mp_vect_options opt=VECT_REAL_ITEMS)
+{
+  return mp_min_abs_vect(x, opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ mp_min_abs_vect(const TRUSTVect<_TYPE_,_SIZE_>& x, Mp_vect_options opt=VECT_REAL_ITEMS)
+{
+  _TYPE_ s = local_min_abs_vect(x, opt);
+  s = Process::mp_min(s);
+  return s;
+}
+
+template<typename _TYPE_, typename _SIZE_>
+extern _TYPE_ local_prodscal(const TRUSTVect<_TYPE_,_SIZE_>& vx, const TRUSTVect<_TYPE_,_SIZE_>& vy, Mp_vect_options opt=VECT_SEQUENTIAL_ITEMS);
+
+enum class TYPE_OPERATION_VECT_BIS { CARRE_ , SOMME_ };
+
+template <typename _TYPE_, typename _SIZE_, TYPE_OPERATION_VECT_BIS _TYPE_OP_ >
+extern _TYPE_ local_operations_vect_bis_generic(const TRUSTVect<_TYPE_,_SIZE_>& vx,Mp_vect_options opt);
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ local_carre_norme_vect(const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt=VECT_SEQUENTIAL_ITEMS)
+{
+  return local_operations_vect_bis_generic<_TYPE_,_SIZE_,TYPE_OPERATION_VECT_BIS::CARRE_>(vx,opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ mp_carre_norme_vect(const TRUSTVect<_TYPE_,_SIZE_>& vx)
+{
+  return Process::mp_sum(local_carre_norme_vect(vx));
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ local_somme_vect(const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt=VECT_SEQUENTIAL_ITEMS)
+{
+  return local_operations_vect_bis_generic<_TYPE_,_SIZE_,TYPE_OPERATION_VECT_BIS::SOMME_>(vx,opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ mp_prodscal(const TRUSTVect<_TYPE_,_SIZE_>& x, const TRUSTVect<_TYPE_,_SIZE_>& y)
+{
+  return Process::mp_sum(local_prodscal(x, y));
+}
+
+template <typename _SIZE_>
+inline int mp_norme_vect(const TRUSTVect<int, _SIZE_>& vx) = delete; // forbidden
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ mp_norme_vect(const TRUSTVect<_TYPE_,_SIZE_>& vx)
+{
+  _TYPE_ x = mp_carre_norme_vect(vx);
+  x = sqrt(x);
+  return x;
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ mp_norme_vect_(const TRUSTVect<_TYPE_,_SIZE_>& vx)
+{
+  return mp_norme_vect(vx);
+}
+
+template <typename _SIZE_>
+inline int mp_moyenne_vect(const TRUSTVect<int, _SIZE_>& x) = delete; // forbidden
+
+template<typename _TYPE_, typename _SIZE_>
+inline _TYPE_ mp_moyenne_vect(const TRUSTVect<_TYPE_,_SIZE_>& x)
+{
+#ifndef LATATOOLS
+  _TYPE_ s = mp_somme_vect(x);
+  trustIdType n;
+  const MD_Vector& md = x.get_md_vector();
+  if (md.non_nul()) n = md->nb_items_seq_tot() * x.line_size();
+  else
+    {
+      assert(Process::is_sequential()); // Coding error: mp_moyenne_vect is used on a not distributed TRUSTVect<double> !
+      n = x.size_totale();
+    }
+  return s / (_TYPE_)n;
+#else
+  return (_TYPE_) 0;
+#endif
+}
+// FIN code pour operation min/max/abs
+// ==================================================================================================================================
+
+// ==================================================================================================================================
+// DEBUT code pour operateurs vect/vect ou vect/scalair
+enum class TYPE_OPERATOR_VECT { ADD_ , SUB_ , MULT_ , DIV_ , EGAL_ };
+
+inline void error_divide(const char * nom_funct)
+{
+  Cerr << "What ??? Divide by 0 in " << nom_funct << " operator_divide() !!" << finl;
+  throw;
+}
+
+template <typename _TYPE_, typename _SIZE_, TYPE_OPERATOR_VECT _TYPE_OP_ >
+extern void operator_vect_vect_generic(TRUSTVect<_TYPE_,_SIZE_>& resu, const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt);
+
+template<typename _TYPE_, typename _SIZE_>
+inline void operator_add(TRUSTVect<_TYPE_,_SIZE_>& resu, const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt=VECT_ALL_ITEMS)
+{
+  operator_vect_vect_generic<_TYPE_,_SIZE_,TYPE_OPERATOR_VECT::ADD_>(resu,vx,opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void operator_sub(TRUSTVect<_TYPE_,_SIZE_>& resu, const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt=VECT_ALL_ITEMS)
+{
+  operator_vect_vect_generic<_TYPE_,_SIZE_,TYPE_OPERATOR_VECT::SUB_>(resu,vx,opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void operator_multiply(TRUSTVect<_TYPE_,_SIZE_>& resu, const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt=VECT_ALL_ITEMS)
+{
+  operator_vect_vect_generic<_TYPE_,_SIZE_,TYPE_OPERATOR_VECT::MULT_>(resu,vx,opt);
+}
+
+template<typename _SIZE_>
+inline void operator_divide(TRUSTVect<int, _SIZE_>& resu, const TRUSTVect<int, _SIZE_>& vx, Mp_vect_options opt=VECT_ALL_ITEMS) = delete; // forbidden
+
+template<typename _TYPE_, typename _SIZE_>
+inline void operator_divide(TRUSTVect<_TYPE_,_SIZE_>& resu, const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt=VECT_ALL_ITEMS)
+{
+  operator_vect_vect_generic<_TYPE_,_SIZE_,TYPE_OPERATOR_VECT::DIV_>(resu,vx,opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void operator_egal(TRUSTVect<_TYPE_,_SIZE_>& resu, const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt=VECT_ALL_ITEMS)
+{
+  operator_vect_vect_generic<_TYPE_,_SIZE_,TYPE_OPERATOR_VECT::EGAL_>(resu,vx,opt);
+}
+
+enum class TYPE_OPERATOR_SINGLE { ADD_ , SUB_ , MULT_ , DIV_ , EGAL_ , NEGATE_ , INV_ , ABS_ , RACINE_CARRE_ , CARRE_ };
+
+template <typename _TYPE_, typename _SIZE_, TYPE_OPERATOR_SINGLE _TYPE_OP_ >
+extern void operator_vect_single_generic(TRUSTVect<_TYPE_,_SIZE_>& resu, const _TYPE_ x, Mp_vect_options opt);
+
+template<typename _TYPE_, typename _SIZE_>
+inline void operator_add(TRUSTVect<_TYPE_,_SIZE_>& resu, const _TYPE_ x, Mp_vect_options opt=VECT_ALL_ITEMS)
+{
+  operator_vect_single_generic<_TYPE_,_SIZE_,TYPE_OPERATOR_SINGLE::ADD_>(resu,x,opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void operator_sub(TRUSTVect<_TYPE_,_SIZE_>& resu, const _TYPE_ x, Mp_vect_options opt=VECT_ALL_ITEMS)
+{
+  operator_vect_single_generic<_TYPE_,_SIZE_,TYPE_OPERATOR_SINGLE::SUB_>(resu,x,opt);
+}
+
+// ATTENTION : on utilise is_convertible sinon soucis quand TYPE = double et x = int ... ex : operator_multiply(TRUSTVect<double>, 1) ...
+template<typename _TYPE_, typename _SIZE_, typename _SCALAR_TYPE_>
+typename std::enable_if<std::is_convertible<_SCALAR_TYPE_, _TYPE_>::value >::type
+inline operator_multiply(TRUSTVect<_TYPE_,_SIZE_>& resu, const _SCALAR_TYPE_ x, Mp_vect_options opt=VECT_ALL_ITEMS)
+{
+  operator_vect_single_generic<_TYPE_,_SIZE_,TYPE_OPERATOR_SINGLE::MULT_>(resu,x,opt);
+}
+
+template<typename _SIZE_>
+inline void operator_divide(TRUSTVect<int,_SIZE_>& resu, const int x, Mp_vect_options opt=VECT_ALL_ITEMS) = delete; // forbidden (avant c'etait possible ... a voir si besoin)
+
+template<typename _TYPE_, typename _SIZE_>
+inline void operator_divide(TRUSTVect<_TYPE_,_SIZE_>& resu, const _TYPE_ x, Mp_vect_options opt=VECT_ALL_ITEMS)
+{
+  operator_vect_single_generic<_TYPE_,_SIZE_,TYPE_OPERATOR_SINGLE::DIV_>(resu,x,opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void operator_egal(TRUSTVect<_TYPE_,_SIZE_>& resu, _TYPE_ x, Mp_vect_options opt=VECT_ALL_ITEMS)
+{
+  operator_vect_single_generic<_TYPE_,_SIZE_,TYPE_OPERATOR_SINGLE::EGAL_>(resu,x,opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void operator_negate(TRUSTVect<_TYPE_,_SIZE_>& resu, Mp_vect_options opt=VECT_ALL_ITEMS)
+{
+  operator_vect_single_generic<_TYPE_,_SIZE_,TYPE_OPERATOR_SINGLE::NEGATE_>(resu,(_TYPE_)0 /* inutile */,opt);
+}
+
+template<typename _SIZE_>
+inline void operator_inverse(TRUSTVect<int,_SIZE_>& resu, Mp_vect_options opt=VECT_ALL_ITEMS) = delete; // forbidden
+
+template<typename _TYPE_, typename _SIZE_>
+inline void operator_inverse(TRUSTVect<_TYPE_,_SIZE_>& resu, Mp_vect_options opt=VECT_ALL_ITEMS)
+{
+  operator_vect_single_generic<_TYPE_,_SIZE_,TYPE_OPERATOR_SINGLE::INV_>(resu,0. /* inutile */,opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void operator_abs(TRUSTVect<_TYPE_,_SIZE_>& resu, Mp_vect_options opt=VECT_ALL_ITEMS)
+{
+  operator_vect_single_generic<_TYPE_,_SIZE_,TYPE_OPERATOR_SINGLE::ABS_>(resu,(_TYPE_)0 /* inutile */,opt);
+}
+
+template<typename _SIZE_>
+inline void racine_carree(TRUSTVect<int,_SIZE_>& resu, Mp_vect_options opt=VECT_ALL_ITEMS) = delete; // forbidden
+
+template<typename _TYPE_, typename _SIZE_>
+inline void racine_carree(TRUSTVect<_TYPE_,_SIZE_>& resu, Mp_vect_options opt=VECT_ALL_ITEMS)
+{
+  operator_vect_single_generic<_TYPE_,_SIZE_,TYPE_OPERATOR_SINGLE::RACINE_CARRE_>(resu,0. /* inutile */,opt);
+}
+
+template<typename _SIZE_>
+inline void racine_carree_(TRUSTVect<int,_SIZE_>& resu, Mp_vect_options opt=VECT_ALL_ITEMS) = delete; // forbidden
+
+template<typename _TYPE_, typename _SIZE_>
+inline void racine_carree_(TRUSTVect<_TYPE_,_SIZE_>& resu, Mp_vect_options opt=VECT_ALL_ITEMS)
+{
+  racine_carree(resu,opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void carre(TRUSTVect<_TYPE_,_SIZE_>& resu, Mp_vect_options opt=VECT_ALL_ITEMS)
+{
+  operator_vect_single_generic<_TYPE_,_SIZE_,TYPE_OPERATOR_SINGLE::CARRE_>(resu,0. /* inutile */,opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void carre_(TRUSTVect<_TYPE_,_SIZE_>& resu, Mp_vect_options opt)
+{
+  carre(resu,opt);
+}
+
+// FIN code pour operateurs vect/vect ou vect/scalair
+// ==================================================================================================================================
+
+// ==================================================================================================================================
+// DEBUT code pour operations speciales
+enum class TYPE_OPERATION_VECT_SPEC { ADD_ , CARRE_ };
+
+template <TYPE_OPERATION_VECT_SPEC _TYPE_OP_, typename _SIZE_>
+inline void ajoute_operation_speciale_generic(TRUSTVect<int,_SIZE_>& resu, int alpha, const TRUSTVect<int,_SIZE_>& vx, Mp_vect_options opt) = delete; // forbidden ... ajoute si besoin
+
+template <TYPE_OPERATION_VECT_SPEC _TYPE_OP_ ,typename _TYPE_, typename _SIZE_>
+extern void ajoute_operation_speciale_generic(TRUSTVect<_TYPE_,_SIZE_>& resu, _TYPE_ alpha, const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt);
+
+template<typename _TYPE_, typename _SIZE_>
+inline void ajoute_alpha_v(TRUSTVect<_TYPE_,_SIZE_>& resu, _TYPE_ alpha, const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt=VECT_REAL_ITEMS)
+{
+  ajoute_operation_speciale_generic<TYPE_OPERATION_VECT_SPEC::ADD_,_TYPE_>(resu,alpha,vx,opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+inline void ajoute_carre(TRUSTVect<_TYPE_,_SIZE_>& resu, _TYPE_ alpha, const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt=VECT_ALL_ITEMS)
+{
+  ajoute_operation_speciale_generic<TYPE_OPERATION_VECT_SPEC::CARRE_,_TYPE_>(resu,alpha,vx,opt);
+}
+
+template<typename _TYPE_, typename _SIZE_>
+extern void ajoute_produit_scalaire(TRUSTVect<_TYPE_,_SIZE_>& resu, _TYPE_ alpha, const TRUSTVect<_TYPE_,_SIZE_>& vx, const TRUSTVect<_TYPE_,_SIZE_>& vy, Mp_vect_options opt = VECT_ALL_ITEMS);
+
+enum class TYPE_OPERATION_VECT_SPEC_GENERIC { MUL_ , DIV_ };
+
+template <TYPE_OPERATION_VECT_SPEC_GENERIC _TYPE_OP_ , typename _TYPE_, typename _SIZE_>
+extern void operation_speciale_tres_generic(TRUSTVect<_TYPE_,_SIZE_>& resu, const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt);
+
+template <TYPE_OPERATION_VECT_SPEC_GENERIC _TYPE_OP_, typename _SIZE_>
+inline void operation_speciale_tres_generic(TRUSTVect<int,_SIZE_>& resu, const TRUSTVect<int,_SIZE_>& vx, Mp_vect_options opt) = delete; // forbidden !!
+
+template<typename _SIZE_>
+inline void tab_multiply_any_shape_(TRUSTVect<int,_SIZE_>& resu, const TRUSTVect<int,_SIZE_>& vx, Mp_vect_options opt) = delete; // forbidden
+
+template<typename _TYPE_, typename _SIZE_>
+inline void tab_multiply_any_shape_(TRUSTVect<_TYPE_,_SIZE_>& resu, const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt)
+{
+  operation_speciale_tres_generic<TYPE_OPERATION_VECT_SPEC_GENERIC::MUL_,_TYPE_>(resu,vx,opt);
+}
+
+template<typename _SIZE_>
+inline void tab_divide_any_shape_(TRUSTVect<int,_SIZE_>& resu, const TRUSTVect<int,_SIZE_>& vx, Mp_vect_options opt) = delete; // forbidden
+
+template<typename _TYPE_, typename _SIZE_>
+inline void tab_divide_any_shape_(TRUSTVect<_TYPE_,_SIZE_>& resu, const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt)
+{
+  operation_speciale_tres_generic<TYPE_OPERATION_VECT_SPEC_GENERIC::DIV_,_TYPE_>(resu,vx,opt);
+}
+
+// Cette methode permettent de multiplier un tableau a plusieurs dimensions par un tableau de dimension inferieure (par exemple un tableau a trois composantes par un tableau a une composante).
+//  Chaque valeur du tableau vx est utilisee pour plusieurs items consecutifs du tableau resu (le nombre de fois est le rapport des line_size() des deux tableaux).
+//  resu.line_size() doit etre un multiple int de vx.line_size() et les descripteurs doivent etre identiques.
+//  Cas particulier: vx peut contenir une constante unique (size_array() == 1 et descripteur nul), dans ce cas c'est un simple produit par la constante
+template<typename _TYPE_, typename _SIZE_>
+inline void tab_multiply_any_shape(TRUSTVect<_TYPE_,_SIZE_>& resu, const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt=VECT_ALL_ITEMS)
+{
+  if (vx.size_array() == 1 && !vx.get_md_vector().non_nul()) // Produit par une constante
+    {
+      const _TYPE_ x = vx[0];
+      operator_multiply(resu, x, opt);
+    }
+  else if (vx.line_size() == resu.line_size()) // Produit membre a membre
+    operator_multiply(resu, vx, opt);
+  else // Cas general
+    tab_multiply_any_shape_(resu, vx, opt);
+}
+
+template<typename _SIZE_>
+inline void tab_multiply_any_shape(TRUSTVect<int,_SIZE_>& resu, const TRUSTVect<int,_SIZE_>& vx, Mp_vect_options opt=VECT_ALL_ITEMS) = delete; // forbidden
+
+// Idem que tab_multiply_any_shape() mais avec une division
+template<typename _TYPE_, typename _SIZE_>
+inline void tab_divide_any_shape(TRUSTVect<_TYPE_,_SIZE_>& resu, const TRUSTVect<_TYPE_,_SIZE_>& vx, Mp_vect_options opt=VECT_ALL_ITEMS)
+{
+  if (vx.size_array() == 1 && !vx.get_md_vector().non_nul()) // division par une constante
+    {
+      if (vx[0] == 0) error_divide(__func__);
+      const _TYPE_ x = 1. / vx[0];
+      operator_multiply(resu, x, opt);
+    }
+  else if (vx.line_size() == resu.line_size()) // division membre a membre
+    operator_divide(resu, vx, opt);
+  else // Cas general
+    tab_divide_any_shape_(resu, vx, opt);
+}
+
+template<typename _SIZE_>
+inline void tab_divide_any_shape(TRUSTVect<int,_SIZE_>& resu, const TRUSTVect<int,_SIZE_>& vx, Mp_vect_options opt=VECT_ALL_ITEMS) = delete; // forbidden
+// FIN code pour operations speciales
+// ==================================================================================================================================
+
+#endif /* TRUSTVect_tools_TPP_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUST_Deriv.h b/Utilities/VisItBridge/databases/readers/Lata/TRUST_Deriv.h
new file mode 100644
index 00000000..4127cffe
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUST_Deriv.h
@@ -0,0 +1,267 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef TRUST_Deriv_included
+#define TRUST_Deriv_included
+
+#include <Objet_U_ptr.h>
+#include <Nom.h>
+
+/*! @brief classe TRUST_Deriv
+ *
+ *   Soit une classe Type_base qui derive de Objet_U.
+ *
+ *   TRUST_Deriv<Type_base> est une petite classe template contenant un pointeur vers une instance de Type_base,
+ *   ou de n'importe quelle classe derivee de Type_base qui est creee dynamiquement lors a l'execution.
+ *
+ *   Definition de la DERIV:
+ *
+ *   #include <TRUST_Deriv.h>
+ *   #include <Type_base.h>
+ *   TRUST_Deriv<Type_base>
+ *
+ *   Creation d'un objet de type OWN_PTR(Type_base) :
+ *    OWN_PTR(Type_base) deriv_type; // deriv_type est encore un pointeur nul
+ *
+ *   On suppose que la classe Type_Derive derive de Type_base et est instanciable:
+ *    class Type_Derive : Type_base
+ *    {
+ *        Declare_instanciable(Type_Derive);;
+ *      ...
+ *    };
+ *
+ *   Creation d'une instance de la classe Type_Derive qui derive de Type_base:
+ *    deriv_type.typer("Type_Derive");
+ *
+ *   Acces a l'instance de Type_Derive:
+ *    Type_Derive & objet_derive = deriv_type.valeur();
+ *    const Type_Derive & objet_derive = deriv_type.valeur();
+ *
+ *   L'instance de Type_Derive est detruite si on appelle a nouveau "typer()"
+ *   ou si l'objet deriv_type est detruit.
+ *
+ */
+
+// MACRO to replace OWN_PTR(THECLASS) by Deriv_THECLASS & keep previous syntax for some developers
+#define DERIV(_TYPE_) \
+  static_assert(false, "The old DERIV MACRO is now deprecated. Please use OWN_PTR instead.")
+
+#define OWN_PTR(_TYPE_) TRUST_Deriv<_TYPE_>
+
+template<typename _CLASSE_>
+class TRUST_Deriv: public Objet_U_ptr
+{
+protected:
+  unsigned taille_memoire() const override { throw; }
+
+  int duplique() const override
+  {
+    TRUST_Deriv *xxx = new TRUST_Deriv(*this);
+#ifndef LATATOOLS
+    if (!xxx) Process::exit("Not enough memory !");
+#endif
+    return xxx->numero();
+  }
+
+  Sortie& printOn(Sortie& os) const override { return Objet_U_ptr::printOn(os); }
+
+  Entree& readOn(Entree& is) override { return Objet_U_ptr::readOn(is); }
+
+  void set_Objet_U_ptr(Objet_U *objet) override
+  {
+    Objet_U_ptr::set_Objet_U_ptr(objet);
+    /* Attention: cette conversion de type est non triviale. si le _TYPE_ est issu d'un heritage multiple. */
+    if (objet) pointeur_ = (_CLASSE_*) objet;
+    else pointeur_ = nullptr;
+  }
+
+private:
+  _CLASSE_ *pointeur_ = nullptr;
+
+  /* XXX Elie Saikali : interdit de l'appeler ! */
+  void nommer(const Nom&) override { /* NON PAS POSSIBLE */ }
+  int reprendre(Entree&) override { return -100; /* NON PAS POSSIBLE */ }
+  int sauvegarder(Sortie&) const override { return -100; /* NON PAS POSSIBLE */ }
+
+public:
+  ~TRUST_Deriv() { detach(); }
+  TRUST_Deriv() :  Objet_U_ptr(), pointeur_(nullptr) { }
+  TRUST_Deriv(const TRUST_Deriv& t) : TRUST_Deriv()
+  {
+    if (t.non_nul()) recopie(t.valeur());
+  }
+
+  TRUST_Deriv(const _CLASSE_& t) : TRUST_Deriv()
+  {
+    recopie(t);
+  }
+
+  inline const _CLASSE_& valeur() const
+  {
+    assert(pointeur_ != nullptr);
+#ifndef _OPENMP_TARGET
+    assert(get_Objet_U_ptr_check() || 1);
+#endif
+    return *pointeur_;
+  }
+
+  inline _CLASSE_& valeur()
+  {
+    assert(pointeur_ != nullptr);
+#ifndef _OPENMP_TARGET
+    assert(get_Objet_U_ptr_check() || 1);
+#endif
+    return *pointeur_;
+  }
+
+  inline const _CLASSE_* operator ->() const
+  {
+    assert(pointeur_ != nullptr);
+    assert(get_Objet_U_ptr_check() || 1);
+    return pointeur_;
+  }
+
+  inline _CLASSE_* operator ->()
+  {
+    assert(pointeur_ != nullptr);
+    assert(get_Objet_U_ptr_check() || 1);
+    return pointeur_;
+  }
+
+  const TRUST_Deriv& operator=(const _CLASSE_& t)
+  {
+    if (pointeur_ != (&t))
+      {
+        detach();
+        recopie(t);
+      }
+    return *this;
+  }
+
+  const TRUST_Deriv& operator=(const TRUST_Deriv& t)
+  {
+    if (pointeur_ != t.pointeur_)
+      {
+        detach();
+        if (t.non_nul()) recopie(t.valeur());
+      }
+    return *this;
+  }
+
+  operator const _CLASSE_& () const { return valeur(); }
+  operator _CLASSE_& () { return valeur(); }
+
+  const Type_info& get_info_ptr() const override
+  {
+    const Type_info * type_info = _CLASSE_::info();
+    return *type_info; /* type de base accepte par la ref */
+  }
+
+  Entree& typer_lire_simple(Entree& is, const char* msg = "??")
+  {
+    return typer_lire(is, "??", msg);
+  }
+
+  Entree& typer_lire(Entree& is, const char* b = "??", const char* msg = "??")
+  {
+    Nom type, base;
+
+    if (strcmp(msg, "??") != 0)
+      Cerr << msg << " ";
+
+    if (strcmp(b, "??") != 0)
+      base = b;
+
+    is >> type; // On lit le type :-)
+
+    if (base != "??")
+      type = base + type;
+
+    typer(type); // on type :-)
+
+    if (strcmp(msg, "??") != 0)
+      Cerr << valeur().que_suis_je() << finl;
+
+    is >> valeur(); // et on lit la classe :-)
+
+    return is;
+  }
+};
+
+/* ======================================================= *
+ * ======================================================= *
+ * ======================================================= */
+
+/*! @brief classe TRUST_Deriv_Objet_U est quasiment identique a TRUST_Deriv<Objet_U>
+ *  sauf qu'elle ne contient pas les operateurs de conversion de OWN_PTR(Objet_U) en Objet_U.
+ *
+ *  Il existe 3 methodes supplementaires :
+ *
+ *   - deplace(TRUST_Deriv_Objet_U& )
+ *   - reprendre
+ *   - sauvegarder
+ *
+ *   Utilisation :
+ *   - TRUST_Deriv_Objet_U
+ *   ou
+ *   - DerObjU
+ */
+class TRUST_Deriv_Objet_U: public Objet_U_ptr
+{
+  Declare_instanciable_sans_constructeur(TRUST_Deriv_Objet_U);
+protected:
+  void set_Objet_U_ptr(Objet_U *objet) override;
+
+private:
+  Objet_U *pointeur_;
+
+public:
+  TRUST_Deriv_Objet_U();
+  TRUST_Deriv_Objet_U(const TRUST_Deriv_Objet_U& t);
+  TRUST_Deriv_Objet_U(const Objet_U& t);
+  const Type_info& get_info_ptr() const override;
+  const TRUST_Deriv_Objet_U& operator=(const Objet_U& t);
+  const TRUST_Deriv_Objet_U& operator=(const TRUST_Deriv_Objet_U& t);
+#ifndef LATATOOLS
+  int reprendre(Entree& is) override;
+  int sauvegarder(Sortie& os) const override;
+#endif
+  void deplace(TRUST_Deriv_Objet_U& deriv_obj);
+
+  inline const Objet_U& valeur() const
+  {
+    assert(pointeur_ != nullptr);
+    assert(get_Objet_U_ptr_check() || 1);
+    return *pointeur_;
+  }
+
+  inline Objet_U& valeur()
+  {
+    assert(pointeur_ != nullptr);
+    assert(get_Objet_U_ptr_check() || 1);
+    return *pointeur_;
+  }
+
+  inline Objet_U* operator ->() const
+  {
+    assert(pointeur_ != nullptr);
+    assert(get_Objet_U_ptr_check() || 1);
+    return pointeur_;
+  }
+};
+
+using DerObjU = TRUST_Deriv_Objet_U;
+
+#endif /* TRUST_Deriv_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUST_Ref.h b/Utilities/VisItBridge/databases/readers/Lata/TRUST_Ref.h
new file mode 100644
index 00000000..f3d54a9d
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUST_Ref.h
@@ -0,0 +1,143 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef TRUST_Ref_included
+#define TRUST_Ref_included
+
+#include <type_traits>
+#include <assert.h>
+
+class Objet_U;
+class Nom;
+
+/*! @brief Soit une classe _CLASSE_ qui derive de Objet_U.
+ *
+ *   TRUST_Ref<_CLASSE_> est une petite classe template contenant un pointeur vers une instance de _CLASSE_.
+ *
+ *   Definition de la REF:
+ *
+ *   #include <TRUST_Ref.h>
+ *   #include <_CLASSE_.h>
+ *
+ *   Creation d'un objet de type OBS_PTR(_CLASSE_) :
+ *
+ *    OBS_PTR(_CLASSE_) la_ref_;
+ *
+ *    ou bien
+ *
+ *    TRUST_Ref<_CLASSE_>
+ *
+ */
+
+// MACRO to replace OBS_PTR(_TYPE_) by TRUST_Ref<_TYPE_*> & keep previous syntax for some developers
+#define REF(_TYPE_) \
+  static_assert(false, "The old REF MACRO is now deprecated. Please use OBS_PTR instead.")
+
+#define OBS_PTR(_TYPE_) TRUST_Ref<_TYPE_*>
+
+template<typename _CLASSE_>
+class TRUST_Ref final
+{
+  /*
+   * Elie & Adrien :
+   * Define the underlying (non-pointer) type
+   * For example if _CLASSE_ = 'Probleme_base*', value_type is 'Probleme_base' : https://en.cppreference.com/w/cpp/types/remove_pointer
+   */
+  using value_type = typename std::remove_pointer<_CLASSE_>::type;
+
+private:
+  value_type * p_ = nullptr;
+
+public:
+  static constexpr bool HAS_POINTER = true;
+
+  ~TRUST_Ref() = default;
+  TRUST_Ref() = default;
+  TRUST_Ref(const value_type& t) :  p_((value_type*)&t) { }
+  TRUST_Ref(const TRUST_Ref& t) : p_(t.p_) { }
+
+  const TRUST_Ref& operator=(const value_type& t)
+  {
+    p_ = const_cast<value_type *>(&t);
+    return *this;
+  }
+
+  const TRUST_Ref& operator=(const TRUST_Ref& t)
+  {
+    p_ = t.p_;
+    return *this;
+  }
+
+  // pas delete car soucis dans les iterateurs de TRUST_List par exemple (LIST(REF ....)
+  operator const value_type& () const { return valeur(); }
+  operator value_type& () { return valeur(); }
+
+  inline const value_type& valeur() const { assert(p_ != nullptr); return *p_; }
+  inline value_type& valeur() { assert(p_ != nullptr); return *p_; }
+  inline const value_type* operator ->() const { assert(p_ != nullptr); return p_; }
+  inline value_type* operator ->() { assert(p_ != nullptr); return p_; }
+  bool non_nul() const { return p_ != nullptr; }
+  bool est_nul() const { return p_ == nullptr; }
+  const Nom& le_nom() const = delete;
+  void reset() {  p_ = nullptr; }
+};
+
+// Le resultat de == est positif si r1 et r2 pointent sur le meme objet (meme cle), ou si les deux references sont nulles
+template<typename _CLASSE_>
+inline int operator ==(const TRUST_Ref<_CLASSE_>& r1, const TRUST_Ref<_CLASSE_>& r2)
+{
+  if (r1.est_nul() && r2.est_nul()) return 1;
+  if (r1->numero() == r2->numero()) return 1;
+  return 0;
+}
+
+/* ======================================================= *
+ * ======================================================= *
+ * ======================================================= */
+
+/*! @brief classe TRUST_Ref_Objet_U
+ *
+ * Cette classe est quasiment identique a TRUST_Ref<>,  sauf qu'elle ne contient pas les operateurs de conversion implicite
+ *
+ */
+class TRUST_Ref_Objet_U
+{
+private:
+  Objet_U * p_ = nullptr;
+
+public:
+  static constexpr bool HAS_POINTER = true;
+
+  ~TRUST_Ref_Objet_U();
+  TRUST_Ref_Objet_U();
+  TRUST_Ref_Objet_U(const Objet_U& t);
+  TRUST_Ref_Objet_U(const TRUST_Ref_Objet_U& t);
+
+  const TRUST_Ref_Objet_U& operator=(const Objet_U& t);
+  const TRUST_Ref_Objet_U& operator=(const TRUST_Ref_Objet_U& t);
+  bool non_nul() const;
+  bool est_nul() const;
+
+  inline const Objet_U& valeur() const { assert(p_ != nullptr); return *p_; }
+  inline Objet_U& valeur() { assert(p_ != nullptr); return *p_; }
+  inline const Objet_U* operator ->() const { assert(p_ != nullptr); return p_; }
+  inline Objet_U* operator ->() { assert(p_ != nullptr); return p_; }
+};
+
+int operator ==(const TRUST_Ref_Objet_U& r1, const TRUST_Ref_Objet_U& r2);
+
+using RefObjU = TRUST_Ref_Objet_U;
+
+#endif /* TRUST_Ref_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TRUST_Vector.h b/Utilities/VisItBridge/databases/readers/Lata/TRUST_Vector.h
new file mode 100644
index 00000000..f383292f
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TRUST_Vector.h
@@ -0,0 +1,241 @@
+/****************************************************************************
+* Copyright (c) 2023, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef TRUST_Vector_included
+#define TRUST_Vector_included
+
+#include <type_traits>
+#include <algorithm> // pour std::transform
+#include <vector>
+#include <memory> // pour std::shared_ptr
+#include <Nom.h>
+#include <Separateur.h>
+
+class MD_Vector;
+
+// MACRO to replace VECT(THECLASS) by TRUST_Vector<THECLASS> & keep previous syntax for some developers
+#define VECT(_TYPE_) TRUST_Vector<_TYPE_>
+
+/*! @brief classe TRUST_Vector
+ *
+ *  - La classe template TRUST_Vector est utilisable pour n'importe quelle classe
+ *
+ *      Utilisation (par exemple):
+ *
+ *        - TRUST_Vector<MD_Vector>
+ *        - TRUST_Vector<Milieu_base>
+ *        - TRUST_Vector<TRUSTArray<double>>
+ */
+template<typename _CLASSE_>
+class TRUST_Vector: public Objet_U
+{
+  using value_type = _CLASSE_;
+  using pointer_type = std::shared_ptr<_CLASSE_>;
+  using STLVect = std::vector<pointer_type>; // vector of shared ptr to _CLASSE_
+  using Iterator = typename STLVect::iterator;
+  using Const_Iterator = typename STLVect::const_iterator;
+
+  // XXX : Elie Saikali
+  // We have an std vector of shared ptrs => iterators return pointers and not the passed value type
+  // These classes allows a return of the value type
+  class IteratorWrapper
+  {
+  public:
+    explicit IteratorWrapper(Iterator it) : it_(it) { }
+    value_type& operator*() { return *it_->get(); }
+    value_type* operator->() { return it_->get(); }
+    IteratorWrapper& operator++() { ++it_; return *this; }
+    IteratorWrapper operator++(True_int) { return IteratorWrapper(it_++); }
+    bool operator==(const IteratorWrapper& other) const { return it_ == other.it_; }
+    bool operator!=(const IteratorWrapper& other) const { return it_ != other.it_; }
+
+  private:
+    Iterator it_;
+  };
+
+  class ConstIteratorWrapper
+  {
+  public:
+    explicit ConstIteratorWrapper(Const_Iterator it) : it_(it) {}
+    const value_type& operator*() const { return *it_->get(); }
+    const value_type* operator->() const { return it_->get(); }
+    ConstIteratorWrapper& operator++() { ++it_; return *this; }
+    ConstIteratorWrapper operator++(True_int) { return ConstIteratorWrapper(it_++); }
+    bool operator==(const ConstIteratorWrapper& other) const { return it_ == other.it_; }
+    bool operator!=(const ConstIteratorWrapper& other) const { return it_ != other.it_; }
+
+  private:
+    Const_Iterator it_;
+  };
+
+protected:
+  unsigned taille_memoire() const override { throw; }
+  int duplique() const override { throw; }
+  Sortie& printOn(Sortie& s) const override { return printOn_<_CLASSE_>(s); }
+  Entree& readOn(Entree& s) override { return readOn_<_CLASSE_>(s); }
+
+private:
+  STLVect z_vect_;
+
+  template<typename _TYPE_>
+  std::enable_if_t< !(std::is_same<_TYPE_,MD_Vector>::value), Entree&>
+  readOn_(Entree& s)
+  {
+#ifndef LATATOOLS
+    int i;
+    s >> i;
+    clear();
+    _TYPE_ obj;
+    for (int ind = 0; ind < i; ind++)
+      {
+        s >> obj;
+        add(std::move(obj));
+      }
+#endif
+    return s;
+  }
+
+  template<typename _TYPE_>
+  std::enable_if_t< !(std::is_same<_TYPE_,MD_Vector>::value), Sortie&>
+  printOn_(Sortie& s) const
+  {
+#ifndef LATATOOLS
+    s << (int) z_vect_.size() << tspace;
+    for (auto &itr : z_vect_) s << *itr << tspace;
+    s << finl;
+#endif
+    return s;
+  }
+
+  // MD_Vector class does not derive from Objet_U => no readOn & printOn
+  template<typename _TYPE_>
+  std::enable_if_t<(std::is_same<_TYPE_,MD_Vector>::value), Entree&>
+  readOn_(Entree& s) { return s; }
+
+  template<typename _TYPE_>
+  std::enable_if_t<(std::is_same<_TYPE_,MD_Vector>::value), Sortie&>
+  printOn_(Sortie& s) const { return s ; }
+
+public:
+  ~TRUST_Vector() { z_vect_.clear(); }
+
+  TRUST_Vector() = default;
+
+  explicit TRUST_Vector(int i) { dimensionner_force(i); } /* clear, resize to i & fill with i empty shared ptrs */
+
+  // XXX : Elie Saikali
+  // Nota Bene : Deep copy : should not use the same memory !! So dangerous attention !!
+  TRUST_Vector(const TRUST_Vector& avect) : Objet_U(avect)
+  {
+    clear();
+    for (int i = 0; i < avect.size(); i++)
+      z_vect_.push_back(std::make_shared<_CLASSE_>(*avect.z_vect_[i]));
+  }
+
+  // get stl vector : attention its a vector of shared ptrs !!
+  const STLVect& get_stl_vect() const { return z_vect_; }
+  STLVect& get_stl_vect() { return z_vect_; }
+
+  // iterators on TRUST_Vector
+  IteratorWrapper begin() { return IteratorWrapper(z_vect_.begin()); }
+  IteratorWrapper end() { return IteratorWrapper(z_vect_.end()); }
+  const ConstIteratorWrapper begin() const { return ConstIteratorWrapper(z_vect_.begin()); }
+  const ConstIteratorWrapper end() const { return ConstIteratorWrapper(z_vect_.end()); }
+
+  /* Iterator begin() { return (z_vect_.begin()); }
+  Iterator end() { return (z_vect_.end()); }
+  const Const_Iterator begin() const { return (z_vect_.begin()); }
+  const Const_Iterator end() const { return (z_vect_.end()); } */
+
+  const value_type& operator[](int i) const { return *z_vect_[i]; }
+  value_type& operator[](int i) { return *z_vect_[i]; }
+
+  // XXX : Elie Saikali : Pas de negociation pour ca desole ...
+  const value_type& operator()(int i) const = delete;
+  value_type& operator()(int i) = delete;
+  value_type& add() = delete; //{ return add(_CLASSE_()); }
+
+  int size() const { return (int)z_vect_.size(); }
+  void reset() { z_vect_.clear(); }
+  void clear() { z_vect_.clear(); }
+  void resize(int i) { dimensionner(i); }
+  value_type& back() { return *(z_vect_.back()); }
+  value_type& front() { return *(z_vect_.front()); }
+
+  // XXX : Elie Saikali
+  // Attention : it is so important to implement dimensionner and dimensionner_force as this otherwise issue with the standard = operator.
+  // A pre-initialised shared ptr is required in each zone memory of the sized vector.
+  void dimensionner(int i)
+  {
+    const int old_size = (int)z_vect_.size();
+    if (old_size == i) return;
+
+    if (old_size != 0)
+      {
+        Cerr << "WARNING : dimensionner method of a TRUST_Vector" << finl;
+        Cerr << "Old vector size : " << old_size << finl;
+        Cerr << "New vector size : " << i << finl;
+      }
+
+    z_vect_.resize(i);
+    for (int j = old_size; j < i; j++)
+      z_vect_[j] = std::make_shared<_CLASSE_>();
+  }
+
+  void dimensionner_force(int i)
+  {
+    z_vect_.clear();
+    z_vect_.resize(i);
+    for (auto& itr : z_vect_) itr = std::make_shared<_CLASSE_>();
+  }
+
+  Entree& lit(Entree& s) { return readOn_<_CLASSE_>(s); }
+
+  TRUST_Vector& operator=(const TRUST_Vector& avect)
+  {
+    if (this == &avect) return *this;
+
+    clear();
+    for (int i = 0; i < avect.size(); i++)
+      z_vect_.push_back(std::make_shared<_CLASSE_>(*avect.z_vect_[i]));
+
+    return *this;
+  }
+
+  /* Add a new element to the vect */
+  value_type& add(value_type&& data_to_add)
+  {
+    z_vect_.emplace_back(std::make_shared<_CLASSE_>(std::forward<_CLASSE_>(data_to_add)));
+    return *(z_vect_.back());
+  }
+
+  value_type& add(const value_type& data_to_add)
+  {
+    z_vect_.push_back(std::make_shared<_CLASSE_>(data_to_add));
+    return *(z_vect_.back());
+  }
+
+  /* Append a vect to a vect */
+  void add(const TRUST_Vector& v2)
+  {
+    STLVect tmp_;
+    tmp_.reserve(v2.size());
+    auto lambda_ = [](pointer_type const &iter) { return std::make_shared<_CLASSE_>(*iter); };
+    std::transform(v2.get_stl_vect().begin(), v2.get_stl_vect().end(), std::back_inserter(tmp_), lambda_);
+    z_vect_.insert(z_vect_.end(), std::make_move_iterator(tmp_.begin()), std::make_move_iterator(tmp_.end()));
+  }
+};
+
+#endif /* TRUST_Vector_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/TVAlloc.h b/Utilities/VisItBridge/databases/readers/Lata/TVAlloc.h
new file mode 100644
index 00000000..1921af23
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/TVAlloc.h
@@ -0,0 +1,58 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef TVAlloc_included
+#define TVAlloc_included
+
+/*! Allocator adaptor that intercepts the 'construct' calls to convert value initialization into default initialization
+ * Written by Casey Carter (@codercasey)
+ * Taken from https://hackingcpp.com/cpp/recipe/uninitialized_numeric_array.html
+ *
+ * This allows "std::vector<T>(30)" to only allocate, not initialize, the data.
+ */
+template< typename T, typename Alloc = std::allocator<T> >
+class TVAlloc : public Alloc
+{
+  using a_t = std::allocator_traits<Alloc>;
+public:
+  // Obtain alloc<U> where U != T
+  template<typename U>
+  struct rebind
+  {
+    using other = TVAlloc<U, typename a_t::template rebind_alloc<U> >;
+  };
+
+  // Make inherited ctors visible
+  using Alloc::Alloc;
+
+  // Ddefault-construct objects - WITHOUT initialisation!
+  template<typename U>
+  void construct (U* ptr)     noexcept(    std::is_nothrow_default_constructible<      U>::value)
+  {
+    ::new(static_cast<void*>(ptr)) U; // 'placement new':
+  }
+
+  // Construct with ctor arguments
+  template<typename U, typename... Args>
+  void construct (U* ptr, Args&& ... args)
+  {
+    a_t::construct(
+      static_cast<Alloc&>(*this),
+      ptr, std::forward<Args>(args)...);
+  }
+
+};
+
+#endif /* TVAlloc_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/Type_info.h b/Utilities/VisItBridge/databases/readers/Lata/Type_info.h
new file mode 100644
index 00000000..1ab1adf7
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/Type_info.h
@@ -0,0 +1,105 @@
+/****************************************************************************
+* Copyright (c) 2023, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef Type_info_included
+#define Type_info_included
+class Objet_U;
+class Nom;
+class Noms;
+class Sortie;
+class Synonyme_info;
+
+
+/*! @brief modelise une information de type pour les Objet_U
+ *
+ * @sa Objet_U Nom
+ */
+class Type_info
+{
+public:
+  ~Type_info();
+  Type_info(const char* name, Objet_U* (*f)(), int nb_bases=0, const Type_info** bases=0);
+  Type_info(const char* name,                  int nb_bases=0, const Type_info** bases=0);
+
+  inline const Nom& name() const
+  {
+    return *name_;
+  };
+  inline int      can_cast(const Type_info* p) const;
+
+  int     same(const Type_info* p) const;
+  int     same(const Nom&) const;
+  int     has_base(const Type_info* p, int direct=0) const;
+  int     has_base(const Nom& , int direct=0) const;
+  Sortie&    bases(Sortie&) const;
+  Objet_U*   instance() const;
+  int     instanciable() const;
+
+  // Methodes statiques :
+  static Sortie&           hierarchie(Sortie&) ;
+  static int            est_un_type(const char*) ;
+  static int            les_sous_types(const Nom&, Noms& sous_types);
+  static int            les_sous_types(const Type_info&, Noms& sous_types);
+  static const Type_info * type_info_from_name(const char * type_name);
+  static Objet_U*          instance(const char* typ);
+
+protected:
+
+private:
+  Type_info(Type_info&) {}; // Constructeur par copie invalide
+  Type_info&    operator=(Type_info&); // Operateur= invalide
+  void   ajouter_type(const Type_info& type_info);
+  static int search_type_info_name(const char *nom, int& index);
+
+  // Possible names (eg: A|B)
+  const char* names_ = "rien";
+  // Name and its synonym
+  mutable Nom * name_ = nullptr; // (eg: A)
+  mutable Nom * synonym_name_ = nullptr; // (eg: B)
+  // Object synonym:
+  Synonyme_info* synonym_= nullptr; // Synonym
+
+  // Nombre de classes de base de cette classe
+  int nb_bases_ = -1;
+  // Liste des Type_info des classes de base de cette classe
+  const Type_info** b= nullptr;
+  // Pointeur vers la methode statique "cree_instance" de la classe
+  // (nul si la classe n'est pas instanciable)
+  Objet_U* (*cree_instance)()= nullptr;
+
+  // Liste des Type_info des classes declarees par declare_base/declare_instanciable
+  // La liste est triee par ordre alphabetique (minuscules/majuscules indifferentes)
+  static const Type_info** les_types;
+  // Pour chaque type enregistre dans "les_types", s'il existe plusieurs classes
+  // ayant le meme "nom", alors types_homonymes != 0.
+  static int * types_homonymes;
+  // Nombre de classes enregistrees dans "les_types" et "types_homonymes"
+  static int nb_classes;
+  // Taille memoire du tableau "les_types" et "types_homonymes"
+  // (tableau redimensionne par blocs)
+  static int les_types_memsize;
+};
+
+/*! @brief Exploration de la hierarchie des types retourne 1 si p pointe sur un sous type du type considere
+ *
+ * @param (const Type_info* p) pointeur sur le type a tester
+ * @return (int) 1 si p pointe sur un sous type du type considere, 0 sinon
+ */
+inline int Type_info::can_cast(const Type_info* p) const
+{
+  return ( (same(p)) || (p->has_base(this)) );
+}
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/UserFields.cpp b/Utilities/VisItBridge/databases/readers/Lata/UserFields.cpp
new file mode 100644
index 00000000..4cc5a507
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/UserFields.cpp
@@ -0,0 +1,896 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#include <UserFields.h>
+#include <LataFilter.h>
+#include <stdlib.h>
+// ********************************************************************************
+// METHODES OUTILS DE GESTION
+//  (normalement, on n'a pas besoin de les modifier mais on peut en ajouter...)
+// ********************************************************************************
+
+// Implementation de la classe Geometry_handle
+// (utiliser cette classe pour eviter d'avoir a faire des dynamic_cast
+//  compliques et pour ne pas avoir a gerer get_geometry et release_geometry a la main)
+// Exemple d'utilisation: voir interpoler_elem_vers_som()
+Geometry_handle::Geometry_handle() { }
+
+void Geometry_handle::set(LataFilter & lata_filter, const Domain_Id & id)
+{
+  lata_filter_ = lata_filter;
+  geom_ = lata_filter.get_geometry(id);
+}
+
+Geometry_handle::Geometry_handle(Geometry_handle & handle)
+{
+  operator=(handle);
+}
+
+Geometry_handle & Geometry_handle::operator=(Geometry_handle & handle)
+{
+  reset();
+  lata_filter_ = handle.lata_filter_;
+  // Get another reference from the lata filter (to increment ref counter in the cache)
+  geom_ = lata_filter_.valeur().get_geometry(handle.geom_.valeur().id_);
+  return *this;
+}
+
+Geometry_handle::~Geometry_handle()
+{
+  reset();
+}
+
+void Geometry_handle::reset()
+{
+  if (geom_.non_nul())
+    lata_filter_.valeur().release_geometry(geom_.valeur());
+  geom_.reset();
+  lata_filter_.reset();
+}
+
+const DomainUnstructured & Geometry_handle::geom()
+{
+  if (!geom_.non_nul()) {
+    Journal() << "Internal error in Geometry_handle::geom() : nul pointer" << endl;
+    throw;
+  }
+  const DomainUnstructured* ptr = dynamic_cast<const DomainUnstructured *>(&geom_.valeur());
+  if (!ptr) {
+    Journal() << "Error in Geometry_handle::geom() : domain " 
+              << geom_.valeur().id_.name_ << " is not unstructured" << endl;
+    throw;
+  }
+  return *ptr;
+}
+
+const DomainIJK & Geometry_handle::geom_ijk()
+{
+  if (!geom_.non_nul()) {
+    Journal() << "Internal error in Geometry_handle::geom() : nul pointer" << endl;
+    throw;
+  }
+  const DomainIJK* ptr = dynamic_cast<const DomainIJK *>(&geom_.valeur());
+  if (!ptr) {
+    Journal() << "Error in Geometry_handle::geom() : domain " 
+              << geom_.valeur().id_.name_ << " is not IJK" << endl;
+    throw;
+  }
+  return *ptr;
+}
+
+bool Geometry_handle::test_ijk()
+{
+  if (!geom_.non_nul()) {
+    Journal() << "Internal error in Geometry_handle::geom() : nul pointer" << endl;
+    throw;
+  }
+  const DomainIJK* ptr = dynamic_cast<const DomainIJK *>(&geom_.valeur());
+  if (ptr)
+    return true;
+  else
+    return false;
+}
+
+// Description: demande a la classe LataFilter le champ source du champ "id"
+//  qui a ete declare quand on a appele declare_new_name() au debut
+// Voir filtre_boite() pour un exemple d'utilisation.
+FieldType UserFields::get_champ_source(const Field_Id & id)
+{
+  // Cherche la structure LataFieldMetaData du champ "id":
+  const LataFieldMetaData & data = lata_filter_.valeur().get_field_metadata(id.uname_);
+  Field_Id id2(data.source_field_, id.timestep_, id.block_);
+  FieldType tmp;
+  const LataField_base & field = lata_filter_.valeur().get_field(id2);
+  const FieldType* ptr = dynamic_cast<const FieldType *>(&field);
+  if (!ptr) {
+    Journal() << "Error in UserFields::get_champ_source : field " << id.uname_ 
+              << " is not a floattab" << endl;
+    throw;
+  }
+  // Copie le contenu du champ dans un tableau temporaire:
+  tmp = *ptr;
+  // Libere le champ d'origine
+  lata_filter_.valeur().release_field(field);
+  return tmp;
+}
+
+// Description: demande a la classe LataFilter le champ de nom "nom" et dont
+//  la geometrie, le pas de temps et la localisation sont celles de "id".
+FieldType UserFields::get_champ(const Nom & nom, const Field_Id & id)
+{
+  FieldType tmp;
+  // Construit un Field_Id identique, seul le nom du champ chamge:
+  Field_Id id2(id);
+  id2.uname_.set_field_name(nom);
+  const LataField_base & field = lata_filter_.valeur().get_field(id2);
+  const FieldType* ptr = dynamic_cast<const FieldType *>(&field);
+  if (!ptr) {
+    Journal() << "Error in UserFields::get_champ : field " << id.uname_ 
+              << " is not a floattab" << endl;
+    throw;
+  }
+  // Copie le contenu du champ dans un tableau temporaire:
+  tmp = *ptr;
+  // Libere le champ d'origine
+  lata_filter_.valeur().release_field(field);
+
+  return tmp;
+}
+
+// Description: idem, mais cherche un champ avec une localisation differente de id
+FieldType UserFields::get_champ_loc(const Nom & nom, LataField_base::Elem_som loc, const Field_Id & id)
+{
+  FieldType tmp;
+  // Construit un Field_Id identique, seul le nom du champ chamge:
+  Field_Id id2(id);
+  id2.uname_ = Field_UName(id.uname_.get_geometry(), nom, LataField_base::localisation_to_string(loc));
+  
+  const LataField_base & field = lata_filter_.valeur().get_field(id2);
+  const FieldType* ptr = dynamic_cast<const FieldType *>(&field);
+  if (!ptr) {
+    Journal() << "Error in UserFields::get_champ : field " << id.uname_ 
+              << " is not a floattab" << endl;
+    throw;
+  }
+  // Copie le contenu du champ dans un tableau temporaire:
+  tmp = *ptr;
+  // Libere le champ d'origine
+  lata_filter_.valeur().release_field(field);
+
+  return tmp;
+}
+
+// Description: renvoie un objet Geometry_handle qui pointe sur le domaine
+//  support du champ "id".
+// Voir interpoler_elem_vers_som() pour un exemple d'utilisation
+void UserFields::get_geometry(const Domain_Id & id, Geometry_handle & h)
+{
+  h.set(lata_filter_.valeur(), id);
+}
+
+// ********************************************************************************
+//  METHODES OUTILS DE CALCUL
+//  Ces methodes sont des fonctions qui calculent un champ en fonction d'un autre champ.
+//  On peut les modifier comme on veut, en ajouter, etc... 
+//  Lachez-vous...
+// ********************************************************************************
+
+// Description:
+//  Fonction d'interpolation qui transforme un champ aux "elements"
+//  en un champ aux "sommets".
+//  Dans cet exemple, on a deux algorithmes selon que le champ est sur
+//  un maillage ijk ou non.
+//  La valeur aux sommets est la moyenne des valeurs sur les elements adjacents.
+FieldType UserFields::interpoler_elem_vers_som(const Field_Id & id)
+{
+  // Recupere le champ a filtrer (champ aux elements)
+  FieldType source = get_champ_source(id);
+
+  FieldType resu;
+  // Remplissage des meta-data du champ:
+  resu.id_ = id;
+  resu.component_names_ = source.component_names_;
+  resu.localisation_ = LataField_base::SOM;
+  resu.nature_ = source.nature_;
+  
+  // Recupere la geometrie (domaine ijk ou non structure) sur laquelle est definie
+  //  le champ source:
+  Geometry_handle geom;
+  get_geometry(id, geom);
+  BigArrOfFloat poids;
+
+  if (geom.test_ijk()) {
+    const DomainIJK & dom = geom.geom_ijk();
+    // Le code suivant marche en 1D, 2D et 3D:
+    const trustIdType nbsom = dom.nb_nodes();
+    const int nbcompo = (int)source.data_.dimension(1);
+    resu.data_.resize(nbsom, nbcompo);
+    const int nsom_x = dom.nb_som_dir(0);
+    const int nsom_y = dom.nb_som_dir(1);
+    const int nelem_x = dom.nb_elem_dir(0);
+    const int nelem_y = dom.nb_elem_dir(1);
+    const int nelem_z = dom.nb_elem_dir(2);
+    poids.resize_array(nbsom);
+    const int ni = 2;
+    const int nj = (dom.dimension() > 1) ? 2 : 1;
+    const int nk = (dom.dimension() > 2) ? 2 : 1;
+
+    // Avec les boucles imbriquees comme ceci, on parcourt tous les
+    //  elements dans l'ordre croissant:
+    // (l'indice de l'element (i,j,k) est :
+    //    elem = (k * nelem_y + j) * nelem_x + i
+    int elem = 0;
+    for (int k = 0; k < nelem_z; k++) {
+      for (int j = 0; j < nelem_y; j++) {
+        for (int i = 0; i < nelem_x; i++) {
+          if (dom.invalid_connections_.size_array() == 0 || dom.invalid_connections_[elem] == 0) {
+            // Element valide:
+            // Boucle sur les sommets de l'element
+            const trustIdType som0 = (k * nsom_y + j) * nsom_x + i;
+            for (int kk = 0; kk < nk; kk++) {
+              for (int jj = 0; jj < nj; jj++) {
+                for (int ii = 0; ii < ni; ii++) {
+                  trustIdType som = som0 + (kk * nsom_y + jj) * nsom_x + ii;
+                  for (int compo = 0; compo < nbcompo; compo++)
+                    resu.data_(som, compo) += source.data_(elem, compo);
+                  poids[som] += 1.0f;
+                }
+              }
+            }
+          }
+          elem++;
+        }
+      }
+    }
+  } else {
+    const DomainUnstructured & dom = geom.geom();
+
+    const trustIdType nbsom = dom.nb_nodes();
+    const int nbcompo = (int)source.data_.dimension(1);
+    resu.data_.resize(nbsom, nbcompo);
+    poids.resize_array(nbsom);
+    const BigTIDTab & les_elem = dom.elements_;
+    const trustIdType n = les_elem.dimension(0);
+    const int m = (int)les_elem.dimension(1);
+    int i, j, k;
+    for ( i = 0; i < n; i++) {
+      for (j = 0; j < m; j++) {
+          trustIdType som = les_elem(i,j);
+        for (k = 0; k < nbcompo; k++) {
+          float x = source.data_(i, k);
+          resu.data_(som, k) += x;
+        }
+        poids[som] += 1.0f;
+      }
+    }
+  }
+  const trustIdType nbsom = poids.size_array();
+  const int nbcompo = (int)resu.data_.dimension(1);
+  for (trustIdType i = 0; i < nbsom; i++)
+    for (int k = 0; k < nbcompo; k++)
+      resu.data_(i, k) /= poids[i];
+
+  return resu;
+}
+
+
+//  Attention: le constructeur par defaut n'initialise pas le vecteur !
+class Vecteur3
+{
+public:
+  Vecteur3() {};
+  Vecteur3(const Vecteur3 & w) {
+    v[0] = w.v[0]; v[1] = w.v[1]; v[2] = w.v[2];
+  }
+  Vecteur3(double x, double y, double z) {
+    v[0] = x; v[1] = y; v[2] = z;
+  }
+  void  set(double x, double y, double z) {
+    v[0] = x; v[1] = y; v[2] = z;
+  }
+  double length() const { return sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]); };
+  Vecteur3(const DoubleTab & tab, int i) {
+    //assert(tab.line_size() == 3);
+    assert(i >= 0 && i < tab.dimension_tot(0));
+    const double *ptr = tab.addr() + i * 3;
+    v[0] = ptr[0];
+    v[1] = ptr[1];
+    v[2] = ptr[2];
+  }
+  Vecteur3 & operator=(double x) {
+    v[0] = x; v[1] = x; v[2] = x;
+    return *this;
+  }
+  Vecteur3 & operator*=(double x) {
+    v[0] *= x; v[1] *= x; v[2] *= x;
+    return *this;
+  }
+
+  Vecteur3 & operator=(const Vecteur3 & w) {
+    v[0] = w.v[0]; v[1] = w.v[1]; v[2] = w.v[2];
+    return *this;
+  }
+  double               operator[](int i) const { assert(i>=0 && i<3); return v[i]; }
+  double &             operator[](int i)       { assert(i>=0 && i<3); return v[i]; }
+  inline        double norme_Linfini();
+  static inline void   produit_vectoriel(const Vecteur3 & x, const Vecteur3 & y, Vecteur3 & resu);
+  static inline double produit_scalaire(const Vecteur3 & x, const Vecteur3 & y);
+  friend Vecteur3 operator-(const Vecteur3 &, const Vecteur3 &);
+protected:
+  double v[3];
+};
+
+
+inline void Vecteur3::produit_vectoriel(const Vecteur3 & x, const Vecteur3 & y, Vecteur3 & z)
+{
+  z.v[0] = x.v[1] * y.v[2] - x.v[2] * y.v[1];
+  z.v[1] = x.v[2] * y.v[0] - x.v[0] * y.v[2];
+  z.v[2] = x.v[0] * y.v[1] - x.v[1] * y.v[0];
+}
+
+inline double Vecteur3::produit_scalaire(const Vecteur3 & x, const Vecteur3 & y)
+{
+  double r = x.v[0] * y.v[0] + x.v[1] * y.v[1] + x.v[2] * y.v[2];
+  return r;
+}
+
+// Description: norme L_infini, c'est le max des abs(v[i])
+inline double Vecteur3::norme_Linfini()
+{
+  double x = fabs(v[0]);
+  double y = fabs(v[1]);
+  double z = fabs(v[2]);
+  double resu = ((x > y) ? x : y);
+  resu = ((resu > z) ? resu : z);
+  return resu;  
+}
+
+inline Vecteur3 operator-(const Vecteur3 & x, const Vecteur3 & y)
+{
+  Vecteur3 z;
+  z.v[0] = x.v[0] - y.v[0];
+  z.v[1] = x.v[1] - y.v[1];
+  z.v[2] = x.v[2] - y.v[2];
+  return z;
+}
+
+double largest_angle_2(const DoubleTab& coords)
+{
+  if (((coords.dimension(0)!=4)&&(coords.dimension(0)!=3))||(coords.dimension(1)!=3))
+    {
+      Cerr<<" cas nn prevu"<<endl; 
+      throw;
+    }
+  int nb_face=coords.dimension(0);
+  Vecteur3 normals[4];
+  Vecteur3 edge[2],opp;
+  edge[1].set(0,0,1);
+  for (int n=0;n<nb_face;n++)
+    {
+     
+      int prem=0;
+      if (n==0) prem=1;
+      int compteur=0;
+      for (int s=0;s<nb_face;s++)
+        {
+          if ((s!=n) && (s!=prem))
+            {
+              edge[compteur].set(coords(s,0)-coords(prem,0),
+                                 coords(s,1)-coords(prem,1),
+                                 coords(s,2)-coords(prem,2));
+              compteur++;
+            }
+        }
+      if (compteur!=nb_face-2) throw;
+      opp.set(coords(n,0)-coords(prem,0),
+              coords(n,1)-coords(prem,1),
+              coords(n,2)-coords(prem,2));
+      Vecteur3::produit_vectoriel(edge[0],edge[1],normals[n]);
+      //normals[n]=edge[0]*edge[1];
+      normals[n]*=1./normals[n].length();
+      if (Vecteur3::produit_scalaire(normals[n],opp)<0)
+        normals[n]*=-1;
+    }
+  // on a les 4 normals orientes vers l'interieur
+  double max_pscal=-100;
+  for (int n1=0;n1<nb_face;n1++)
+    for (int n2=n1+1;n2<nb_face;n2++)
+      {
+        double pscal=Vecteur3::produit_scalaire(normals[n1],normals[n2]);
+        //min_pscal=pscal;
+        if (pscal>max_pscal)
+          max_pscal=pscal;
+      }
+  double tet=acos(max_pscal)/acos(-1.)*180; // PL: acos(-1) ne compile pas sur de multiples plateformes
+  
+  tet=180-tet;
+  return tet;
+}
+
+
+FieldType UserFields::calculer_angle(const Field_Id & id)
+{
+  // Recupere le champ a filtrer (champ aux elements)
+  //  FieldType source = get_champ_source(id);
+  
+  FieldType resu;
+  // Remplissage des meta-data du champ:
+  resu.id_ = id;
+  const LataFieldMetaData & data = lata_filter_.valeur().get_field_metadata(id.uname_);
+  resu.component_names_ = data.component_names_;
+  resu.localisation_ = data.localisation_;
+  resu.nature_ = LataDBField::SCALAR;
+  
+  // Recupere la geometrie (domaine ijk ou non structure) sur laquelle est definie
+  //  le champ source:
+  Geometry_handle geom;
+  get_geometry(id, geom);
+
+  if (geom.test_ijk()) {
+    Journal() <<    "non code" <<endl;
+    throw;
+  } else {
+    const DomainUnstructured & dom = geom.geom();
+    const int nbcompo = dom.dimension();
+    //poids.resize_array(nbsom);
+    const BigTIDTab & les_elem = dom.elements_;
+    const trustIdType n = les_elem.dimension(0);
+ 
+    resu.data_.resize(n, nbcompo);
+    
+    const BigFloatTab& nodes_=dom.nodes_;
+    int nb_som_elem=(int)les_elem.dimension(1);
+    DoubleTab coords(nb_som_elem,3);
+    for ( trustIdType i = 0; i < n; i++) {
+      for (int s=0;s<nb_som_elem;s++)
+        for (int d=0;d<(int)nodes_.dimension(1);d++)
+          coords(s,d)=nodes_(les_elem(i,s),d);
+      resu.data_(i, 0) = (float)largest_angle_2(coords);
+    }
+  }
+  return resu;
+}
+
+FieldType UserFields::calculer_normale(const Field_Id & id)
+{
+
+  // Recupere le champ a filtrer (champ aux elements)
+  //  FieldType source = get_champ_source(id);
+
+  FieldType resu;
+  // Remplissage des meta-data du champ:
+  resu.id_ = id;
+  const LataFieldMetaData & data = lata_filter_.valeur().get_field_metadata(id.uname_);
+  resu.component_names_ = data.component_names_;
+  resu.localisation_ = data.localisation_;
+  resu.nature_ = LataDBField::VECTOR;
+  
+  // Recupere la geometrie (domaine ijk ou non structure) sur laquelle est definie
+  //  le champ source:
+  Geometry_handle geom;
+  get_geometry(id, geom);
+
+  if (geom.test_ijk()) {
+    Journal() <<    "non code" <<endl;
+    throw;
+  } else {
+    const DomainUnstructured & dom = geom.geom();
+    const int nbcompo = dom.dimension();
+    const BigTIDTab & les_elem = dom.elements_;
+    const trustIdType n = les_elem.dimension(0);
+ 
+    resu.data_.resize(n, nbcompo);
+    
+    const BigFloatTab& nodes_=dom.nodes_;
+    
+    ArrOfFloat v1( nbcompo),v2(nbcompo);
+    ArrOfDouble nor(nbcompo);
+    for ( trustIdType i = 0; i < n; i++) {
+      // calcul de la normale
+      trustIdType som0 = les_elem(i,0);
+      trustIdType som1 = les_elem(i,1);
+      for (int j=0;j<nbcompo;j++)
+        v1[j]=nodes_(som1,j)-nodes_(som0,j);
+      if (nbcompo==3)
+        {
+          trustIdType som2 = les_elem(i,2);
+          for (int j=0;j<nbcompo;j++)
+            v2[j]=nodes_(som2,j)-nodes_(som0,j);
+          
+          nor[0]=v1[1]*v2[2]-v1[2]*v2[1];
+          nor[1]=v1[2]*v2[0]-v1[0]*v2[2];
+          nor[2]=v1[0]*v2[1]-v1[1]*v2[0];
+          nor/=2.;
+        }
+      else
+        {
+          assert(nbcompo==2);
+          nor[0]=v1[1];
+          nor[1]=-v1[0];
+        }
+      for (int k = 0; k < nbcompo; k++) {
+        resu.data_(i, k) = (float)nor[k];
+      }
+    }
+  }
+  
+  return resu;
+}
+
+// Description:
+//  Fonction d'interpolation qui transforme un champ de vitesse VDF aux "faces"
+//  en un champ aux "elements".
+//  Ne fonctionne que sur les maillages ijk !
+//  On attend un champ scalaire a une composante en entree (champ source)
+//  et on fournit en sortie un champ vectoriel a "dimension" composantes.
+FieldType UserFields::interpoler_faces_vdf_vers_elem(const Field_Id & id)
+{
+  // Recupere le champ a filtrer (champ aux elements)
+  FieldType source = get_champ_source(id);
+  
+  if (source.localisation_ != LataField_base::FACES) {
+    Journal() << "Error in UserFields::interpoler_faces_vdf_vers_elem: source field " << id.uname_.build_string()
+              << " is not at faces !" << endl;
+    throw;
+  }
+
+  // Get geometry:
+  Geometry_handle geom;
+  get_geometry(id, geom);
+  if (!geom.test_ijk()) {
+    Journal() << "Error in UserFields::interpoler_faces_vdf_vers_elem: geometry of field " << id.uname_.build_string()
+              << " is not IJK" << endl;
+    throw;
+  }
+  const DomainIJK & dom = geom.geom_ijk();
+
+  const int dim = dom.dimension();
+  
+  if ((int)source.data_.dimension(1) != dim) {
+    Journal() << "Error in UserFields::interpoler_faces_vdf_vers_elem: source field " << id.uname_.build_string()
+              << " must have " << dim << " components !" << endl;
+    throw;
+  }
+
+  FieldType resu;
+  // Remplissage des meta-data du champ:
+  resu.id_ = id;
+  resu.component_names_.reset();
+  resu.localisation_ = LataField_base::ELEM;
+  resu.nature_ = LataDBField::VECTOR;
+
+  // Le code suivant marche en 1D, 2D et 3D:
+  const trustIdType nbelem = dom.nb_elements();
+  const int nbcompo = dim;
+  resu.data_.resize(nbelem, nbcompo);
+  const int nelem_x = dom.nb_elem_dir(0);
+  const int nelem_y = dom.nb_elem_dir(1);
+  const int nelem_z = dom.nb_elem_dir(2);
+  const int nfaces_x = dom.nb_som_dir(0);
+  const int nfaces_y = dom.nb_som_dir(1);
+  // Avec les boucles imbriquees comme ceci, on parcourt tous les
+  //  elements dans l'ordre croissant:
+  // (l'indice de l'element (i,j,k) est :
+  //    elem = (k * nelem_y + j) * nelem_x + i
+  int elem = 0;
+  for (int k = 0; k < nelem_z; k++) {
+    for (int j = 0; j < nelem_y; j++) {
+      for (int i = 0; i < nelem_x; i++) {
+        if (dom.invalid_connections_.size_array() == 0 || dom.invalid_connections_[elem] == 0) {
+          // Element valide:
+          // Boucle sur les trois directions:
+          for (int dir = 0; dir < dim; dir++) {
+            // indices des deux faces opposees de l'element dan la direction dir:
+            const trustIdType face1 = (k * nfaces_y + j) * nfaces_x + i;
+            trustIdType face2;
+            if (dir == 0)
+              face2 = face1 + 1;
+            else if (dir == 1)
+              face2 = face1 + nfaces_x;
+            else
+              face2 = face1 + nfaces_y * nfaces_x;
+            // On fait la moyenne des vitesses sur les deux faces
+            double v_moy = (source.data_(face1, dir) + source.data_(face2, dir)) * 0.5;
+            resu.data_(elem, dir) = (float)v_moy;
+          }
+        }
+        elem++;
+      }
+    }
+  }
+  return resu;
+}
+
+// **********************************************************************************
+// METHODES UTILISATEUR: ces methodes sont a mettre a jour en fonction des besoins
+//  specifiques...
+// **********************************************************************************
+
+// Description: Constructeur de la classe.
+//  Attention: penser a initialiser toutes les variables de la classe (options)
+UserFields_options::UserFields_options()
+{
+  demie_largeur_filtre_boite_ = 1;
+}
+
+// Cette methode est appelee avec les options en ligne de commande ou sur la troisieme
+//  ligne. Il faut renvoyer 0 si on ne comprend pas l'option, sinon 1.
+bool UserFields_options::parse_option(const Nom & option)
+{
+  if (option.debute_par("demie_largeur_filtre_boite=")) {
+    demie_largeur_filtre_boite_ = LataOptions::read_int_opt(option);
+  } else {
+    return false;
+  }
+  return true;
+}
+
+// Cette methode est appelee par lata_analyzer en ligne de commande pour afficher une aide.
+// On peut decrire toutes les options...
+void UserFields_options::print_help_option() const
+{
+  cerr << "Options provided by UserFields:" << endl;
+  cerr << " demie_largeur_filtre_boite=N  (see filtre_boite implementation)" << endl;
+}
+
+// Description:
+//  Cette methode est appelee par lata_analyzer au debut pour connaitre la liste
+//  des champs que UserFields est capable de calculer.
+//  fields_data contient en entree tous les champs deja fournis par lata_analyzer
+//   (champs presents dans le fichier .lata, plus les champs resultant des operateurs
+//    standards (regularize, dualmesh etc...)
+//  On doit ajouter dans fields_data la description des champs supplementaires 
+//   que UserFields peut calculer.
+void UserFields::new_fields_metadata(LataFilter & filter,
+                                     LataVector<LataFieldMetaData> & fields_data)
+{
+  lata_filter_ = filter;
+
+  const Noms geoms = filter.get_exportable_geometry_names();
+  
+  const int nb_geometries = geoms.size();
+  
+  for (int i = 0; i < nb_geometries; i++) {
+    const LataGeometryMetaData data = filter.get_geometry_metadata(geoms[i]);
+    
+    // Si on a des faces, proposer la normale aux faces
+    int topo_dim=data.dimension_;
+    
+    switch(data.element_type_) {
+    case Domain::point:     topo_dim = 0; break;
+    case Domain::line:      topo_dim = 1; break;
+    case Domain::triangle:
+    case Domain::polygone:
+    case Domain::quadri:    topo_dim = 2; break;
+    case Domain::tetra:
+    case Domain::prism6:
+    case Domain::polyedre:
+    case Domain::hexa:      topo_dim = 3; break;
+    default:
+      cerr << "avtlataFileFormat::PopulateDatabaseMetaData error: unknown element type" << endl;
+      throw;
+    }
+    if ((data.dimension_>1)&&(topo_dim!=data.dimension_)) {
+      Journal(1)<<"Ajout de la normale"<<endl;
+      LataFieldMetaData dest;
+      dest.name_ = "normals/NORMALE";
+      dest.geometry_name_ = data.internal_name_;
+      dest.component_names_.reset() ;
+      
+      dest.nb_components_ = data.dimension_;
+      dest.is_vector_ = true;
+      dest.localisation_ = LataField_base::ELEM;
+      dest.source_localisation_ = "ELEM";
+      dest.source_ = "user_fields";
+      // source_field_ inutile.
+      
+      dest.uname_ = Field_UName(dest.geometry_name_,
+                                dest.name_,
+                                LataField_base::localisation_to_string(dest.localisation_));
+      fields_data.add(dest);
+    }
+    else
+    if (data.element_type_==Domain::triangle||data.element_type_==Domain::tetra)
+      
+      {
+         Journal(1)<<"Ajout de mesh_quality/LargestAngle"<<endl;
+         LataFieldMetaData dest;
+         dest.name_ = "mesh_quality/LargestAngle";
+         dest.geometry_name_ = data.internal_name_;
+         dest.component_names_.reset() ;
+      
+         dest.nb_components_ = 1;
+         dest.is_vector_ = false;
+         dest.localisation_ = LataField_base::ELEM;
+         dest.source_localisation_ = "ELEM";
+         dest.source_ = "user_fields";
+         // source_field_ inutile.
+      
+         dest.uname_ = Field_UName(dest.geometry_name_,
+                                   dest.name_,
+                                   LataField_base::localisation_to_string(dest.localisation_));
+         fields_data.add(dest);
+      }
+  }
+}
+
+// Description:
+//  Cette methode publique est appelee par lata_analyzer pour obtenir les champs declares dans
+//  new_fields_metadata. Il faut tester "id" et calculer le champ demande.
+//  On a le droit d'appeler get_champ() pour obtenir d'autres champs.
+FieldType UserFields::get_field(const Field_Id & id)
+{
+  // Convertit le nom du champ en majuscules:
+  Motcle nom(id.uname_.get_field_name());
+
+  // Ces deux lignes sont des EXEMPLES (a remplacer par les champs qu'on veut
+  //  effectivement calculer)
+  if (nom == "moyenne_temperature")    return filtre_boite(id);
+  else if (nom.finit_par("_elem_vers_som")) return interpoler_elem_vers_som(id);
+  else if (nom.finit_par("_faces_vers_elem")) return interpoler_faces_vdf_vers_elem(id);
+  else if (nom.debute_par("normals/NORMALE")) return calculer_normale(id);
+  else if (nom.debute_par("mesh_quality/LargestAngle")) return calculer_angle(id);
+  // Ceci doit rester:
+  else {
+    Journal() << "Error in UserFields::get_field: unknown field " << nom << endl;
+    throw;
+  }
+}
+
+class FiltreSpatial
+{   
+public:
+  FiltreSpatial(LataFilter & lata, const Domain_Id & id, int demi_pas) :
+    demi_pas_(-1), pbDim_(-1), nx_(-1), ny_(-1), nz_(-1), dx_(-1.), dy_(-1.), dz_(-1.)
+  {
+    init(lata, id, demi_pas); 
+  }
+  FieldType filtrer(const FieldType & f, const Field_Id & id) const;
+  FieldType gradient(const FieldType & f, const Field_Id & id) const;
+  float volume() const { return dx_ * dy_ * dz_; }
+protected:
+  void init(LataFilter & lata, const Domain_Id & id, int demi_pas);
+  BigFloatTab calculer_somme_dir(const BigFloatTab & src, const int dir) const;
+  BigFloatTab annu_bord(const BigFloatTab & input, int epaisseur) const;
+  trustIdType ijk_index(int i, int j, int k) const {
+    if (i < 0)
+      i = 0;
+    else if (i >= nx_)
+      i = nx_-1;
+    if (j < 0)
+      j = 0;
+    else if (j >= ny_)
+      j = ny_ - 1;
+    if (k < 0)
+      k = 0;
+    else if (k >= nz_)
+      k = nz_-1; 
+    return (trustIdType)k*(trustIdType)ny_*(trustIdType)nx_ + (trustIdType)j*(trustIdType)nx_ + (trustIdType)i;
+  } 
+
+  // Tableau: pour chaque element, 1 s'il est INVALIDE, 0 s'il est OK
+  BigArrOfBit invalid_connections_;
+
+  int demi_pas_;
+  int pbDim_; // dimension
+  int nx_;
+  int ny_;
+  int nz_;
+  float dx_;
+  float dy_;
+  float dz_;
+};
+
+void FiltreSpatial::init(LataFilter & lata, const Domain_Id & id, int demi_pas)
+{
+  const Domain & dom = lata.get_geometry(id);
+  const DomainIJK * ptr = dynamic_cast<const DomainIJK *>(&dom);
+  if (!ptr) {
+    Journal() << "Error in FiltreSpatial::init : domain " << id.name_ << " is not IJK" << endl;
+    throw;
+  }
+  demi_pas_ = demi_pas;
+  pbDim_ = ptr->coord_.size();
+  nx_ = ptr->coord_[0].size_array() - 1;
+  ny_ = ptr->coord_[1].size_array() - 1;
+  if (pbDim_ == 3)
+    nz_ = ptr->coord_[2].size_array() - 1;
+  else
+    nz_ = 1;
+
+  dx_ = ptr->coord_[0][1] - ptr->coord_[0][0];
+  dy_ = ptr->coord_[1][1] - ptr->coord_[1][0];
+  if (pbDim_ == 3)
+    dz_ = ptr->coord_[2][1] - ptr->coord_[2][0];
+  else
+    dz_ = 1.;
+
+  invalid_connections_ = ptr->invalid_connections_;
+
+  if (invalid_connections_.size_array() == 0) {
+    invalid_connections_.resize_array(ptr->nb_elements());
+    invalid_connections_ = 0;
+  }
+
+  lata.release_geometry(dom);
+}
+
+BigFloatTab FiltreSpatial::calculer_somme_dir(const BigFloatTab & src, const int dir) const
+{
+  const trustIdType n = src.dimension(0);
+  const int nb_compo = (int)src.dimension(1);
+  BigFloatTab tmp;
+  tmp.resize(n, nb_compo);
+
+  int index_resu = 0;
+  for (int k = 0; k < nz_; k++) {
+    for (int j = 0; j < ny_; j++) {
+      for (int i = 0; i < nx_; i++) {
+        for (int count = -demi_pas_; count <= demi_pas_; count++) {
+          trustIdType index;
+          switch(dir) {
+          case 0: index = ijk_index(i+count, j, k); break;
+          case 1: index = ijk_index(i, j+count, k); break;
+          case 2: index = ijk_index(i, j, k+count); break;
+          default:
+            throw;
+          }
+
+          if (invalid_connections_[index] == 1 && dir == 0) {
+            // element invalide !
+          } else {
+            // element ok !
+            for (int compo = 0; compo < nb_compo; compo++)
+              tmp(index_resu, compo) += src(index, compo);
+          }
+        }
+        index_resu++;
+      }
+    }
+  }
+  return tmp;
+}
+
+FieldType FiltreSpatial::filtrer(const FieldType & source, const Field_Id & id) const
+{
+  // On copie tout pour avoir les noms des composantes, localisation etc...
+  FieldType resu = source;
+  resu.id_ = id;
+
+  BigFloatTab somme_x = calculer_somme_dir(source.data_, 0);
+  BigFloatTab somme_y = calculer_somme_dir(somme_x, 1);
+  if (pbDim_ == 3)
+    resu.data_ = calculer_somme_dir(somme_y, 2);
+  else
+    resu.data_ = somme_y;
+
+  int pas = demi_pas_ * 2 + 1;
+  double fact = pas * pas;
+  if (pbDim_ == 3)
+    fact *= pas;
+  resu.data_ *= (float)(1. / fact);
+
+  return resu;
+}
+
+FieldType UserFields::filtre_boite(const Field_Id & id)
+{
+  FieldType source = get_champ_source(id);
+  FiltreSpatial filtre(lata_filter_.valeur(), id, opt_.demie_largeur_filtre_boite_);
+  FieldType resu = filtre.filtrer(source, id);
+
+  return resu;
+}
+
diff --git a/Utilities/VisItBridge/databases/readers/Lata/UserFields.h b/Utilities/VisItBridge/databases/readers/Lata/UserFields.h
new file mode 100644
index 00000000..ddcaea80
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/UserFields.h
@@ -0,0 +1,91 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef UserFields_H
+#define UserFields_H
+
+#include <LataTools.h>
+#include <LataStructures.h>
+#include <TRUSTArray.h>
+
+template<class F> class Field;
+typedef Field<BigFloatTab> FieldType;
+class Field_Id;
+class LataFilter;
+struct LataFieldMetaData;
+class DomainUnstructured;
+class DomainIJK;
+
+// Description: classe outil pour acceder a une geometrie dans LataFilter.
+//  La geometrie est chargee en memoire quand cet objet est cree,
+//  elle est dechargee quand il est detruit.
+// Exemple d'utilisation dans UserFields::interpoler_elem_vers_som
+class Geometry_handle
+{
+public:
+  Geometry_handle();
+  Geometry_handle(Geometry_handle&);
+  Geometry_handle& operator=(Geometry_handle&);
+  ~Geometry_handle();
+  void set(LataFilter &filter, const Domain_Id&);
+  const DomainUnstructured& geom();
+  const DomainIJK& geom_ijk();
+  bool test_ijk();
+protected:
+  void reset();
+  LataRef<LataFilter> lata_filter_;
+  LataRef<const Domain> geom_;
+};
+
+class UserFields_options
+{
+public:
+  UserFields_options();
+  bool parse_option(const Nom&);
+  void print_help_option() const;
+
+  // Exemple de parametre en option (commentaires bienvenus !)
+  // demie-largeur du filtre_boite en mailles
+  int demie_largeur_filtre_boite_;
+};
+
+class UserFields
+{
+public:
+  void set_options(const UserFields_options &opt) { opt_ = opt; }
+  void new_fields_metadata(LataFilter &filter, LataVector<LataFieldMetaData> &fields_data);
+  FieldType get_field(const Field_Id &id);
+  Size_t compute_memory_size() { return 0; }
+
+protected:
+  // Declaration de methodes outils
+  FieldType get_champ_source(const Field_Id &id);
+  FieldType get_champ(const Nom &nom, const Field_Id &id);
+  FieldType get_champ_loc(const Nom &nom, LataField_base::Elem_som loc, const Field_Id &id);
+  void get_geometry(const Domain_Id &id, Geometry_handle&);
+
+  FieldType filtre_boite(const Field_Id &id);
+  FieldType calculer_normale(const Field_Id &id);
+  FieldType calculer_angle(const Field_Id &id);
+  FieldType interpoler_elem_vers_som(const Field_Id &id);
+  FieldType interpoler_faces_vdf_vers_elem(const Field_Id &id);
+
+  // Reference a la classe LataFilter (pour recuperer les champs sources)
+  LataRef<LataFilter> lata_filter_;
+
+  UserFields_options opt_;
+};
+
+#endif /* UserFields_H */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/View_Types.h b/Utilities/VisItBridge/databases/readers/Lata/View_Types.h
new file mode 100644
index 00000000..83d1a1c6
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/View_Types.h
@@ -0,0 +1,193 @@
+/****************************************************************************
+* Copyright (c) 2025, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef View_Types_included
+#define View_Types_included
+
+#include <kokkos++.h>
+
+#ifdef KOKKOS
+// The DualView type allowing semi-automatic sync between host and device.
+// By default, host is 'LayoutRight' and device is 'LayoutLeft' -> very important
+// We keep Kokkos::LayoutRight for OpenMP now
+template<typename T>
+using DualViewArr = Kokkos::DualView<T *, Kokkos::LayoutRight>;
+template<typename T>
+using DualViewTab = Kokkos::DualView<T **, Kokkos::LayoutRight>;
+template<typename T>
+using DualViewTab3 = Kokkos::DualView<T ***, Kokkos::LayoutRight>;
+template<typename T>
+using DualViewTab4 = Kokkos::DualView<T ****, Kokkos::LayoutRight>;
+
+// The execution space (=where code is run): on the device if compiled for GPU, else CPU.
+using execution_space = DualViewArr<double>::execution_space;
+
+// Typedefs for range policies in kernels
+using range_1D = Kokkos::RangePolicy<execution_space>;
+using range_2D = Kokkos::MDRangePolicy<execution_space, Kokkos::Rank<2>>;
+using range_3D = Kokkos::MDRangePolicy<execution_space, Kokkos::Rank<3>>;
+
+// The memory space (=where data is stored): on the device if compiled for GPU, or on CPU otherwise:
+typedef std::conditional< \
+std::is_same<execution_space, Kokkos::DefaultExecutionSpace>::value , \
+DualViewArr<double>::memory_space, DualViewArr<double>::host_mirror_space>::type \
+memory_space;
+
+// Whatever the compilation type, the host memory space:
+using host_mirror_space = DualViewArr<double>::host_mirror_space;
+
+//for host views:
+//"You do not need to explicitly specify host_execution_space because host_mirror_space already implies that you are using the host execution space."
+//memory space implies execution space
+
+using random_unmanaged_memory = Kokkos::MemoryTraits<Kokkos::RandomAccess | Kokkos::Unmanaged>;
+// The actual view type that will be manipulated everywhere in the kernels (a *device* view)
+template<typename T>
+using ViewArr = Kokkos::View<T *, typename DualViewArr<T>::array_layout, memory_space, Kokkos::MemoryRandomAccess>;
+template<typename T>
+using ViewTab = Kokkos::View<T **, typename DualViewArr<T>::array_layout, memory_space, Kokkos::MemoryRandomAccess>;
+template<typename T>
+using ViewTab3 = Kokkos::View<T ***, typename DualViewArr<T>::array_layout, memory_space, Kokkos::MemoryRandomAccess>;
+template<typename T>
+using ViewTab4 = Kokkos::View<T ****, typename DualViewArr<T>::array_layout, memory_space, Kokkos::MemoryRandomAccess>;
+
+// Views on the host that allow conditional execution of loop that are not fully ported to device. They are unmanaged to avoid new allocation
+template<typename T>
+using HostViewArr = Kokkos::View<T *, typename DualViewArr<T>::array_layout, host_mirror_space,  random_unmanaged_memory>;
+template<typename T>
+using HostViewTab = Kokkos::View<T **, typename DualViewArr<T>::array_layout, host_mirror_space,  random_unmanaged_memory>;
+template<typename T>
+using HostViewTab3 = Kokkos::View<T ***, typename DualViewArr<T>::array_layout, host_mirror_space,  random_unmanaged_memory>;
+template<typename T>
+using HostViewTab4 = Kokkos::View<T ****, typename DualViewArr<T>::array_layout, host_mirror_space,  random_unmanaged_memory>;
+
+// Its const version (const disabled for OpenMP, weird bug)
+#ifdef _OPENMP_TARGET
+template<typename T>
+using ConstViewArr = Kokkos::View</* const */T *, typename DualViewArr<T>::array_layout, memory_space, Kokkos::MemoryRandomAccess>;
+template<typename T>
+using ConstViewTab = Kokkos::View</* const */T **, typename DualViewArr<T>::array_layout, memory_space, Kokkos::MemoryRandomAccess>;
+template<typename T>
+using ConstViewTab3 = Kokkos::View</* const */T ***, typename DualViewArr<T>::array_layout, memory_space, Kokkos::MemoryRandomAccess>;
+template<typename T>
+using ConstViewTab4 = Kokkos::View</* const */T ****, typename DualViewArr<T>::array_layout, memory_space, Kokkos::MemoryRandomAccess>;
+// Host views
+template<typename T>
+using ConstHostViewArr = Kokkos::View<const T *, typename DualViewArr<T>::array_layout, host_mirror_space,  random_unmanaged_memory>;
+template<typename T>
+using ConstHostViewTab = Kokkos::View<const T **, typename DualViewArr<T>::array_layout, host_mirror_space,  random_unmanaged_memory>;
+template<typename T>
+using ConstHostViewTab3 = Kokkos::View<const T ***, typename DualViewArr<T>::array_layout, host_mirror_space,  random_unmanaged_memory>;
+template<typename T>
+using ConstHostViewTab4 = Kokkos::View<const T ****, typename DualViewArr<T>::array_layout, host_mirror_space,  random_unmanaged_memory>;
+
+#else //else openmp
+
+template<typename T>
+using ConstViewArr = Kokkos::View<const T *, typename DualViewArr<T>::array_layout, memory_space, Kokkos::MemoryRandomAccess>;
+template<typename T>
+using ConstViewTab = Kokkos::View<const T **, typename DualViewArr<T>::array_layout, memory_space, Kokkos::MemoryRandomAccess>;
+template<typename T>
+using ConstViewTab3 = Kokkos::View<const T ***, typename DualViewArr<T>::array_layout, memory_space, Kokkos::MemoryRandomAccess>;
+template<typename T>
+using ConstViewTab4 = Kokkos::View<const T ****, typename DualViewArr<T>::array_layout, memory_space, Kokkos::MemoryRandomAccess>;
+// Host views
+template<typename T>
+using ConstHostViewArr = Kokkos::View<const T *, typename DualViewArr<T>::array_layout, host_mirror_space,  random_unmanaged_memory>;
+template<typename T>
+using ConstHostViewTab = Kokkos::View<const T **, typename DualViewArr<T>::array_layout, host_mirror_space,  random_unmanaged_memory>;
+template<typename T>
+using ConstHostViewTab3 = Kokkos::View<const T ***, typename DualViewArr<T>::array_layout, host_mirror_space,  random_unmanaged_memory>;
+template<typename T>
+using ConstHostViewTab4 = Kokkos::View<const T ****, typename DualViewArr<T>::array_layout, host_mirror_space,  random_unmanaged_memory>;
+#endif
+
+// Handy aliases:
+using IntArrView = ViewArr<int>;
+using DoubleArrView = ViewArr<double>;
+
+using CIntArrView = ConstViewArr<int>;
+using CDoubleArrView = ConstViewArr<double>;
+
+using IntTabView = ViewTab<int>;
+using DoubleTabView = ViewTab<double>;
+using DoubleTabView3 = ViewTab3<double>;
+using DoubleTabView4 = ViewTab4<double>;
+
+using CIntTabView = ConstViewTab<int>;
+using CIntTabView3 = ConstViewTab3<int>;
+using CDoubleTabView = ConstViewTab<double>;
+using CDoubleTabView3 = ConstViewTab3<double>;
+using CDoubleTabView4 = ConstViewTab4<double>;
+
+// Host views
+using IntArrHostView = HostViewArr<int>;
+using DoubleArrHostView = HostViewArr<double>;
+
+using CIntArrHostView = ConstHostViewArr<int>;
+using CDoubleArrHostView = ConstHostViewArr<double>;
+
+using IntTabHostView = HostViewTab<int>;
+using DoubleTabHostView = HostViewTab<double>;
+using DoubleTabHostView3 = HostViewTab3<double>;
+using DoubleTabHostView4 = HostViewTab4<double>;
+
+using CIntTabHostView = ConstHostViewTab<int>;
+using CIntTabHostView3 = ConstHostViewTab3<int>;
+using CDoubleTabHostView = ConstHostViewTab<double>;
+using CDoubleTabHostView3 = ConstHostViewTab3<double>;
+using CDoubleTabHostView4 = ConstHostViewTab4<double>;
+
+extern void kokkos_self_test();
+#else
+
+using IntArrView = IntVect;
+using DoubleArrView = DoubleVect;
+
+using CIntArrView = const IntVect;
+using CDoubleArrView = const DoubleVect;
+
+using IntTabView = IntTab;
+using DoubleTabView = DoubleTab;
+using DoubleTabView3 = DoubleTab;
+using DoubleTabView4 = DoubleTab;
+
+using CIntTabView = IntTab& ;
+using CIntTabView3 = IntTab& ;
+using CDoubleTabView = const DoubleTab& ;
+using CDoubleTabView3 = const DoubleTab;
+using CDoubleTabView4 = const DoubleTab;
+//Host
+using IntArrHostView = IntVect;
+using DoubleArrHostView = DoubleVect;
+
+using CIntArrHostView = const IntVect;
+using CDoubleArrHostView = const DoubleVect;
+
+using IntTabHostView = IntTab;
+using DoubleTabHostView = DoubleTab;
+using DoubleTabHostView3 = DoubleTab;
+using DoubleTabHostView4 = DoubleTab;
+
+using CIntTabHostView = IntTab& ;
+using CIntTabHostView3 = IntTab& ;
+using CDoubleTabHostView = const DoubleTab& ;
+using CDoubleTabHostView3 = const DoubleTab;
+using CDoubleTabHostView4 = const DoubleTab;
+
+#define KOKKOS_INLINE_FUNCTION inline
+#endif
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/arch.h b/Utilities/VisItBridge/databases/readers/Lata/arch.h
new file mode 100644
index 00000000..d7174773
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/arch.h
@@ -0,0 +1,142 @@
+//TRUST_NO_INDENT
+/****************************************************************************
+* Copyright (c) 2025, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+/*****************************************************************************/
+/* WARNING: this file is generated automatically from arch.h.in !!           */
+/* DO NOT EDIT MANUALLY.                                                     */
+/*****************************************************************************/
+
+
+/*! @brief Gestion des dependances machines pour l'appel a FORTRAN La macro F77DECLARE(TOTO) permet de declarer une routine FORTRAN.
+ *
+ *   La macro F77NAME(TOTO) permet d'appeler une routine FORTRAN.
+ *   Exemple :
+ *   toto.f :
+ *          SUBROUTINE TOTO(DOUBLE X)
+ *          X=2.0*X
+ *          RETURN
+ *          END
+ *
+ *   appel_toto.cpp
+ *   void F77DECLARE(TOTO) (const double* );
+ *   void main()
+ *   {
+ *      double x;
+ *      F77NAME(TOTO)(x);
+ *   }
+ *
+ */
+
+#ifndef _ARCH_H_
+#define _ARCH_H_
+
+#include <generique.h>
+
+// The below used to differ according to compilers, but now should be standard:
+#define IOS_OPEN_MODE std::ios_base::openmode
+#define IOS_FORMAT std::ios_base::fmtflags
+
+#ifdef __CYGWIN__
+void srand48(int) ;
+double drand48();
+char* strdup(const char* s);
+#endif
+
+#ifdef MICROSOFT
+void srand48(int) ;
+double drand48();
+double atanh(const double&);
+#include <iso646.h>
+#define NO_RANDOM
+#define F77DECLARE(x) F77NAME(x)
+#else
+#define F77DECLARE(x) F77NAME(x)
+#endif
+
+#ifndef F77CALLWITHOUT_
+#define F77NAME(x) name2(x,_)
+#else
+#define F77NAME(x) x
+#endif
+
+// Used for FORTRAN interfaces:
+typedef int integer;
+// This one always remain an int, even when replacing all int by long in the historical (find/replace)
+// 64b building mode:
+typedef int True_int;
+
+extern char* pwd();
+
+/* **************************************
+            32b / 64b management
+  **************************************
+  Below we define 'trustIdType', type used to store all geometrical entity indices (element index, node index, ...) that might
+  exceed the 32b limit.
+
+  All the TRUST libraries (LIBLATAFILTER notably) and all the main C++ source code can be compiled in either 32b or 64b depending
+  on the flag set at configure time.
+
+  However the lata_tools and VisIt plugin are **only** 64b for simplicity, and because it will be provided to the VisIt team for integration.
+
+  In the core TRUST C++ code, the strategy is as follows: all the C++ classes that are potentially used before the Scatter keyword
+  should support both 32 or 64b mode. This is typically done by having them templatized on the SIZE parameter. In practice however
+  some classes are not yet ported to 64b and will remain only functional in 32b.
+  The idea is that once the computation is distributed on several processors, each proc will never need to use 64b indices. And everything
+  happening after Scatter (like the operator computations, etc.) is done on one proc only.
+  (note that there are some exceptions for the postprocessing where we still need a total number of elements for example).
+
+  The Zone files (containing splitted domains after Partition) are always written in 32b (see DomaineCutter and look for set_64b(false))
+  Similarly, the save/restart files are always 32b (see SaveRestart.cpp).
+  
+  The input/output management is sometimes tricky, since even with an executable compiled in 64b, we might need to write (/read) 32b data.
+  See what is done class AbstractIO about this.
+
+  Various types/sizes of arrays are declared in TRUSTTab_forward.h. For example you might want a small of array of (big) identifiers (=SmallArrOfTID)
+  or a big array of regular 32b int (=BigArrOfInt). Notice that for big arrays, only the first dimension (dimension 0) might be big. Other axes
+  always remain within 32b.
+  
+  For the IJK parts of the code, the rule is that : the three directions nx, ny and nz are always within 32b, but their *product* might exceed 32b.
+
+  At the time of writing, there are two ways to produce a 64b version of the code:
+    - either with configure flag '-with-64-bit-indices' which brutally replace all 'int' in the source code with 'long' (historical).
+    When done so, C++ define tag 'INT_is_64_' is set to 1.
+    - or with configure flag '-64-bit-new' (the final target), defining trustIdType to int64. In this case C++ define tag
+    'INT_is_64_' is set to 2.
+*/
+
+#include <cstdint>
+// We will often rely on std::numeric_limits<int>::max(), so need this:
+#include <limits>
+
+#if 1          // are we in 64b mode?
+using trustIdType = std::int64_t;
+#  ifndef INT_is_64_           // it might have been already defined by the CMake (e.g. in lata_tools compilation)
+#    if  1     // are we in 64b mode, new way of doing it?
+#      define INT_is_64_ 2
+#    else
+#      define INT_is_64_ 1
+#    endif
+#  endif
+#else
+#  ifdef LATATOOLS
+using trustIdType = std::int64_t;   // In lata_tools and VisIt lata plugin, trustIdType is always 64b, so that the tools
+//                                  // can deal with any type of lata files (32b or 64b)
+#  else
+using trustIdType = int;
+#  endif
+#endif
+
+#endif // _ARCH_H_
diff --git a/Utilities/VisItBridge/databases/readers/Lata/avtlataFileFormat.C b/Utilities/VisItBridge/databases/readers/Lata/avtlataFileFormat.C
new file mode 100644
index 00000000..abb64681
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/avtlataFileFormat.C
@@ -0,0 +1,933 @@
+/*****************************************************************************
+ *
+ * Copyright (c) 2000 - 2015, Lawrence Livermore National Security, LLC
+ * Produced at the Lawrence Livermore National Laboratory
+ * All rights reserved.
+ *
+ * This file is part of VisIt. For details, see http://www.llnl.gov/visit/. The
+ * full copyright notice is contained in the file COPYRIGHT located at the root
+ * of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+ *
+ * Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  - Redistributions of  source code must  retain the above  copyright notice,
+ *    this list of conditions and the disclaimer below.
+ *  - Redistributions in binary form must reproduce the above copyright notice,
+ *    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+ *    documentation and/or materials provided with the distribution.
+ *  - Neither the name of the UC/LLNL nor  the names of its contributors may be
+ *    used to  endorse or  promote products derived from  this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+ * ARE  DISCLAIMED.  IN  NO  EVENT  SHALL  THE  REGENTS  OF  THE  UNIVERSITY OF
+ * CALIFORNIA, THE U.S.  DEPARTMENT  OF  ENERGY OR CONTRIBUTORS BE  LIABLE  FOR
+ * ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+ * LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+ * OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ *****************************************************************************/
+
+// ************************************************************************* //
+//                            avtlataFileFormat.C                           //
+// ************************************************************************* //
+
+#include <avtlataFileFormat.h>
+
+#include <LmlReader.h>
+#include <LataJournal.h>
+
+#include <avtDatabaseMetaData.h>
+#include <avtGhostData.h>
+
+#include <DebugStream.h>
+#include <Expression.h>
+#include <InvalidVariableException.h>
+
+#include <vtkCellData.h>
+#include <vtkCellType.h>
+#include <vtkFloatArray.h>
+#include <vtkInformation.h>
+#include <vtkIntArray.h>
+#include <vtkLongArray.h>
+#include <vtkRectilinearGrid.h>
+#include <vtkStreamingDemandDrivenPipeline.h>
+#include <vtkStructuredGrid.h>
+#include <vtkUnsignedCharArray.h>
+#include <vtkUnstructuredGrid.h>
+
+#include <string>
+#include <fstream>
+#include <iostream>
+#include <visitstream.h>
+#include <vector>
+
+// ****************************************************************************
+//  Method: avtlata constructor
+//
+//  Programmer: fauchet -- generated by xml2avt
+//
+// ****************************************************************************
+
+avtlataFileFormat::avtlataFileFormat(const char *filename)
+    : avtMTMDFileFormat(filename)
+{
+    debug1 << "avtlataFileFormat constructor " << filename << endl;
+    try {
+        set_Journal_level(0);
+
+        LataOptions opt;
+        LataOptions::extract_path_basename(filename, opt.path_prefix, opt.basename);
+        opt.dual_mesh = true;
+        opt.faces_mesh = true;
+        opt.regularize = 2;
+        opt.regularize_tolerance = 1e-7f;
+        opt.user_fields_=true;
+        read_any_format_options(filename, opt);
+        debug1 << "avtlataFileFormat: initializing filter" << endl;
+        // Read the source file to the lata database
+        read_any_format(filename, opt.path_prefix, lata_db_);
+        filter_.initialize(opt, lata_db_);
+    }
+    catch (LataDBError& err) {
+        cerr << "Error in LataFilter::initialize " << filename << " " << err.describe() << endl;
+        throw;
+    }
+}
+
+avtlataFileFormat::~avtlataFileFormat()
+{
+}
+
+// ****************************************************************************
+//  Method: avtEMSTDFileFormat::GetNTimesteps
+//
+//  Purpose:
+//      Tells the rest of the code how many timesteps there are in this file.
+//
+//  Programmer: fauchet -- generated by xml2avt
+//
+// ****************************************************************************
+
+int
+avtlataFileFormat::GetNTimesteps(void)
+{
+    int n;
+    try {
+        n = filter_.get_nb_timesteps();
+        // Timestep 0 contains global definitions.
+        // If we have "real" timesteps, do not show timestep 0
+        if (n > 1)
+            n--;
+    }
+    catch (LataDBError& err) {
+        cerr << "Error in getntimesteps " << filename << " " << err.describe() << endl;
+        throw;
+    }
+    return n;
+}
+
+void avtlataFileFormat::GetTimes(std::vector<double>& times)
+{
+    int n;
+    try {
+        n = filter_.get_nb_timesteps();
+        if (n == 1)
+            times.push_back(0.);
+        else
+            for (int i = 1; i < n; i++)
+                times.push_back(filter_.get_timestep(i));
+    }
+    catch (LataDBError& err) {
+        cerr << "Error in gettimes " << filename << " " << err.describe() << endl;
+        throw;
+    }
+    return;
+}
+
+// ****************************************************************************
+//  Method: avtlataFileFormat::FreeUpResources
+//
+//  Purpose:
+//      When VisIt is done focusing on a particular timestep, it asks that
+//      timestep to free up any resources (memory, file descriptors) that
+//      it has associated with it.  This method is the mechanism for doing
+//      that.
+//
+//  Programmer: fauchet -- generated by xml2avt
+//
+// ****************************************************************************
+
+void
+avtlataFileFormat::FreeUpResources(void)
+{
+}
+
+int is_fort21(const char* filename);
+
+// ****************************************************************************
+//  Method: avtlataFileFormat::PopulateDatabaseMetaData
+//
+//  Purpose:
+//      This database meta-data object is like a table of contents for the
+//      file.  By populating it, you are telling the rest of VisIt what
+//      information it can request from you.
+//
+//  Programmer: fauchet -- generated by xml2avt
+//
+// ****************************************************************************
+void
+avtlataFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
+{
+    try {
+        debug1 << "avtlataFileFormat::PopulateDatabaseMetaData : "
+               << filename << " " << timeState << endl;
+
+        const char *suffix_vector_names[] = { "_X", "_Y", "_Z" };
+        const char *suffix_vector_expr[] = { "[0]", "[1]", "[2]" };
+
+        const Noms geoms = filter_.get_exportable_geometry_names();
+
+        for (int i_geom = 0; i_geom < geoms.size(); i_geom++) {
+            debug1 << " Domain : " << geoms[i_geom] << endl;
+            const LataGeometryMetaData data = filter_.get_geometry_metadata(geoms[i_geom]);
+
+            avtMeshType mt = AVT_UNSTRUCTURED_MESH;
+
+            if (data.is_ijk_==1)
+            {
+                mt = AVT_RECTILINEAR_MESH;
+            }
+            int block_origin = 0;
+            int topo_dim;
+            switch(data.element_type_) {
+            case Domain::point:
+                topo_dim = 0;
+                mt = AVT_POINT_MESH;
+                break;
+            case Domain::line:
+                topo_dim = 1;
+                break;
+            case Domain::triangle:
+            case Domain::polygone:
+            case Domain::quadri:
+                topo_dim = 2;
+                break;
+            case Domain::tetra:
+            case Domain::prism6:
+            case Domain::polyedre:
+            case Domain::hexa:
+                topo_dim = 3;
+                break;
+            default:
+                cerr << "avtlataFileFormat::PopulateDatabaseMetaData error: unknown element type" << endl;
+                topo_dim = 3; ///TODO: this should be an error in default case!
+                EXCEPTION1(InvalidVariableException,
+                           "avtlataFileFormat::PopulateDatabaseMetaData error: unknown element type");
+                throw;
+            }
+
+            bool mesh_faces=false;
+            if  (data.internal_name_.finit_par("_centerfaces"))
+            {
+                //cerr<<"la "<<data.internal_name_<<endl;
+                mesh_faces=true;
+            }
+            double *extents = NULL;
+            const std::string geom_name(data.displayed_name_);
+            AddMeshToMetaData(md, geom_name, mt, extents, data.nblocks_, block_origin,
+                              data.dimension_, topo_dim);
+            mesh_username_.add(data.displayed_name_);
+            mesh_latafilter_name_.add(data.internal_name_);
+
+            Field_UNames fields = filter_.get_exportable_field_unames(geoms[i_geom]);
+
+            bool c3 = (is_fort21(filename)==1);
+            for (int i_field = 0; i_field < fields.size(); i_field++) {
+                const LataFieldMetaData data2 = filter_.get_field_metadata(fields[i_field]);
+                avtCentering cent;
+                switch (data2.localisation_) {
+                case LataField_base::ELEM:
+                    cent = AVT_ZONECENT;
+                    break;
+                case LataField_base::SOM:
+                    cent = AVT_NODECENT;
+                    break;
+                default:
+                    // Do not export fields that cannot be shown
+                    continue;
+                }
+
+                // Take localisation of source field
+                Nom loc = data2.source_localisation_;
+                std::string varname(data2.name_);
+                if (!c3)
+                  {
+                    varname += "_";
+                    varname += loc;
+                    varname += "_";
+                    varname += geom_name;
+                  }
+                else
+                  {
+                    varname = geom_name;
+                    varname += "/";
+                    varname+=data2.name_;
+                  }
+                if (data2.nb_components_ == 1) {
+                    // Scalar field
+                    // We append the geometry name to the component name:
+                    register_fieldname(varname.c_str(), fields[i_field], 0);
+                    if (!mesh_faces)
+                        AddScalarVarToMetaData(md, varname, geom_name, cent);
+                } else if (data2.is_vector_ && data2.nb_components_ == data.dimension_) {
+                    // Vector field
+                    register_fieldname(varname.c_str(), fields[i_field], -1);
+                    AddVectorVarToMetaData(md, varname, geom_name, cent, data2.nb_components_);
+                    if (!mesh_faces)
+                    {
+                        std::string n;
+                        for (int i = 0; i < data2.nb_components_; i++) {
+                            Expression v;
+                            n = data2.name_;
+                            n += suffix_vector_names[i];
+                            n += "_";
+                            n += loc;
+                            n += "_";
+                            n += geom_name;
+                            v.SetName(n);
+                            n = varname;
+                            n += suffix_vector_expr[i];
+                            v.SetDefinition(n);
+                            v.SetType(Expression::ScalarMeshVar);
+                            md->AddExpression(&v);
+                        }
+                        if (varname.find_first_of("/",0)==std::string::npos)
+                        {
+                            // On calcule la norme des vecteurs de premier niveau (pas de / dans le chemin)
+                            Expression norme_v;
+                            n = "norme_";
+                            n += varname;
+                            norme_v.SetName(n);
+                            n = "magnitude(";
+                            n += varname;
+                            n += ")";
+                            norme_v.SetDefinition(n);
+                            norme_v.SetType(Expression::ScalarMeshVar);
+                            md->AddExpression(&norme_v);
+                        }
+                    }
+                } else {
+                    // Multiscalar field
+                    // I chose to postfix the varname with the component name, perhaps not the best choice.
+                    if (!mesh_faces)
+                    {
+                        for (int i_compo = 0; i_compo < data2.nb_components_; i_compo++) {
+                            std::string varname2(data2.name_);
+                            varname2 += "_";
+                            if (data2.component_names_.size() == data2.nb_components_) {
+                                varname2 += data2.component_names_[i_compo];
+                            } else {
+                                Nom n(i_compo);
+                                varname2 += n;
+                            }
+                            varname2 += "_";
+                            varname2 += loc;
+                            varname2 += "_";
+                            varname2 += geom_name;
+                            register_fieldname(varname2.c_str(), fields[i_field], i_compo);
+                            AddScalarVarToMetaData(md, varname2, geom_name, cent);
+                        }
+                    }
+                }
+            }
+        }
+        debug1 << "End avtlataFileFormat::PopulateDatabaseMetaData" << endl;
+    }
+    catch (LataDBError& err) {
+        cerr << "Error in PopulateDatabaseMetaData " << err.describe() << endl;
+        throw;
+    }
+}
+
+void
+avtlataFileFormat::register_fieldname(const char *visit_name, const Field_UName & uname, int component)
+{
+    if (field_username_.rang(visit_name) >= 0) {
+        cerr << "Error in avtlataFileFormat::register_fieldname: duplicate field name " << visit_name << endl;
+        cerr << "Ignoring field" << endl;
+        return;
+    }
+    field_username_.add(visit_name);
+    field_uname_.add(uname);
+    field_component_.add(component);
+}
+
+void
+avtlataFileFormat::register_meshname(const char *visit_name, const char *latafilter_name)
+{
+    if (mesh_username_.rang(visit_name) >= 0) {
+        cerr << "Error in avtlataFileFormat::register_meshname: duplicate name " << visit_name << endl;
+        cerr << "Ignoring mesh" << endl;
+        return;
+    }
+    mesh_username_.add(visit_name);
+    mesh_latafilter_name_.add(latafilter_name);
+}
+
+// ****************************************************************************
+//  Method: avtlataFileFormat::GetMesh
+//
+//  Purpose:
+//      Gets the mesh associated with this file.  The mesh is returned as a
+//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
+//      vtkUnstructuredGrid, etc).
+//
+//  Arguments:
+//      timestate   The index of the timestate.  If GetNTimesteps returned
+//                  'N' time steps, this is guaranteed to be between 0 and N-1.
+//      domain      The index of the domain.  If there are NDomains, this
+//                  value is guaranteed to be between 0 and NDomains-1,
+//                  regardless of block origin.
+//      meshname    The name of the mesh of interest.  This can be ignored if
+//                  there is only one mesh.
+//
+//  Programmer: fauchet -- generated by xml2avt
+//
+// ****************************************************************************
+
+vtkDataSet *
+avtlataFileFormat::GetMesh(int timestate, int block, const char *meshname)
+{
+    vtkDataSet *return_value = 0;
+    try {
+        debug1 << " avtlataFileFormat::GetMesh ts=" << timestate
+               << " block=" << block
+               << " meshname=" << meshname << endl;
+
+        // We have real timesteps in the database, add one to timestep index:
+        if (filter_.get_nb_timesteps() > 1)
+            timestate++;
+
+        const int index = mesh_username_.rang(meshname);
+        if (index < 0) {
+            cerr << "internal error in avtlataFileFormat::GetMesh: name " << meshname << " not found" << endl;
+            throw;
+        }
+        Domain_Id id(mesh_latafilter_name_[index], timestate, block);
+        const Domain & geometry = filter_.get_geometry(id);
+
+        const DomainUnstructured * geom_ptr = dynamic_cast<const DomainUnstructured*>(&geometry);
+        const DomainIJK          * ijk_ptr = dynamic_cast<const DomainIJK*>(&geometry);
+
+        if (geom_ptr) {
+            const DomainUnstructured & geom = *geom_ptr;
+
+            vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::New();
+            vtkPoints *points = vtkPoints::New();
+            const BigFloatTab & pos = geom.nodes_;
+            const trustIdType nnodes = pos.dimension(0);
+            const bool dim3 = (int)pos.dimension(1) == 3;
+            points->SetNumberOfPoints(nnodes);
+            float* pts = (float *) points->GetVoidPointer(0);
+            trustIdType i, jl=0;
+            for (i = 0; i < nnodes; i++) {
+                pts[jl]   = pos(i,0);
+                pts[jl+1] = pos(i,1);
+                pts[jl+2] = dim3 ? pos(i,2) : 0.f;
+                jl+=3;
+            }
+            ugrid->SetPoints(points);
+            points->Delete();
+
+            const BigTIDTab & conn = geom.elements_;
+            const BigTIDTab & elem_faces = geom.elem_faces_;
+            const BigTIDTab & faces = geom.faces_;
+            const trustIdType ncells = conn.dimension(0);
+            int nverts = (int)conn.dimension(1);
+
+            int type_cell;
+            switch (geom.elt_type_) {
+            case Domain::point:
+                type_cell=VTK_VERTEX;
+                if (ncells == 0)
+                    nverts = 1;
+                break;
+            case Domain::line:
+                type_cell=VTK_LINE;
+                break;
+            case Domain::triangle:
+                type_cell=VTK_TRIANGLE;
+                break;
+            case Domain::quadri:
+                type_cell=VTK_QUAD;
+                break;
+            case Domain::tetra:
+                type_cell=VTK_TETRA;
+                break;
+            case Domain::prism6:
+                type_cell=VTK_WEDGE;
+                break;
+            case Domain::hexa:
+                type_cell=VTK_HEXAHEDRON;
+                break;
+            case Domain::polygone:
+                type_cell=VTK_POLYGON;
+                break;
+            case Domain::polyedre:
+                type_cell= elem_faces.dimension(0) > 0 ? VTK_POLYHEDRON : VTK_CONVEX_POINT_SET;
+                break;
+            default:
+                type_cell=-1;
+                cerr<<"avtlataFileFormat::GetMesh unknown elt type "<<endl;
+                throw;
+                break;
+            }
+            vtkIdType *verts = new vtkIdType[nverts];
+            std::vector<vtkIdType> poly_p, poly_f;
+            if (type_cell == VTK_VERTEX && ncells == 0) {
+                // Cells are implicit. Create them:
+                ugrid->Allocate(nnodes);
+                for (i = 0; i < nnodes; i++) {
+                    verts[0] = i;
+                    ugrid->InsertNextCell(type_cell, nverts, verts);
+                }
+            } else {
+                ugrid->Allocate(ncells);
+                for (i = 0; i < ncells; i++) {
+                    if (type_cell==VTK_QUAD) {
+                        // Nodes order is different in visit than in trio_u
+                        verts[0]=conn(i,0);
+                        verts[1]=conn(i,1);
+                        verts[2]=conn(i,3);
+                        verts[3]=conn(i,2);
+                    } else if (type_cell==VTK_HEXAHEDRON) {
+                        // Nodes order is different in visit than in trio_u
+                        verts[0]=conn(i,0);
+                        verts[1]=conn(i,1);
+                        verts[2]=conn(i,3);
+                        verts[3]=conn(i,2);
+                        verts[4]=conn(i,4);
+                        verts[5]=conn(i,5);
+                        verts[6]=conn(i,7);
+                        verts[7]=conn(i,6);
+                    } else if (type_cell==VTK_POLYHEDRON) {
+                        //polyhedra, face by face
+                        int k;
+                        trustIdType nfaces = 0, npts = 0, i_f, s, f;
+                        poly_p.resize(0), poly_f.resize(0);
+                        for (int j = 0; j < (int)conn.dimension(1); j++)
+                          if ((s = conn(i, j)) >= 0)
+                            {
+                              poly_p.push_back(s);
+                              npts++;
+                            }
+                        for (int j = 0; j < (int)elem_faces.dimension(1); j++)
+                          if ((f = elem_faces(i, j)) >= 0)
+                            for (k = 0, nfaces++, i_f = poly_f.size(), poly_f.push_back(0); k < (int)faces.dimension(1) ; k++)
+                              if ((s = faces(f, k)) >= 0)
+                                {
+                                  poly_f.push_back(s);
+                                  poly_f[i_f]++;
+                                }
+                        ugrid->InsertNextCell(type_cell, npts, &poly_p[0], nfaces, &poly_f[0]);
+                    } else if ((type_cell==VTK_CONVEX_POINT_SET)||(type_cell==VTK_POLYGON)) {
+                        int nverts_loc=nverts;
+                        for (int j = 0; j < nverts; j++)
+                        {
+                            verts[j] = conn(i,j);
+
+                            if (verts[j]<=-1)
+                            {
+                                nverts_loc=j;
+                                break;
+                            }
+                            /*            else
+                            	{
+                            	if (verts[j]<-1)
+                            	{
+                            	std::cerr<<i<<" iiiii "<< j<<" "<<verts[j]<<finl;
+                            }
+
+                            }	*/
+                        }
+                        int  nb_som_max_to_regularize=0;
+                        if (filter_.get_options().regularize_polyedre!=0)
+                        {
+                            nb_som_max_to_regularize=8;
+                            if (filter_.get_options().regularize_polyedre==-1)
+                                nb_som_max_to_regularize=32000;
+                        }
+                        if ( geom.elt_type_==Domain::polygone)
+                            nb_som_max_to_regularize=-1;
+                        if ((nb_som_max_to_regularize>=6) && (nverts_loc==6))
+                            ugrid->InsertNextCell(VTK_WEDGE, nverts_loc, verts);
+                        else if ((nb_som_max_to_regularize>=12)&&(nverts_loc==12))
+                            ugrid->InsertNextCell(VTK_HEXAGONAL_PRISM, nverts_loc, verts);
+                        else if ((nb_som_max_to_regularize>=8)&&(nverts_loc==8))
+                        {
+                            // Nodes order is different in visit than in trio_u
+                            verts[0]=conn(i,0);
+                            verts[1]=conn(i,1);
+                            verts[2]=conn(i,3);
+                            verts[3]=conn(i,2);
+                            verts[4]=conn(i,4);
+                            verts[5]=conn(i,5);
+                            verts[6]=conn(i,7);
+                            verts[7]=conn(i,6);
+                            ugrid->InsertNextCell(VTK_HEXAHEDRON, nverts_loc, verts);
+
+                        }
+                        else
+                            ugrid->InsertNextCell(type_cell, nverts_loc, verts);
+                    }
+                    else {
+                        for (int j = 0; j < nverts; j++)
+                            verts[j] = conn(i,j);
+                    }
+                    if ((type_cell!=VTK_POLYHEDRON) &&(type_cell!=VTK_CONVEX_POINT_SET) && (type_cell!=VTK_POLYGON))
+
+                        ugrid->InsertNextCell(type_cell, nverts, verts);
+                }
+            }
+            delete [] verts;
+            verts = nullptr;
+            // Declare ghost elements:
+            const trustIdType n = geom.nb_virt_items(LataField_base::ELEM);
+            if (n > 0) {
+                unsigned char realVal = 0;
+                unsigned char ghost   = 0; // Sera modifie par AddGhostZoneType
+                avtGhostData::AddGhostZoneType(ghost, DUPLICATED_ZONE_INTERNAL_TO_PROBLEM);
+                vtkUnsignedCharArray *ghostcells = vtkUnsignedCharArray::New();
+                ghostcells->SetName("avtGhostZones");
+                ghostcells->SetNumberOfTuples(ncells);
+                unsigned char *dat = (unsigned char *) ghostcells->GetVoidPointer(0);
+                for (i = 0; i < ncells - n; i++)
+                    dat[i] = realVal;
+                for (i = ncells - n; i < ncells; i++)
+                    dat[i] = ghost;
+                ugrid->GetCellData()->AddArray(ghostcells);
+                ugrid->GetInformation()->Set(
+                    vtkStreamingDemandDrivenPipeline::UPDATE_NUMBER_OF_GHOST_LEVELS(), 0);
+                ghostcells->Delete();
+            }
+            return_value = ugrid;
+
+        } else if (ijk_ptr) {
+            const DomainIJK & geom = *ijk_ptr;
+
+            // Maillage regulier : on transmet la grille ijk
+            vtkRectilinearGrid *sgrid = vtkRectilinearGrid::New();
+
+            const int dim = geom.coord_.size();
+            ArrOfInt ncoord(3);
+            ncoord = 1;
+            for (int i = 0; i < dim; i++)
+                ncoord[i] = geom.coord_[i].size_array();
+            sgrid->SetDimensions(ncoord[0], ncoord[1], ncoord[2]);
+
+            for (int i = 0; i < 3; i++) {
+                float *data;
+                vtkFloatArray *c;
+                c = vtkFloatArray::New();
+                const int n = ncoord[i];
+                c->SetNumberOfTuples(n);
+                data = (float *) c->GetVoidPointer(0);
+                if (i < dim) {
+                    const ArrOfFloat & coord = geom.coord_[i];
+                    for (int j = 0; j < n; j++)
+                        data[j] = coord[j];
+                } else {
+                    data[0] = 0.;
+                }
+                switch(i) {
+                case 0:
+                    sgrid->SetXCoordinates(c);
+                    break;
+                case 1:
+                    sgrid->SetYCoordinates(c);
+                    break;
+                case 2:
+                    sgrid->SetZCoordinates(c);
+                    break;
+                default:
+                    ;
+                }
+                c->Delete();
+            }
+            // Create "invalid cells" data (GettingDataIntoVisit.pdf, page 136)
+            // and "ghost cells"
+            const trustIdType n = geom.invalid_connections_.size_array();
+            if (n > 0 || geom.virtual_layer_begin_ || geom.virtual_layer_end_) {
+                const trustIdType ncells = geom.nb_elements();
+                unsigned char realVal = 0;
+                unsigned char invalid = 0; // Sera modifie par AddGhostZoneType
+                unsigned char ghost   = 0;
+                avtGhostData::AddGhostZoneType(invalid, ZONE_NOT_APPLICABLE_TO_PROBLEM);
+                avtGhostData::AddGhostZoneType(ghost, DUPLICATED_ZONE_INTERNAL_TO_PROBLEM);
+                vtkUnsignedCharArray *ghostcells = vtkUnsignedCharArray::New();
+                ghostcells->SetName("avtGhostZones");
+                ghostcells->SetNumberOfTuples(ncells);
+                unsigned char *dat = (unsigned char *) ghostcells->GetVoidPointer(0);
+
+                for (trustIdType ii = 0; ii < ncells; ii++)
+                    dat[ii] = realVal;
+
+                if (n > 0) {
+                    // invalid cells
+                    for (trustIdType ii = 0; ii < ncells; ii++) {
+                        if (geom.invalid_connections_[ii])
+                            dat[ii] = invalid;
+                    }
+                }
+
+                // ghost cells
+                trustIdType ij = 1;
+                for (int i = 0; i < dim-1; i++)
+                    ij *= ncoord[i]-1;
+                if (geom.virtual_layer_begin_) {
+                    // first layer of cells is ghost
+                    for (int i = 0; i < ij * geom.virtual_layer_begin_; i++)
+                        dat[i] += ghost;
+                }
+                if (geom.virtual_layer_end_) {
+                    // last layer of cells is ghost
+                    for (trustIdType ii = ncells - ij * (trustIdType)geom.virtual_layer_end_; ii < ncells; ii++)
+                        dat[ii] += ghost;
+                }
+
+                sgrid->GetCellData()->AddArray(ghostcells);
+                sgrid->GetInformation()->Set(
+                    vtkStreamingDemandDrivenPipeline::UPDATE_NUMBER_OF_GHOST_LEVELS(), 0);
+                ghostcells->Delete();
+            }
+
+            return_value = sgrid;
+        } else {
+            cerr << "Error in avtlataFileFormat::GetMesh: unknown geometry type" << endl;
+            throw;
+        }
+
+        filter_.release_geometry(geometry);
+    }
+    catch (LataDBError& err) {
+        cerr << "Error in getmesh " << timestate << " " << block << " " << meshname << " " << err.describe() << endl;
+        throw;
+    }
+
+    return return_value;
+}
+
+
+// ****************************************************************************
+//  Method: avtlataFileFormat::GetVar
+//
+//  Purpose:
+//      Gets a scalar variable associated with this file.  Although VTK has
+//      support for many different types, the best bet is vtkFloatArray, since
+//      that is supported everywhere through VisIt.
+//
+//  Arguments:
+//      timestate  The index of the timestate.  If GetNTimesteps returned
+//                 'N' time steps, this is guaranteed to be between 0 and N-1.
+//      domain     The index of the domain.  If there are NDomains, this
+//                 value is guaranteed to be between 0 and NDomains-1,
+//                 regardless of block origin.
+//      varname    The name of the variable requested.
+//
+//  Programmer: fauchet -- generated by xml2avt
+//
+// ****************************************************************************
+
+vtkDataArray *
+avtlataFileFormat::GetVar(int timestate, int block, const char *varname)
+{
+    vtkDataArray * return_value = 0;
+    try {
+        // visit -debug 1 : activate debug1
+        debug1 << "Getvar time:" << timestate
+               << " block:" << block
+               << " varname:" << varname << endl;
+
+        if (filter_.get_nb_timesteps() > 1)
+            timestate++;
+
+        Field_UName field_uname;
+        int component;
+        get_field_info_from_visitname(varname, field_uname, component);
+
+        if (component < 0) {
+            cerr << "Error: avtlataFileFormat::GetVar called for vector field" << endl;
+            throw;
+        }
+
+        Field_Id id(field_uname, timestate, block);
+
+        const LataField_base & field = filter_.get_field(id);
+
+        const Field<BigFloatTab> * float_field_ptr = dynamic_cast<const Field<BigFloatTab>*>(&field);
+        const Field<BigIntTab> * int_field_ptr = dynamic_cast<const Field<BigIntTab>*>(&field);
+        const Field<BigTIDTab> * tid_field_ptr = dynamic_cast<const Field<BigTIDTab>*>(&field);
+
+        if (float_field_ptr) {
+            vtkFloatArray *rv = vtkFloatArray::New();
+            const Field<BigFloatTab> & fld = *float_field_ptr;
+            const BigFloatTab & values = fld.data_;
+            trustIdType ntuples = values.dimension(0);
+            rv->SetNumberOfTuples(ntuples);
+            float * data = rv->GetPointer(0);
+            for (trustIdType i = 0; i < ntuples; i++)
+                data[i] = values(i, component);
+            return_value = rv;
+        } else if (int_field_ptr) {
+            vtkIntArray *rv = vtkIntArray::New();
+            const Field<BigIntTab> & fld = *int_field_ptr;
+            const BigIntTab & values = fld.data_;
+            trustIdType ntuples = values.dimension(0);
+            rv->SetNumberOfTuples(ntuples);
+            int * data = rv->GetPointer(0);
+            for (trustIdType i = 0; i < ntuples; i++)
+                data[i] = values(i, component);
+            return_value = rv;
+        } else if (tid_field_ptr) {
+            vtkLongArray *rv = vtkLongArray::New();
+            const Field<BigTIDTab> & fld = *tid_field_ptr;
+            const BigTIDTab & values = fld.data_;
+            trustIdType ntuples = values.dimension(0);
+            rv->SetNumberOfTuples(ntuples);
+            long * data = rv->GetPointer(0);
+            for (trustIdType i = 0; i < ntuples; i++)
+                data[i] = values(i, component);
+            return_value = rv;
+        } else {
+            cerr << "Error in avtlataFileFormat::GetVar: unknown data type" << endl;
+            throw;
+        }
+        filter_.release_field(field);
+    }
+    catch (LataDBError& err) {
+        cerr << "Error in getvar " << timestate << " " << block << " " << varname << " " << err.describe() << endl;
+        throw;
+    }
+    return return_value;
+}
+
+
+// ****************************************************************************
+//  Method: avtlataFileFormat::GetVectorVar
+//
+//  Purpose:
+//      Gets a vector variable associated with this file.  Although VTK has
+//      support for many different types, the best bet is vtkFloatArray, since
+//      that is supported everywhere through VisIt.
+//
+//  Arguments:
+//      timestate  The index of the timestate.  If GetNTimesteps returned
+//                 'N' time steps, this is guaranteed to be between 0 and N-1.
+//      domain     The index of the domain.  If there are NDomains, this
+//                 value is guaranteed to be between 0 and NDomains-1,
+//                 regardless of block origin.
+//      varname    The name of the variable requested.
+//
+//  Programmer: fauchet -- generated by xml2avt
+//
+// ****************************************************************************
+
+vtkDataArray *
+avtlataFileFormat::GetVectorVar(int timestate, int block, const char *varname)
+{
+    vtkDataArray * return_value = 0;
+    try {
+        debug1 << "Getvectorvar time:" << timestate
+               << " block:" << block
+               << " varname:" << varname << endl;
+
+        if (filter_.get_nb_timesteps() > 1)
+            timestate++;
+
+        Field_UName field_uname;
+        int component;
+        get_field_info_from_visitname(varname, field_uname, component);
+
+        if (component >= 0) {
+            cerr << "Error: avtlataFileFormat::GetVectorVar called for scalar field" << endl;
+            throw;
+        }
+
+        Field_Id id(field_uname, timestate, block);
+
+        const LataField_base & field = filter_.get_field(id);
+
+        const Field<BigFloatTab> * float_field_ptr = dynamic_cast<const Field<BigFloatTab>*>(&field);
+        const Field<BigIntTab> * int_field_ptr = dynamic_cast<const Field<BigIntTab>*>(&field);
+        const Field<BigTIDTab> * tid_field_ptr = dynamic_cast<const Field<BigTIDTab>*>(&field);
+
+        if (float_field_ptr) {
+            vtkFloatArray *rv = vtkFloatArray::New();
+            const Field<BigFloatTab> & fld = *float_field_ptr;
+            const BigFloatTab & values = fld.data_;
+            trustIdType ntuples = values.dimension(0);
+            int dim = (int)values.dimension(1);
+            rv->SetNumberOfComponents(3);
+            rv->SetNumberOfTuples(ntuples);
+            float* data= rv->WritePointer(0,3*ntuples);
+            for (trustIdType i = 0; i < ntuples; i++)
+                for (int j = 0; j < 3; j++)
+                    data[i*3+j] = (j<dim) ? values(i, j) : 0.f;
+            return_value = rv;
+        } else if (int_field_ptr) {
+            vtkIntArray *rv = vtkIntArray::New();
+            const Field<BigIntTab> & fld = *int_field_ptr;
+            const BigIntTab & values = fld.data_;
+            trustIdType ntuples = values.dimension(0);
+            int dim = (int)values.dimension(1);
+            rv->SetNumberOfComponents(3);
+            rv->SetNumberOfTuples(ntuples);
+            int* data= rv->WritePointer(0,3*ntuples);
+            for (trustIdType i = 0; i < ntuples; i++)
+                for (int j = 0; j < 3; j++)
+                    data[i*3+j] = (j<dim) ? values(i, j) : 0;
+            return_value = rv;
+        } else if (tid_field_ptr) {
+            vtkLongArray *rv = vtkLongArray::New();
+            const Field<BigTIDTab> & fld = *tid_field_ptr;
+            const BigTIDTab & values = fld.data_;
+            trustIdType ntuples = values.dimension(0);
+            int dim = (int)values.dimension(1);
+            rv->SetNumberOfComponents(3);
+            rv->SetNumberOfTuples(ntuples);
+            long* data= rv->WritePointer(0,3*ntuples);
+            for (trustIdType i = 0; i < ntuples; i++)
+                for (int j = 0; j < 3; j++)
+                    data[i*3+j] = (j<dim) ? values(i, j) : 0;
+            return_value = rv;
+        } else {
+            cerr << "Error in avtlataFileFormat::GetVectorVar: unknown data type" << endl;
+            throw;
+        }
+        filter_.release_field(field);
+    }
+    catch (LataDBError& err) {
+        cerr << "Error in getvectorvar " << timestate << " " << block << " " << varname << " " << err.describe() << endl;
+        throw;
+    }
+    return return_value;
+}
+
+void avtlataFileFormat::get_field_info_from_visitname(const char *varname, Field_UName & uname, int & component) const
+{
+    const int k = field_username_.rang(varname);
+    if (k < 0) {
+        cerr << "Error in avtlataFileFormat::get_field_info_from_visitname: field " << varname << " not found" << endl;
+        throw  ;
+    }
+    uname = field_uname_[k];
+    component = field_component_[k];
+}
diff --git a/Utilities/VisItBridge/databases/readers/Lata/avtlataFileFormat.h b/Utilities/VisItBridge/databases/readers/Lata/avtlataFileFormat.h
new file mode 100644
index 00000000..392e43d3
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/avtlataFileFormat.h
@@ -0,0 +1,115 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2012, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* All rights reserved.
+*
+* This file is part of VisIt. For details, see http://www.llnl.gov/visit/. The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or materials provided with the distribution.
+*  - Neither the name of the UC/LLNL nor  the names of its contributors may be
+*    used to  endorse or  promote products derived from  this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED.  IN  NO  EVENT  SHALL  THE  REGENTS  OF  THE  UNIVERSITY OF
+* CALIFORNIA, THE U.S.  DEPARTMENT  OF  ENERGY OR CONTRIBUTORS BE  LIABLE  FOR
+* ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                            avtlataFileFormat.h                           //
+// ************************************************************************* //
+
+#ifndef AVT_lata_FILE_FORMAT_H
+#define AVT_lata_FILE_FORMAT_H
+
+#include <avtMTMDFileFormat.h>
+
+#include <vector>
+#include "LataFilter.h"
+
+// ****************************************************************************
+//  Class: avtlataFileFormat
+//
+//  Purpose:
+//      Reads in lata files as a plugin to VisIt.
+//
+//  Programmer: fauchet -- generated by xml2avt
+//
+// ****************************************************************************
+
+class avtlataFileFormat : public avtMTMDFileFormat
+{
+  public:
+    avtlataFileFormat(const char *);
+    virtual ~avtlataFileFormat();
+
+    //
+    // This is used to return unconvention data -- ranging from material
+    // information to information about block connectivity.
+    //
+    // virtual void      *GetAuxiliaryData(const char *var, const char *type,
+    //                                     int timestep, int domain,void *args, 
+    //                                     DestructorFunction &);
+    //
+
+    //
+    // If you know the times and cycle numbers, overload this function.
+    // Otherwise, VisIt will make up some reasonable ones for you.
+    //
+    // virtual void        GetCycles(std::vector<int> &);
+    // virtual void        GetTimes(std::vector<double> &);
+    //
+
+    virtual int            GetNTimesteps(void);
+
+    virtual const char    *GetType(void)   { return "lata"; };
+    virtual void           FreeUpResources(void); 
+
+    virtual vtkDataSet    *GetMesh(int timestate, int block, const char *meshname);
+    virtual vtkDataArray  *GetVar(int timestate, int block, const char *varname);
+    virtual vtkDataArray  *GetVectorVar(int timestate, int block, const char *varname);
+    virtual void GetTimes(std::vector<double>& times);
+
+  protected:
+    // DATA MEMBERS
+
+    virtual void           PopulateDatabaseMetaData(avtDatabaseMetaData *, int);
+
+    void register_fieldname(const char *visit_name, const Field_UName &, int component);
+    void register_meshname(const char *visit_name, const char *latafilter_name);
+    void get_field_info_from_visitname(const char *varname, Field_UName &, int & component) const;
+
+    LataDB      lata_db_; // Source database
+    LataFilter  filter_; // Data processor and cache
+    Noms field_username_;
+    Field_UNames field_uname_;
+
+    Noms mesh_username_;
+    Noms mesh_latafilter_name_;
+
+    // For each name, which component is it in the source field:
+    LataVector<int> field_component_;
+};
+
+
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/blas1.h b/Utilities/VisItBridge/databases/readers/Lata/blas1.h
new file mode 100644
index 00000000..93be8c13
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/blas1.h
@@ -0,0 +1,763 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef _BLAS1_H_
+#define _BLAS1_H_
+
+
+
+/*! @brief Appel aux blas1
+ *
+ */
+
+#include <arch.h>
+
+
+#ifndef _NO_BLAS1_
+extern "C"
+/*! @brief Appel aux blas1
+ *
+ */
+{
+
+#ifdef F77_Majuscule
+#ifndef CRAY
+  double F77DECLARE(DASUM)(const integer *n, const double* const dx, const integer *incx);
+
+
+  void F77DECLARE(DAXPY)(const integer *n, const double * const da, const double * const dx,
+                         const integer *incx, double * const dy, const integer *incy);
+
+  void F77DECLARE(DCOPY)(const integer *n,
+                         const double * const dx, const integer *incx,
+                         double * const dy, const integer *incy);
+
+
+  double F77DECLARE(DDOT)(const integer *n, const double * const dx, const integer *incx,
+                          const double * const dy, const integer *incy);
+
+  double F77DECLARE(DNRM2)(const integer *n, const double * const dx, const integer *incx);
+
+  void F77DECLARE(DROT)(const integer *n, double * const dx, const integer *incx, double * const dy,
+                        const integer *incy, const double * const c, const double * const s);
+
+  void F77DECLARE(DROTG)(double * const da, double * const db, double * const c, double * const s);
+
+  void F77DECLARE(DSCAL)(const integer *n, double * const da, double * const dx, const integer *incx);
+
+  void F77DECLARE(DSWAP)(const integer *n, double * const dx, const integer *incx, double * const dy,
+                         const integer *incy);
+
+  integer F77DECLARE(IDAMAX)(const integer *n, const double * const dx, const integer *incx);
+#endif
+
+  float F77DECLARE(SDOT)(const integer *n, const float *cx,
+                         const integer *incx, const float *cy, const integer *incy);
+
+  void F77DECLARE(SAXPY)(const integer *n, const float *da, const float *dx,
+                         const integer *incx, float *dy, const integer *incy);
+
+  void F77DECLARE(SCOPY)(const integer *n, float *dx, const integer *incx,
+                         float *dy, const integer *incy);
+
+  float F77DECLARE(SASUM)(const integer *n, const float *dx, const integer *incx);
+
+  float F77DECLARE(SNRM2)(const integer *n, const float *dx, const integer *incx);
+
+  void F77DECLARE(SSCAL)(const integer *n, const double * const da, float *dx,
+                         const integer *incx);
+
+  integer F77DECLARE(ISAMAX)(const integer *n, const float * const dx, const integer *incx);
+
+  void F77DECLARE(SSWAP)(const integer *n, float *dx, const integer *incx,
+                         float *dy, integer *incy);
+
+  void F77DECLARE(SROT)(const integer *n,
+                        double * const dx,
+                        const integer *incx,
+                        double * const dy,
+                        const integer *incy,
+                        const double * const c,
+                        const double * const s);
+
+  void F77DECLARE(SROTG)(double * const da,
+                         double * const db,
+                         double * const c,
+                         double * const s);
+#else
+
+  double F77DECLARE(dasum)(const integer *n, const double* const dx, const integer *incx);
+
+
+  void F77DECLARE(daxpy)(const integer *n, const double * const da, const double * const dx,
+                         const integer *incx, double * const dy, const integer *incy);
+
+  void F77DECLARE(dcopy)(const integer *n,
+                         const double * const dx, const integer *incx,
+                         double * const dy, const integer *incy);
+
+
+  double F77DECLARE(ddot)(const integer *n, const double * const dx, const integer *incx,
+                          const double * const dy, const integer *incy);
+
+  double F77DECLARE(dnrm2)(const integer *n, const double * const dx, const integer *incx);
+
+  void F77DECLARE(drot)(const integer *n, double * const dx, const integer *incx, double * const dy,
+                        const integer *incy, const double * const c, const double * const s);
+
+  void F77DECLARE(drotg)(double * const da, double * const db, double * const c, double * const s);
+
+  void F77DECLARE(dscal)(const integer *n, double * const da, double * const dx, const integer *incx);
+
+  void F77DECLARE(dswap)(const integer *n, double * const dx, const integer *incx, double * const dy,
+                         const integer *incy);
+
+  integer F77DECLARE(idamax)(const integer *n, const double * const dx, const integer *incx);
+
+  float F77DECLARE(sdot)(const integer *n, const float *cx,
+                         const integer *incx, const float *cy, const integer *incy);
+
+  void F77DECLARE(saxpy)(const integer *n, const float *da, const float *dx,
+                         const integer *incx, float *dy, const integer *incy);
+
+  void F77DECLARE(scopy)(const integer *n, float *dx, const integer *incx,
+                         float *dy, const integer *incy);
+
+  float F77DECLARE(sasum)(const integer *n, const float *dx, const integer *incx);
+
+  float F77DECLARE(snrm2)(const integer *n, const float *dx, const integer *incx);
+
+  void F77DECLARE(sscal)(const integer *n, const float *da, float *dx,
+                         const integer *incx);
+
+  integer F77DECLARE(isamax)(const integer *n, const float * const dx, const integer *incx);
+
+  void F77DECLARE(sswap)(const integer *n, float *dx, const integer *incx,
+                         float *dy, integer *incy);
+
+  void F77DECLARE(srot)(const integer *n,
+                        double * const dx,
+                        const integer *incx,
+                        double * const dy,
+                        const integer *incy,
+                        const double * const c,
+                        const double * const s);
+
+  void F77DECLARE(srotg)(double * const da,
+                         double * const db,
+                         double * const c,
+                         double * const s);
+
+#endif
+}
+
+/*! @brief
+ *
+ */
+#ifndef F77_Majuscule
+inline double F77NAME(DASUM)(const integer *n,
+                             const double* const dx,
+                             const integer *incx)
+{
+  return F77NAME(dasum)(n ,dx ,incx);
+}
+
+
+
+/*! @brief
+ *
+ */
+inline void F77NAME(DAXPY)(const integer *n,
+                           const double * const da,
+                           const double * const dx,
+                           const integer *incx,
+                           double * const dy,
+                           const integer *incy)
+{
+  F77NAME(daxpy)(n ,da, dx ,incx, dy, incy);
+}
+
+
+/*! @brief
+ *
+ */
+inline void F77NAME(DCOPY)(const integer *n,
+                           const double * const dx,
+                           const integer *incx,
+                           double * const dy,
+                           const integer *incy)
+{
+  F77NAME(dcopy)(n , dx , incx, dy, incy);
+}
+
+
+
+/*! @brief
+ *
+ */
+inline double F77NAME(DDOT)(const integer *n,
+                            const double * const dx,
+                            const integer *incx,
+                            const double * const dy,
+                            const integer *incy)
+{
+  return F77NAME(ddot)(n , dx , incx, dy, incy);
+}
+
+
+/*! @brief
+ *
+ */
+inline double F77NAME(DNRM2)(const integer *n,
+                             const double * const dx,
+                             const integer *incx)
+{
+  return F77NAME(dnrm2)(n , dx , incx);
+}
+
+
+/*! @brief
+ *
+ */
+inline void F77NAME(DROT)(const integer *n,
+                          double * const dx,
+                          const integer *incx,
+                          double * const dy,
+                          const integer *incy,
+                          const double * const c,
+                          const double * const s)
+{
+  F77NAME(drot)(n , dx , incx, dy, incy, c, s);
+}
+
+
+/*! @brief
+ *
+ */
+inline void F77NAME(DROTG)(double * const da,
+                           double * const db,
+                           double * const c,
+                           double * const s)
+{
+  F77NAME(drotg)(da , db , c, s);
+}
+
+
+/*! @brief
+ *
+ */
+inline void F77NAME(DSCAL)(const integer *n,
+                           double * const da,
+                           double * const dx,
+                           const integer *incx)
+{
+  F77NAME(dscal)(n , da , dx, incx);
+}
+
+
+/*! @brief
+ *
+ */
+inline void F77NAME(DSWAP)(const integer *n,
+                           double * const dx,
+                           const integer *incx,
+                           double * const dy,
+                           const integer *incy)
+{
+  F77NAME(dswap)(n , dx , incx, dy, incy);
+}
+
+
+/*! @brief
+ *
+ */
+inline integer F77NAME(IDAMAX)(const integer *n,
+                               const double * const dx,
+                               const integer *incx)
+{
+  return F77NAME(idamax)(n , dx , incx);
+}
+
+
+/*! @brief
+ *
+ */
+inline float F77NAME(SDOT)(const integer *n,
+                           const float *dx,
+                           const integer *incx,
+                           const float *dy,
+                           const integer *incy)
+{
+  return F77NAME(sdot)(n , dx , incx, dy, incy);
+}
+
+
+/*! @brief
+ *
+ */
+inline void F77NAME(SAXPY)(const integer *n,
+                           const float *da,
+                           const float *dx,
+                           const integer *incx,
+                           float *dy,
+                           const integer *incy)
+{
+  F77NAME(saxpy)(n , da, dx , incx, dy, incy);
+}
+
+
+/*! @brief
+ *
+ */
+inline void F77NAME(SCOPY)(const integer *n,
+                           float *dx,
+                           const integer *incx,
+                           float *dy,
+                           const integer *incy)
+{
+  F77NAME(scopy)(n , dx , incx, dy, incy);
+}
+
+
+/*! @brief
+ *
+ */
+inline float F77NAME(SASUM)(const integer *n,
+                            const float *dx,
+                            const integer *incx)
+{
+  return F77NAME(sasum)(n , dx , incx);
+}
+
+
+/*! @brief
+ *
+ */
+inline float F77NAME(SNRM2)(const integer *n,
+                            const float *dx,
+                            const integer *incx)
+{
+  return F77NAME(snrm2)(n , dx , incx);
+}
+
+
+/*! @brief
+ *
+ */
+inline void F77NAME(SSCAL)(const integer *n,
+                           const float *da,
+                           float *dx,
+                           const integer *incx)
+{
+  F77NAME(sscal)(n , da, dx , incx);
+}
+
+
+/*! @brief
+ *
+ */
+inline integer F77NAME(ISAMAX)(const integer *n,
+                               const float * const dx,
+                               const integer *incx)
+{
+  return F77NAME(isamax)(n , dx , incx);
+}
+
+
+/*! @brief
+ *
+ */
+inline void F77NAME(SSWAP)(const integer *n,
+                           float *dx,
+                           const integer *incx,
+                           float *dy,
+                           integer *incy)
+{
+  F77NAME(sswap)(n , dx , incx, dy, incy);
+}
+
+inline void F77NAME(SROT)(const integer *n,
+                          double * const dx,
+                          const integer *incx,
+                          double * const dy,
+                          const integer *incy,
+                          const double * const c,
+                          const double * const s)
+{
+  F77NAME(srot)(n,dx,incx,dy,incy,c,s);
+}
+
+inline void F77NAME(SROTG)(double * const da,
+                           double * const db,
+                           double * const c,
+                           double * const s)
+{
+  F77NAME(srotg)(da,db,c,s);
+}
+#endif
+
+#ifdef CRAY
+inline double F77NAME(DASUM)(const integer *n,
+                             const double* const dx,
+                             const integer *incx)
+{
+  return F77NAME(SASUM)(n , dx , incx);
+}
+
+
+inline void F77NAME(DAXPY)(const integer *n,
+                           const double * const da,
+                           const double * const dx,
+                           const integer *incx,
+                           double * const dy,
+                           const integer *incy)
+{
+  F77NAME(SAXPY)(n,da,dx,incx,dy,incy);
+}
+
+inline void F77NAME(DCOPY)(const integer *n,
+                           const double * const dx,
+                           const integer *incx,
+                           double * const dy,
+                           const integer *incy)
+{
+  F77NAME(SCOPY)(n,dx,incx,dy,incy);
+}
+
+inline double F77NAME(DDOT)(const integer *n,
+                            const double * const dx,
+                            const integer *incx,
+                            const double * const dy,
+                            const integer *incy)
+{
+  return F77NAME(SDOT)(n,dx,incx,dy,incy);
+}
+
+inline double F77NAME(DNRM2)(const integer *n,
+                             const double * const dx,
+                             const integer *incx)
+{
+  return F77NAME(SNRM2)(n,dx,incx);
+}
+
+inline void F77NAME(DROT)(const integer *n,
+                          double * const dx,
+                          const integer *incx,
+                          double * const dy,
+                          const integer *incy,
+                          const double * const c,
+                          const double * const s)
+{
+  F77NAME(SROT)(n,dx,incx,dy,incy,c,s);
+}
+
+inline void F77NAME(DROTG)(double * const da,
+                           double * const db,
+                           double * const c,
+                           double * const s)
+{
+  F77NAME(SROTG)(da,db,c,s);
+}
+
+inline void F77NAME(DSCAL)(const integer *n,
+                           double * const da,
+                           double * const dx,
+                           const integer *incx)
+{
+  F77NAME(SSCAL)(n,da,dx,incx);
+}
+
+inline void F77NAME(DSWAP)(const integer *n,
+                           double * const dx,
+                           const integer *incx,
+                           double * const dy,
+                           const integer *incy)
+{
+  F77NAME(SSWAP)(n,dx,incx,dy,incy);
+}
+
+inline integer F77NAME(IDAMAX)(const integer *n,
+                               const double * const dx,
+                               const integer *incx)
+{
+  return F77NAME(ISAMAX)(n,dx,incx);
+}
+#endif  // CRAY
+
+#else //_NO_BLAS1_
+
+/*! @brief
+ *
+ */
+static inline void ERREUR(const char* const ch)
+{
+  //        Cerr << ch << finl;
+  exit();
+}
+
+/*! @brief
+ *
+ */
+inline double F77NAME(DASUM)(const integer *n,
+                             const double* const dx,
+                             const integer *incx)
+{
+  double somme=0;
+  for(integer i=0; i<*n; i+=*incx)
+    somme+=dx[i];
+  return somme;
+}
+
+
+/*! @brief
+ *
+ */
+inline void F77NAME(DAXPY)(const integer *n,
+                           const double * const da,
+                           const double * const dx,
+                           const integer *incx,
+                           double * const dy,
+                           const integer *incy)
+{
+  int j =0;
+  for(int i=0; i<*n; i+=*incx)
+    {
+      dy[i]+=*da*dx[j];
+      j+=*incy;
+    }
+}
+
+/*! @brief
+ *
+ */
+inline void F77NAME(DCOPY)(const integer *n,
+                           const double * const dx,
+                           const integer *incx,
+                           double * const dy,
+                           const integer *incy)
+{
+  int j=0;
+  for(int i=0; i<*n; i+=*incx)
+    {
+      dy[i]=dx[j];
+      j+=*incy;
+    }
+
+}
+
+
+/*! @brief
+ *
+ */
+inline double F77NAME(DDOT)(const integer *n,
+                            const double * const dx,
+                            const integer *incx,
+                            const double * const dy,
+                            const integer *incy)
+{
+  int j=0;
+  double psc=0;
+  for(int i=0; i<*n; i+=*incx)
+    {
+      psc+=dx[i]*dy[j];
+      j+=*incy;
+    }
+  return psc;
+}
+
+/*! @brief
+ *
+ */
+inline double F77NAME(DNRM2)(const integer *n,
+                             const double * const dx,
+                             const integer *incx)
+{
+  integer un=1;
+  return sqrt(F77NAME(DDOT)(n, dx, &un, dx, &un));
+}
+
+/*! @brief
+ *
+ */
+inline void F77NAME(DROT)(const integer *n,
+                          double * const dx,
+                          const integer *incx,
+                          double * const dy,
+                          const integer *incy,
+                          const double * const c,
+                          const double * const s)
+{
+  ERREUR("DROT : pas code!");
+}
+
+/*! @brief
+ *
+ */
+inline void F77NAME(DROTG)(double * const da,
+                           double * const db,
+                           double * const c,
+                           double * const s)
+{
+  ERREUR("DROTG : pas code!");
+}
+
+/*! @brief
+ *
+ */
+inline void F77NAME(DSCAL)(const integer *n,
+                           double * const da,
+                           double * const dx,
+                           const integer *incx)
+{
+  for(int i=0; i<*n; i+= *incx)
+    dx[i]*=*da;
+}
+
+/*! @brief
+ *
+ */
+inline void F77NAME(DSWAP)(const integer *n,
+                           double * const dx,
+                           const integer *incx,
+                           double * const dy,
+                           const integer *incy)
+{
+  int j=0;
+  double tmp;
+  for(int i=0; i<*n; i+= *incx)
+    {
+      tmp=dx[i];
+      dx[i]=dy[j];
+      dy[j]=tmp;
+      j+=*incy;
+    }
+
+}
+
+/*! @brief
+ *
+ */
+inline integer F77NAME(IDAMAX)(const integer *n,
+                               const double * const dx,
+                               const integer *incx)
+{
+  int imax=0;
+  double themax=dx[0];
+  for(int i=1; i<*n; i+=*incx)
+    if(dx[i]>themax)
+      {
+        imax=i;
+        themax=dx[i];
+      }
+  return imax;
+}
+
+/*! @brief
+ *
+ */
+inline float F77NAME(SDOT)(const integer *n,
+                           const float *dx,
+                           const integer *incx,
+                           const float *dy,
+                           const integer *incy)
+{
+  ERREUR("SDOT : pas code!");
+  return 0;
+}
+
+/*! @brief
+ *
+ */
+inline void F77NAME(SAXPY)(const integer *n,
+                           const float *da,
+                           const float *dx,
+                           const integer *incx,
+                           float *dy,
+                           const integer *incy)
+{
+  ERREUR("SAXPY : pas code!");
+}
+
+/*! @brief
+ *
+ */
+inline void F77NAME(SCOPY)(const integer *n,
+                           float *dx,
+                           const integer *incx,
+                           float *dy,
+                           const integer *incy)
+{
+  ERREUR("SCOPY : pas code!");
+}
+
+/*! @brief
+ *
+ */
+inline float F77NAME(SASUM)(const integer *n,
+                            const float *dx,
+                            const integer *incx)
+{
+  ERREUR("SASUM : pas code!");
+  return 0;
+}
+
+/*! @brief
+ *
+ */
+inline float F77NAME(SNRM2)(const integer *n,
+                            const float *dx,
+                            const integer *incx)
+{
+  ERREUR("SNRM2 : pas code!");
+  return 0;
+}
+
+/*! @brief
+ *
+ */
+inline void F77NAME(SSCAL)(const integer *n,
+                           const float *da,
+                           float *dx,
+                           const integer *incx)
+{
+  ERREUR("SSCAL : pas code!");
+}
+
+/*! @brief
+ *
+ */
+inline integer F77NAME(ISAMAX)(const integer *n,
+                               const float * const dx,
+                               const integer *incx)
+{
+  ERREUR("ISAMAX : pas code!");
+  return 0;
+}
+
+/*! @brief
+ *
+ */
+inline void F77NAME(SSWAP)(const integer *n,
+                           float *dx,
+                           const integer *incx,
+                           float *dy,
+                           integer *incy)
+{
+  ERREUR("SSWAP : pas code!");
+}
+#endif //_NO_BLAS1_
+
+#endif //_BLAS1_H_
+
diff --git a/Utilities/VisItBridge/databases/readers/Lata/communications_array.h b/Utilities/VisItBridge/databases/readers/Lata/communications_array.h
new file mode 100644
index 00000000..3895b809
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/communications_array.h
@@ -0,0 +1,136 @@
+/****************************************************************************
+* Copyright (c) 2025, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef communications_array_included
+#define communications_array_included
+
+#include <type_traits>
+#include <Comm_Group.h>
+#include <PE_Groups.h>
+#include <arch.h>
+
+// Ces methodes sont volontairement separees de communications.h car plus dangereuses a l'usage.
+// Les tableaux passes en parametres doivent absolument avoir au moins n cases et n doit etre
+// identique sur tous les processeurs qui communiquent entre eux.
+
+// Attention: le template ne marche que pour les types simples (pas Objet_U !)
+// On ne passe pas par un buffer Entree / Sortie mais on envoie directement le tableau sous sa forme binaire.
+// Un seul message envoye, sauf en mode check() ou on envoie aussi la taille pour verifier.
+template<typename _TYPE_> std::enable_if_t<std::is_arithmetic<_TYPE_>::value,bool >
+inline envoyer_array(const _TYPE_ *objet, int n, int source, int cible, int canal)
+{
+  const Comm_Group& grp = PE_Groups::current_group();
+  const int moi = grp.rank();
+  if (moi == cible)
+    return false;
+
+  if (source != moi && source != -1)
+    return false;
+
+  const char *data = (const char*) objet;
+  const int sz = (int)sizeof(_TYPE_) * n;
+  if (cible < 0)
+    {
+      const int nbproc = grp.nproc();
+      for (int i = 0; i < nbproc; i++)
+        {
+          if (i != moi)
+            {
+              // En mode check, on verifie que n est bien le meme sur l'expediteur et le recepteur
+              if (grp.check_enabled())
+                grp.send(i, &sz, (int)sizeof(int), canal);
+              if (sz > 0)
+                grp.send(i, data, sz, canal);
+            }
+        }
+    }
+  else
+    {
+      if (grp.check_enabled())
+        grp.send(cible, &sz, (int)sizeof(int), canal);
+      if (sz > 0)
+        grp.send(cible, data, sz, canal);
+    }
+  return true;
+}
+
+#ifndef INT_is_64_
+inline bool envoyer_array(const long *t, int n, int source, int cible, int canal)
+{
+  return envoyer_array<long>(t,n,source,cible,canal);
+}
+#endif
+
+template<typename _TYPE_> std::enable_if_t<std::is_arithmetic<_TYPE_>::value,bool >
+inline recevoir_array(const _TYPE_ *objet, int n, int source, int cible, int canal)
+{
+  const Comm_Group& grp = PE_Groups::current_group();
+  const int moi = grp.rank();
+  if (moi == source)
+    return false;
+
+  if (cible != moi && cible != -1)
+    return false;
+
+  const int sz = (int)sizeof(_TYPE_) * n;
+  if (grp.check_enabled())
+    {
+      int sz_check;
+      grp.recv(source, &sz_check, (int)sizeof(int), canal);
+      if (sz_check != sz)
+        {
+          Cerr << "Fatal error in template<typename _TYPE_> int recevoir_array : incorrect size\n" << " sent=" << sz_check << " expected=" << sz << finl;
+          Process::exit();
+        }
+    }
+  char *data = (char*) objet;
+  if (sz > 0)
+    grp.recv(source, data, sz, canal);
+  return true;
+}
+
+#ifndef INT_is_64_
+inline bool recevoir_array(const long *t, int n, int source, int cible, int canal)
+{
+  return recevoir_array<long>(t, n, source, cible, canal);
+}
+#endif
+
+template<typename _TYPE_> std::enable_if_t<std::is_arithmetic<_TYPE_>::value,bool >
+inline envoyer_broadcast_array(_TYPE_ *objet, int n, int source)
+{
+  const Comm_Group& grp = PE_Groups::current_group();
+  if (grp.check_enabled())
+    {
+      int copie_n = n;
+      grp.broadcast(&copie_n, (int)sizeof(int), source);
+      if (copie_n != n)
+        {
+          Cerr << "Error in template<typename _TYPE_> envoyer_broadcast_array !" << finl;
+          Process::exit();
+        }
+    }
+  grp.broadcast(objet, (int)sizeof(_TYPE_) * n, source);
+  return true;
+}
+
+#ifndef INT_is_64_
+inline bool envoyer_broadcast_array(long *t, int n, int source)
+{
+  return envoyer_broadcast_array<long>(t, n, source);
+}
+#endif
+
+#endif /* communications_array_included */
diff --git a/Utilities/VisItBridge/databases/readers/Lata/generique.h b/Utilities/VisItBridge/databases/readers/Lata/generique.h
new file mode 100644
index 00000000..cb7ee47e
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/generique.h
@@ -0,0 +1,76 @@
+/****************************************************************************
+* Copyright (c) 2022, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+
+#ifndef generique_inclus
+
+#define generique_inclus
+
+/* macros to paste tokens together to form new names */
+/* 4.2BSD and System V cpp's have different mechanisms for
+   pasting tokens together, but 4.3BSD agrees with System V.
+   ANSI C has defined a new way.
+*/
+
+#if defined(__STDC__) || defined (__STDCPP__) || defined (MICROSOFT)
+/* ANSI C preprocessors will not expand the arguments to a macro;
+ * so we need to add a level of indirection to allow macro expansion of
+ * arguments.  (Reiser preprocessors allowed the first arg to be expanded;
+ * this method will allow both to be expanded, which is better than none.)
+ */
+#define name2(a,b)      _name2_aux(a,b)
+#define _name2_aux(a,b)      a##b
+#define name3(a,b,c)    _name3_aux(a,b,c)
+#define _name3_aux(a,b,c)    a##b##c
+#define name4(a,b,c,d)  _name4_aux(a,b,c,d)
+#define _name4_aux(a,b,c,d)  a##b##c##d
+
+#else
+
+#ifdef pyr
+/*
+ * Pyramid run SVR3, but its cpp uses the BSD4.2 version of argument pasting
+ */
+#define name2(a,b) a                                \
+  b
+#define name3(a,b,c) a                                \
+  b                                                \
+  c
+#define name4(a,b,c,d) a                        \
+  b                                                \
+  c                                                \
+  d
+#else
+/*
+ * Most non-ANSI cpps use the "null comment" method
+ */
+#define name2(a,b)        a/**/b
+#define name3(a,b,c)        a/**/b/**/c
+#define name4(a,b,c,d)        a/**/b/**/c/**/d
+#endif
+
+#endif
+
+#define declare(a,t) name2(declare_,a)(t)
+#define implemente(a,t) name2(implemente_,a)(t)
+
+// GF nouvelle macro pour fabriquer des vrais noms pour les listes, les Deriv, les Ref,
+#ifdef _COMPILE_AVEC_GCC_
+#define string_macro_trio(a,b) _inter_name(b)
+#define _inter_name(a) #a
+#else
+#define string_macro_trio(a,b) a
+#endif
+#endif
diff --git a/Utilities/VisItBridge/databases/readers/Lata/kokkos++.h b/Utilities/VisItBridge/databases/readers/Lata/kokkos++.h
new file mode 100644
index 00000000..9aa78c87
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/kokkos++.h
@@ -0,0 +1,45 @@
+/****************************************************************************
+* Copyright (c) 2024, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+
+#ifdef __NVCOMPILER
+#pragma diag_suppress 177
+#pragma diag_suppress 47 /* warning cuda */
+#endif
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wshadow"
+#pragma GCC diagnostic ignored "-Wconversion"
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+#pragma GCC diagnostic ignored "-Wfloat-conversion"
+
+#if __GNUC__ > 5 || __clang_major__ > 10
+#pragma GCC diagnostic ignored "-Wsuggest-override"
+#endif
+
+#if defined(NO_HIP) || defined(LATATOOLS)
+#undef KOKKOS
+#else
+#define KOKKOS
+#include <Kokkos_Core.hpp>
+#include <Kokkos_DualView.hpp>
+#endif
+
+#undef _KOKKOS_AVX
+
+#pragma GCC diagnostic pop
+#ifdef __NVCOMPILER
+#pragma diag_warning 177
+#pragma diag_warning 47
+#endif
+
diff --git a/Utilities/VisItBridge/databases/readers/Lata/span.hpp b/Utilities/VisItBridge/databases/readers/Lata/span.hpp
new file mode 100644
index 00000000..5ad83864
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/span.hpp
@@ -0,0 +1,614 @@
+/*
+This is an implementation of C++20's std::span
+http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/n4820.pdf
+*/
+
+//          Copyright Tristan Brindle 2018.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file ../../LICENSE_1_0.txt or copy at
+//          https://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef TCB_SPAN_HPP_INCLUDED
+#define TCB_SPAN_HPP_INCLUDED
+
+#include <array>
+#include <cstddef>
+#include <cstdint>
+#include <type_traits>
+#include <exception>
+
+#ifndef TCB_SPAN_NO_EXCEPTIONS
+// Attempt to discover whether we're being compiled with exception support
+#if !(defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND))
+#define TCB_SPAN_NO_EXCEPTIONS
+#endif
+#endif
+
+#ifndef TCB_SPAN_NO_EXCEPTIONS
+#include <cstdio>
+#include <stdexcept>
+#endif
+
+// Various feature test macros
+
+#ifndef TCB_SPAN_NAMESPACE_NAME
+#define TCB_SPAN_NAMESPACE_NAME tcb
+#endif
+
+#if __cplusplus >= 201703L || (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)
+#define TCB_SPAN_HAVE_CPP17
+#endif
+
+#if __cplusplus >= 201402L || (defined(_MSVC_LANG) && _MSVC_LANG >= 201402L)
+#define TCB_SPAN_HAVE_CPP14
+#endif
+
+namespace TCB_SPAN_NAMESPACE_NAME {
+
+// Establish default contract checking behavior
+#if !defined(TCB_SPAN_THROW_ON_CONTRACT_VIOLATION) &&                          \
+    !defined(TCB_SPAN_TERMINATE_ON_CONTRACT_VIOLATION) &&                      \
+    !defined(TCB_SPAN_NO_CONTRACT_CHECKING)
+#if defined(NDEBUG) || !defined(TCB_SPAN_HAVE_CPP14)
+#define TCB_SPAN_NO_CONTRACT_CHECKING
+#else
+#define TCB_SPAN_TERMINATE_ON_CONTRACT_VIOLATION
+#endif
+#endif
+
+#if defined(TCB_SPAN_THROW_ON_CONTRACT_VIOLATION)
+struct contract_violation_error : std::logic_error {
+    explicit contract_violation_error(const char* msg) : std::logic_error(msg)
+    {}
+};
+
+inline void contract_violation(const char* msg)
+{
+    throw contract_violation_error(msg);
+}
+
+#elif defined(TCB_SPAN_TERMINATE_ON_CONTRACT_VIOLATION)
+[[noreturn]] inline void contract_violation(const char* /*unused*/)
+{
+    std::terminate();
+}
+#endif
+
+#if !defined(TCB_SPAN_NO_CONTRACT_CHECKING)
+#define TCB_SPAN_STRINGIFY(cond) #cond
+#define TCB_SPAN_EXPECT(cond)                                                  \
+    cond ? (void) 0 : contract_violation("Expected " TCB_SPAN_STRINGIFY(cond))
+#else
+#define TCB_SPAN_EXPECT(cond)
+#endif
+
+#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_inline_variables)
+#define TCB_SPAN_INLINE_VAR inline
+#else
+#define TCB_SPAN_INLINE_VAR
+#endif
+
+#if defined(TCB_SPAN_HAVE_CPP14) ||                                            \
+    (defined(__cpp_constexpr) && __cpp_constexpr >= 201304)
+#define TCB_SPAN_HAVE_CPP14_CONSTEXPR
+#endif
+
+#if defined(TCB_SPAN_HAVE_CPP14_CONSTEXPR)
+#define TCB_SPAN_CONSTEXPR14 constexpr
+#else
+#define TCB_SPAN_CONSTEXPR14
+#endif
+
+#if defined(TCB_SPAN_HAVE_CPP14_CONSTEXPR) &&                                  \
+    (!defined(_MSC_VER) || _MSC_VER > 1900)
+#define TCB_SPAN_CONSTEXPR_ASSIGN constexpr
+#else
+#define TCB_SPAN_CONSTEXPR_ASSIGN
+#endif
+
+#if defined(TCB_SPAN_NO_CONTRACT_CHECKING)
+#define TCB_SPAN_CONSTEXPR11 constexpr
+#else
+#define TCB_SPAN_CONSTEXPR11 TCB_SPAN_CONSTEXPR14
+#endif
+
+#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_deduction_guides)
+#define TCB_SPAN_HAVE_DEDUCTION_GUIDES
+#endif
+
+#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_lib_byte)
+#define TCB_SPAN_HAVE_STD_BYTE
+#endif
+
+#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_lib_array_constexpr)
+#define TCB_SPAN_HAVE_CONSTEXPR_STD_ARRAY_ETC
+#endif
+
+#if defined(TCB_SPAN_HAVE_CONSTEXPR_STD_ARRAY_ETC)
+#define TCB_SPAN_ARRAY_CONSTEXPR constexpr
+#else
+#define TCB_SPAN_ARRAY_CONSTEXPR
+#endif
+
+#ifdef TCB_SPAN_HAVE_STD_BYTE
+using byte = std::byte;
+#else
+using byte = unsigned char;
+#endif
+
+#if defined(TCB_SPAN_HAVE_CPP17)
+#define TCB_SPAN_NODISCARD [[nodiscard]]
+#else
+#define TCB_SPAN_NODISCARD
+#endif
+
+TCB_SPAN_INLINE_VAR constexpr std::size_t dynamic_extent = SIZE_MAX;
+
+template <typename ElementType, std::size_t Extent = dynamic_extent>
+class span;
+
+namespace detail {
+
+template <typename E, std::size_t S>
+struct span_storage {
+    constexpr span_storage() noexcept = default;
+
+    constexpr span_storage(E* p_ptr, std::size_t /*unused*/) noexcept
+       : ptr(p_ptr)
+    {}
+
+    E* ptr = nullptr;
+    static constexpr std::size_t size = S;
+};
+
+template <typename E>
+struct span_storage<E, dynamic_extent> {
+    constexpr span_storage() noexcept = default;
+
+    constexpr span_storage(E* p_ptr, std::size_t p_size) noexcept
+        : ptr(p_ptr), size(p_size)
+    {}
+
+    E* ptr = nullptr;
+    std::size_t size = 0;
+};
+
+// Reimplementation of C++17 std::size() and std::data()
+#if defined(TCB_SPAN_HAVE_CPP17) ||                                            \
+    defined(__cpp_lib_nonmember_container_access)
+using std::data;
+using std::size;
+#else
+template <class C>
+constexpr auto size(const C& c) -> decltype(c.size())
+{
+    return c.size();
+}
+
+template <class T, std::size_t N>
+constexpr std::size_t size(const T (&)[N]) noexcept
+{
+    return N;
+}
+
+template <class C>
+constexpr auto data(C& c) -> decltype(c.data())
+{
+    return c.data();
+}
+
+template <class C>
+constexpr auto data(const C& c) -> decltype(c.data())
+{
+    return c.data();
+}
+
+template <class T, std::size_t N>
+constexpr T* data(T (&array)[N]) noexcept
+{
+    return array;
+}
+
+template <class E>
+constexpr const E* data(std::initializer_list<E> il) noexcept
+{
+    return il.begin();
+}
+#endif // TCB_SPAN_HAVE_CPP17
+
+#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_lib_void_t)
+using std::void_t;
+#else
+template <typename...>
+using void_t = void;
+#endif
+
+template <typename T>
+using uncvref_t =
+    typename std::remove_cv<typename std::remove_reference<T>::type>::type;
+
+template <typename>
+struct is_span : std::false_type {};
+
+template <typename T, std::size_t S>
+struct is_span<span<T, S>> : std::true_type {};
+
+template <typename>
+struct is_std_array : std::false_type {};
+
+template <typename T, std::size_t N>
+struct is_std_array<std::array<T, N>> : std::true_type {};
+
+template <typename, typename = void>
+struct has_size_and_data : std::false_type {};
+
+template <typename T>
+struct has_size_and_data<T, void_t<decltype(detail::size(std::declval<T>())),
+                                   decltype(detail::data(std::declval<T>()))>>
+    : std::true_type {};
+
+template <typename C, typename U = uncvref_t<C>>
+struct is_container {
+    static constexpr bool value =
+        !is_span<U>::value && !is_std_array<U>::value &&
+        !std::is_array<U>::value && has_size_and_data<C>::value;
+};
+
+template <typename T>
+using remove_pointer_t = typename std::remove_pointer<T>::type;
+
+template <typename, typename, typename = void>
+struct is_container_element_type_compatible : std::false_type {};
+
+template <typename T, typename E>
+struct is_container_element_type_compatible<
+    T, E,
+    typename std::enable_if<
+        !std::is_same<
+            typename std::remove_cv<decltype(detail::data(std::declval<T>()))>::type,
+            void>::value &&
+        std::is_convertible<
+            remove_pointer_t<decltype(detail::data(std::declval<T>()))> (*)[],
+            E (*)[]>::value
+        >::type>
+    : std::true_type {};
+
+template <typename, typename = size_t>
+struct is_complete : std::false_type {};
+
+template <typename T>
+struct is_complete<T, decltype(sizeof(T))> : std::true_type {};
+
+} // namespace detail
+
+template <typename ElementType, std::size_t Extent>
+class span {
+    static_assert(std::is_object<ElementType>::value,
+                  "A span's ElementType must be an object type (not a "
+                  "reference type or void)");
+    static_assert(detail::is_complete<ElementType>::value,
+                  "A span's ElementType must be a complete type (not a forward "
+                  "declaration)");
+    static_assert(!std::is_abstract<ElementType>::value,
+                  "A span's ElementType cannot be an abstract class type");
+
+    using storage_type = detail::span_storage<ElementType, Extent>;
+
+public:
+    // constants and types
+    using element_type = ElementType;
+    using value_type = typename std::remove_cv<ElementType>::type;
+    using size_type = std::size_t;
+    using difference_type = std::ptrdiff_t;
+    using pointer = element_type*;
+    using const_pointer = const element_type*;
+    using reference = element_type&;
+    using const_reference = const element_type&;
+    using iterator = pointer;
+    using reverse_iterator = std::reverse_iterator<iterator>;
+
+    static constexpr size_type extent = Extent;
+
+    // [span.cons], span constructors, copy, assignment, and destructor
+    template <
+        std::size_t E = Extent,
+        typename std::enable_if<(E == dynamic_extent || E <= 0), int>::type = 0>
+    constexpr span() noexcept
+    {}
+
+    TCB_SPAN_CONSTEXPR11 span(pointer ptr, size_type count)
+        : storage_(ptr, count)
+    {
+        TCB_SPAN_EXPECT(extent == dynamic_extent || count == extent);
+    }
+
+    TCB_SPAN_CONSTEXPR11 span(pointer first_elem, pointer last_elem)
+        : storage_(first_elem, last_elem - first_elem)
+    {
+        TCB_SPAN_EXPECT(extent == dynamic_extent ||
+                        last_elem - first_elem ==
+                            static_cast<std::ptrdiff_t>(extent));
+    }
+
+    template <std::size_t N, std::size_t E = Extent,
+              typename std::enable_if<
+                  (E == dynamic_extent || N == E) &&
+                      detail::is_container_element_type_compatible<
+                          element_type (&)[N], ElementType>::value,
+                  int>::type = 0>
+    constexpr span(element_type (&arr)[N]) noexcept : storage_(arr, N)
+    {}
+
+    template <std::size_t N, std::size_t E = Extent,
+              typename std::enable_if<
+                  (E == dynamic_extent || N == E) &&
+                      detail::is_container_element_type_compatible<
+                          std::array<value_type, N>&, ElementType>::value,
+                  int>::type = 0>
+    TCB_SPAN_ARRAY_CONSTEXPR span(std::array<value_type, N>& arr) noexcept
+        : storage_(arr.data(), N)
+    {}
+
+    template <std::size_t N, std::size_t E = Extent,
+              typename std::enable_if<
+                  (E == dynamic_extent || N == E) &&
+                      detail::is_container_element_type_compatible<
+                          const std::array<value_type, N>&, ElementType>::value,
+                  int>::type = 0>
+    TCB_SPAN_ARRAY_CONSTEXPR span(const std::array<value_type, N>& arr) noexcept
+        : storage_(arr.data(), N)
+    {}
+
+    template <
+        typename Container, std::size_t E = Extent,
+        typename std::enable_if<
+            E == dynamic_extent && detail::is_container<Container>::value &&
+                detail::is_container_element_type_compatible<
+                    Container&, ElementType>::value,
+            int>::type = 0>
+    constexpr span(Container& cont)
+        : storage_(detail::data(cont), detail::size(cont))
+    {}
+
+    template <
+        typename Container, std::size_t E = Extent,
+        typename std::enable_if<
+            E == dynamic_extent && detail::is_container<Container>::value &&
+                detail::is_container_element_type_compatible<
+                    const Container&, ElementType>::value,
+            int>::type = 0>
+    constexpr span(const Container& cont)
+        : storage_(detail::data(cont), detail::size(cont))
+    {}
+
+    constexpr span(const span& other) noexcept = default;
+
+    template <typename OtherElementType, std::size_t OtherExtent,
+              typename std::enable_if<
+                  (Extent == OtherExtent || Extent == dynamic_extent) &&
+                      std::is_convertible<OtherElementType (*)[],
+                                          ElementType (*)[]>::value,
+                  int>::type = 0>
+    constexpr span(const span<OtherElementType, OtherExtent>& other) noexcept
+        : storage_(other.data(), other.size())
+    {}
+
+    ~span() noexcept = default;
+
+    TCB_SPAN_CONSTEXPR_ASSIGN span&
+    operator=(const span& other) noexcept = default;
+
+    // [span.sub], span subviews
+    template <std::size_t Count>
+    TCB_SPAN_CONSTEXPR11 span<element_type, Count> first() const
+    {
+        TCB_SPAN_EXPECT(Count <= size());
+        return {data(), Count};
+    }
+
+    template <std::size_t Count>
+    TCB_SPAN_CONSTEXPR11 span<element_type, Count> last() const
+    {
+        TCB_SPAN_EXPECT(Count <= size());
+        return {data() + (size() - Count), Count};
+    }
+
+    template <std::size_t Offset, std::size_t Count = dynamic_extent>
+    using subspan_return_t =
+        span<ElementType, Count != dynamic_extent
+                              ? Count
+                              : (Extent != dynamic_extent ? Extent - Offset
+                                                          : dynamic_extent)>;
+
+    template <std::size_t Offset, std::size_t Count = dynamic_extent>
+    TCB_SPAN_CONSTEXPR11 subspan_return_t<Offset, Count> subspan() const
+    {
+        TCB_SPAN_EXPECT(Offset <= size() &&
+                        (Count == dynamic_extent || Offset + Count <= size()));
+        return {data() + Offset,
+                Count != dynamic_extent ? Count : size() - Offset};
+    }
+
+    TCB_SPAN_CONSTEXPR11 span<element_type, dynamic_extent>
+    first(size_type count) const
+    {
+        TCB_SPAN_EXPECT(count <= size());
+        return {data(), count};
+    }
+
+    TCB_SPAN_CONSTEXPR11 span<element_type, dynamic_extent>
+    last(size_type count) const
+    {
+        TCB_SPAN_EXPECT(count <= size());
+        return {data() + (size() - count), count};
+    }
+
+    TCB_SPAN_CONSTEXPR11 span<element_type, dynamic_extent>
+    subspan(size_type offset, size_type count = dynamic_extent) const
+    {
+        TCB_SPAN_EXPECT(offset <= size() &&
+                        (count == dynamic_extent || offset + count <= size()));
+        return {data() + offset,
+                count == dynamic_extent ? size() - offset : count};
+    }
+
+    // [span.obs], span observers
+    constexpr size_type size() const noexcept { return storage_.size; }
+
+    constexpr size_type size_bytes() const noexcept
+    {
+        return size() * sizeof(element_type);
+    }
+
+    TCB_SPAN_NODISCARD constexpr bool empty() const noexcept
+    {
+        return size() == 0;
+    }
+
+    // [span.elem], span element access
+    TCB_SPAN_CONSTEXPR11 reference operator[](size_type idx) const
+    {
+        TCB_SPAN_EXPECT(idx < size());
+        return *(data() + idx);
+    }
+
+    TCB_SPAN_CONSTEXPR11 reference front() const
+    {
+        TCB_SPAN_EXPECT(!empty());
+        return *data();
+    }
+
+    TCB_SPAN_CONSTEXPR11 reference back() const
+    {
+        TCB_SPAN_EXPECT(!empty());
+        return *(data() + (size() - 1));
+    }
+
+    constexpr pointer data() const noexcept { return storage_.ptr; }
+
+    // [span.iterators], span iterator support
+    constexpr iterator begin() const noexcept { return data(); }
+
+    constexpr iterator end() const noexcept { return data() + size(); }
+
+    TCB_SPAN_ARRAY_CONSTEXPR reverse_iterator rbegin() const noexcept
+    {
+        return reverse_iterator(end());
+    }
+
+    TCB_SPAN_ARRAY_CONSTEXPR reverse_iterator rend() const noexcept
+    {
+        return reverse_iterator(begin());
+    }
+
+private:
+    storage_type storage_{};
+};
+
+#ifdef TCB_SPAN_HAVE_DEDUCTION_GUIDES
+
+/* Deduction Guides */
+template <class T, size_t N>
+span(T (&)[N])->span<T, N>;
+
+template <class T, size_t N>
+span(std::array<T, N>&)->span<T, N>;
+
+template <class T, size_t N>
+span(const std::array<T, N>&)->span<const T, N>;
+
+template <class Container>
+span(Container&)->span<typename Container::value_type>;
+
+template <class Container>
+span(const Container&)->span<const typename Container::value_type>;
+
+#endif // TCB_HAVE_DEDUCTION_GUIDES
+
+template <typename ElementType, std::size_t Extent>
+constexpr span<ElementType, Extent>
+make_span(span<ElementType, Extent> s) noexcept
+{
+    return s;
+}
+
+template <typename T, std::size_t N>
+constexpr span<T, N> make_span(T (&arr)[N]) noexcept
+{
+    return {arr};
+}
+
+template <typename T, std::size_t N>
+TCB_SPAN_ARRAY_CONSTEXPR span<T, N> make_span(std::array<T, N>& arr) noexcept
+{
+    return {arr};
+}
+
+template <typename T, std::size_t N>
+TCB_SPAN_ARRAY_CONSTEXPR span<const T, N>
+make_span(const std::array<T, N>& arr) noexcept
+{
+    return {arr};
+}
+
+template <typename Container>
+constexpr span<typename Container::value_type> make_span(Container& cont)
+{
+    return {cont};
+}
+
+template <typename Container>
+constexpr span<const typename Container::value_type>
+make_span(const Container& cont)
+{
+    return {cont};
+}
+
+template <typename ElementType, std::size_t Extent>
+span<const byte, ((Extent == dynamic_extent) ? dynamic_extent
+                                             : sizeof(ElementType) * Extent)>
+as_bytes(span<ElementType, Extent> s) noexcept
+{
+    return {reinterpret_cast<const byte*>(s.data()), s.size_bytes()};
+}
+
+template <
+    class ElementType, size_t Extent,
+    typename std::enable_if<!std::is_const<ElementType>::value, int>::type = 0>
+span<byte, ((Extent == dynamic_extent) ? dynamic_extent
+                                       : sizeof(ElementType) * Extent)>
+as_writable_bytes(span<ElementType, Extent> s) noexcept
+{
+    return {reinterpret_cast<byte*>(s.data()), s.size_bytes()};
+}
+
+template <std::size_t N, typename E, std::size_t S>
+constexpr auto get(span<E, S> s) -> decltype(s[N])
+{
+    return s[N];
+}
+
+} // namespace TCB_SPAN_NAMESPACE_NAME
+
+namespace std {
+
+template <typename ElementType, size_t Extent>
+class tuple_size<TCB_SPAN_NAMESPACE_NAME::span<ElementType, Extent>>
+    : public integral_constant<size_t, Extent> {};
+
+template <typename ElementType>
+class tuple_size<TCB_SPAN_NAMESPACE_NAME::span<
+    ElementType, TCB_SPAN_NAMESPACE_NAME::dynamic_extent>>; // not defined
+
+template <size_t I, typename ElementType, size_t Extent>
+class tuple_element<I, TCB_SPAN_NAMESPACE_NAME::span<ElementType, Extent>> {
+public:
+    static_assert(Extent != TCB_SPAN_NAMESPACE_NAME::dynamic_extent &&
+                      I < Extent,
+                  "");
+    using type = ElementType;
+};
+
+} // end namespace std
+
+#endif // TCB_SPAN_HPP_INCLUDED
diff --git a/Utilities/VisItBridge/databases/readers/Lata/stat_counters.h b/Utilities/VisItBridge/databases/readers/Lata/stat_counters.h
new file mode 100644
index 00000000..6b9d7d20
--- /dev/null
+++ b/Utilities/VisItBridge/databases/readers/Lata/stat_counters.h
@@ -0,0 +1,76 @@
+/****************************************************************************
+* Copyright (c) 2023, CEA
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*****************************************************************************/
+#include <Statistiques.h>
+
+extern void print_statistics_analyse(const char * message, int mode_append);
+extern void declare_stat_counters();
+extern Stat_Counter_Id mpi_sendrecv_counter_;
+extern Stat_Counter_Id mpi_send_counter_;
+extern Stat_Counter_Id mpi_recv_counter_;
+extern Stat_Counter_Id mpi_bcast_counter_;
+extern Stat_Counter_Id mpi_alltoall_counter_;
+extern Stat_Counter_Id mpi_allgather_counter_;
+extern Stat_Counter_Id mpi_gather_counter_;
+extern Stat_Counter_Id mpi_partialsum_counter_;
+extern Stat_Counter_Id mpi_sumdouble_counter_;
+extern Stat_Counter_Id mpi_mindouble_counter_;
+extern Stat_Counter_Id mpi_maxdouble_counter_;
+extern Stat_Counter_Id mpi_sumfloat_counter_;
+extern Stat_Counter_Id mpi_minfloat_counter_;
+extern Stat_Counter_Id mpi_maxfloat_counter_;
+extern Stat_Counter_Id mpi_sumint_counter_;
+extern Stat_Counter_Id mpi_minint_counter_;
+extern Stat_Counter_Id mpi_maxint_counter_;
+extern Stat_Counter_Id mpi_barrier_counter_;
+
+extern Stat_Counter_Id IO_EcrireFicPartageMPIIO_counter_;
+extern Stat_Counter_Id IO_EcrireFicPartageBin_counter_;
+
+extern Stat_Counter_Id echange_vect_counter_;
+extern Stat_Counter_Id solv_sys_counter_;
+extern Stat_Counter_Id solv_sys_petsc_counter_;
+extern Stat_Counter_Id diffusion_implicite_counter_;
+extern Stat_Counter_Id dt_counter_;
+extern Stat_Counter_Id nut_counter_;
+extern Stat_Counter_Id convection_counter_;
+extern Stat_Counter_Id diffusion_counter_;
+extern Stat_Counter_Id decay_counter_;
+extern Stat_Counter_Id source_counter_;
+extern Stat_Counter_Id divergence_counter_;
+extern Stat_Counter_Id gradient_counter_;
+extern Stat_Counter_Id postraitement_counter_;
+extern Stat_Counter_Id divers_counter_;
+extern Stat_Counter_Id sauvegarde_counter_;
+extern Stat_Counter_Id temporary_counter_;
+extern Stat_Counter_Id assemblage_sys_counter_;
+extern Stat_Counter_Id update_vars_counter_;
+extern Stat_Counter_Id update_fields_counter_;
+extern Stat_Counter_Id mettre_a_jour_counter_;
+extern Stat_Counter_Id timestep_counter_;
+extern Stat_Counter_Id interprete_scatter_counter_;
+extern Stat_Counter_Id temps_total_execution_counter_;
+extern Stat_Counter_Id initialisation_calcul_counter_;
+extern Stat_Counter_Id m1_counter_;
+extern Stat_Counter_Id m2_counter_;
+extern Stat_Counter_Id m3_counter_;
+
+extern Stat_Counter_Id probleme_fluide_;
+extern Stat_Counter_Id probleme_combustible_;
+
+extern Stat_Counter_Id gpu_copytodevice_counter_;
+extern Stat_Counter_Id gpu_copyfromdevice_counter_;
+extern Stat_Counter_Id gpu_library_counter_;
+extern Stat_Counter_Id gpu_kernel_counter_;
+
diff --git a/Utilities/VisItBridge/databases/visit_readers.xml b/Utilities/VisItBridge/databases/visit_readers.xml
index 09736b56..4313c8f0 100644
--- a/Utilities/VisItBridge/databases/visit_readers.xml
+++ b/Utilities/VisItBridge/databases/visit_readers.xml
@@ -827,7 +827,24 @@
       </SubProxy>
     </SourceProxy>
 
-    <SourceProxy name="VisItM3DReader" class="vtkVisItM3DReader" label="VisIt M3D Reader"
+    <SourceProxy name="VisItLataReader" class="vtkVisItLataReader" label="VisIt LATA Reader"
+    base_proxygroup="internal_readers" base_proxyname="VisItReaderBase">
+    <Documentation
+       long_help="Lata file reader">
+       Note this reader is automatically generated from wrapping a third party reader. For more information on the reader see https://wci.llnl.gov/codes/visit
+       The default file extensions is .lata
+    </Documentation>
+     <Hints>
+       <ReaderFactory extensions="lata"
+                      file_description="Lata Files" />
+       <ReaderFactory extensions="lml"
+                      file_description="LML Files" />
+       <ReaderFactory extensions="21"
+                      file_description="FORT21 Files" />
+     </Hints>
+    </SourceProxy>
+
+    <SourceProxy name="VisItM3DReader" class="vtkVisItM3DReader"  label="VisIt M3D Reader"
       base_proxygroup="internal_readers" base_proxyname="VisItReaderBase">
     <Documentation
        long_help="M3D fusion code reader">
-- 
2.48.1

